! function(t) {
    var e;
    "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t())
}(function() {
    return function s(n, r, a) {
        function h(i, t) {
            if (!r[i]) {
                if (!n[i]) {
                    var e = "function" == typeof require && require;
                    if (!t && e) return e(i, !0);
                    if (l) return l(i, !0);
                    throw new Error("Cannot find module '" + i + "'")
                }
                var o = r[i] = {
                    exports: {}
                };
                n[i][0].call(o.exports, function(t) {
                    var e = n[i][1][t];
                    return h(e || t)
                }, o, o.exports, s, n, r, a)
            }
            return r[i].exports
        }
        for (var l = "function" == typeof require && require, t = 0; t < a.length; t++) h(a[t]);
        return h
    }({
        1: [function(t, e, i) {
            var c = t("./Scalar");

            function o() {}(e.exports = o).lineInt = function(t, e, i) {
                i = i || 0;
                var o, s, n, r, a, h, l, d = [0, 0];
                return o = t[1][1] - t[0][1], s = t[0][0] - t[1][0], n = o * t[0][0] + s * t[0][1], r = e[1][1] - e[0][1], a = e[0][0] - e[1][0], h = r * e[0][0] + a * e[0][1], l = o * a - r * s, c.eq(l, 0, i) || (d[0] = (a * n - s * h) / l, d[1] = (o * h - r * n) / l), d
            }, o.segmentsIntersect = function(t, e, i, o) {
                var s = e[0] - t[0],
                    n = e[1] - t[1],
                    r = o[0] - i[0],
                    a = o[1] - i[1];
                if (r * n - a * s == 0) return !1;
                var h = (s * (i[1] - t[1]) + n * (t[0] - i[0])) / (r * n - a * s),
                    l = (r * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - r * n);
                return 0 <= h && h <= 1 && 0 <= l && l <= 1
            }
        }, {
            "./Scalar": 4
        }],
        2: [function(t, e, i) {
            function l() {}(e.exports = l).area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            }, l.left = function(t, e, i) {
                return 0 < l.area(t, e, i)
            }, l.leftOn = function(t, e, i) {
                return 0 <= l.area(t, e, i)
            }, l.right = function(t, e, i) {
                return l.area(t, e, i) < 0
            }, l.rightOn = function(t, e, i) {
                return l.area(t, e, i) <= 0
            };
            var d = [],
                c = [];
            l.collinear = function(t, e, i, o) {
                if (o) {
                    var s = d,
                        n = c;
                    s[0] = e[0] - t[0], s[1] = e[1] - t[1], n[0] = i[0] - e[0], n[1] = i[1] - e[1];
                    var r = s[0] * n[0] + s[1] * n[1],
                        a = Math.sqrt(s[0] * s[0] + s[1] * s[1]),
                        h = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
                    return Math.acos(r / (a * h)) < o
                }
                return 0 == l.area(t, e, i)
            }, l.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    o = e[1] - t[1];
                return i * i + o * o
            }
        }, {}],
        3: [function(t, e, i) {
            var a = t("./Line"),
                S = t("./Point"),
                u = t("./Scalar");

            function C() {
                this.vertices = []
            }(e.exports = C).prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, C.prototype.first = function() {
                return this.vertices[0]
            }, C.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }, C.prototype.clear = function() {
                this.vertices.length = 0
            }, C.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var o = e; o < i; o++) this.vertices.push(t.vertices[o])
            }, C.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                S.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, C.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, C.prototype.isReflex = function(t) {
                return S.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var h = [],
                l = [];

            function w(t, e, i, o, s) {
                s = s || 0;
                var n = e[1] - t[1],
                    r = t[0] - e[0],
                    a = n * t[0] + r * t[1],
                    h = o[1] - i[1],
                    l = i[0] - o[0],
                    d = h * i[0] + l * i[1],
                    c = n * l - h * r;
                return u.eq(c, 0, s) ? [0, 0] : [(l * a - r * d) / c, (n * d - h * a) / c]
            }
            C.prototype.canSee = function(t, e) {
                var i, o, s = h,
                    n = l;
                if (S.leftOn(this.at(t + 1), this.at(t), this.at(e)) && S.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                o = S.sqdist(this.at(t), this.at(e));
                for (var r = 0; r !== this.vertices.length; ++r)
                    if ((r + 1) % this.vertices.length !== t && r !== t && S.leftOn(this.at(t), this.at(e), this.at(r + 1)) && S.rightOn(this.at(t), this.at(e), this.at(r)) && (s[0] = this.at(t), s[1] = this.at(e), n[0] = this.at(r), n[1] = this.at(r + 1), i = a.lineInt(s, n), S.sqdist(this.at(t), i) < o)) return !1;
                return !0
            }, C.prototype.copy = function(t, e, i) {
                var o = i || new C;
                if (o.clear(), t < e)
                    for (var s = t; s <= e; s++) o.vertices.push(this.vertices[s]);
                else {
                    for (s = 0; s <= e; s++) o.vertices.push(this.vertices[s]);
                    for (s = t; s < this.vertices.length; s++) o.vertices.push(this.vertices[s])
                }
                return o
            }, C.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], o = new C, s = Number.MAX_VALUE, n = 0; n < this.vertices.length; ++n)
                    if (this.isReflex(n))
                        for (var r = 0; r < this.vertices.length; ++r)
                            if (this.canSee(n, r)) {
                                e = this.copy(n, r, o).getCutEdges(), i = this.copy(r, n, o).getCutEdges();
                                for (var a = 0; a < i.length; a++) e.push(i[a]);
                                e.length < s && (s = (t = e).length, t.push([this.at(n), this.at(r)]))
                            }
                return t
            }, C.prototype.decomp = function() {
                var t = this.getCutEdges();
                return 0 < t.length ? this.slice(t) : [this]
            }, C.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var o = t[i], s = 0; s < e.length; s++) {
                            var n = e[s].slice(o);
                            if (n) {
                                e.splice(s, 1), e.push(n[0], n[1]);
                                break
                            }
                        }
                    return e
                }
                o = t, i = this.vertices.indexOf(o[0]), s = this.vertices.indexOf(o[1]);
                return -1 != i && -1 != s && [this.copy(i, s), this.copy(s, i)]
            }, C.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (a.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (a.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, C.prototype.quickDecomp = function(t, e, i, o, s, n) {
                s = s || 100, n = n || 0, o = o || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var r = [0, 0],
                    a = [0, 0],
                    h = [0, 0],
                    l = 0,
                    d = 0,
                    c = 0,
                    u = 0,
                    p = 0,
                    b = 0,
                    m = 0,
                    y = new C,
                    f = new C,
                    x = this,
                    g = this.vertices;
                if (g.length < 3) return t;
                if (s < ++n) return t;
                for (var _ = 0; _ < this.vertices.length; ++_)
                    if (x.isReflex(_)) {
                        e.push(x.vertices[_]), l = d = Number.MAX_VALUE;
                        for (var v = 0; v < this.vertices.length; ++v) S.left(x.at(_ - 1), x.at(_), x.at(v)) && S.rightOn(x.at(_ - 1), x.at(_), x.at(v - 1)) && (h = w(x.at(_ - 1), x.at(_), x.at(v), x.at(v - 1)), S.right(x.at(_ + 1), x.at(_), h) && (c = S.sqdist(x.vertices[_], h)) < d && (d = c, a = h, b = v)), S.left(x.at(_ + 1), x.at(_), x.at(v + 1)) && S.rightOn(x.at(_ + 1), x.at(_), x.at(v)) && (h = w(x.at(_ + 1), x.at(_), x.at(v), x.at(v + 1)), S.left(x.at(_ - 1), x.at(_), h) && (c = S.sqdist(x.vertices[_], h)) < l && (l = c, r = h, p = v));
                        if (b == (p + 1) % this.vertices.length) h[0] = (a[0] + r[0]) / 2, h[1] = (a[1] + r[1]) / 2, i.push(h), _ < p ? (y.append(x, _, p + 1), y.vertices.push(h), f.vertices.push(h), 0 != b && f.append(x, b, x.vertices.length), f.append(x, 0, _ + 1)) : (0 != _ && y.append(x, _, x.vertices.length), y.append(x, 0, p + 1), y.vertices.push(h), f.vertices.push(h), f.append(x, b, _ + 1));
                        else {
                            if (p < b && (p += this.vertices.length), u = Number.MAX_VALUE, p < b) return t;
                            for (v = b; v <= p; ++v) S.leftOn(x.at(_ - 1), x.at(_), x.at(v)) && S.rightOn(x.at(_ + 1), x.at(_), x.at(v)) && (c = S.sqdist(x.at(_), x.at(v))) < u && (u = c, m = v % this.vertices.length);
                            _ < m ? (y.append(x, _, m + 1), 0 != m && f.append(x, m, g.length), f.append(x, 0, _ + 1)) : (0 != _ && y.append(x, _, g.length), y.append(x, 0, m + 1), f.append(x, m, _ + 1))
                        }
                        return y.vertices.length < f.vertices.length ? (y.quickDecomp(t, e, i, o, s, n), f.quickDecomp(t, e, i, o, s, n)) : (f.quickDecomp(t, e, i, o, s, n), y.quickDecomp(t, e, i, o, s, n)), t
                    }
                return t.push(this), t
            }, C.prototype.removeCollinearPoints = function(t) {
                for (var e = 0, i = this.vertices.length - 1; 3 < this.vertices.length && 0 <= i; --i) S.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(t, e, i) {
            function o() {}(e.exports = o).eq = function(t, e, i) {
                return i = i || 0, Math.abs(t - e) < i
            }
        }, {}],
        5: [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        }, {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            }
        }, {}],
        7: [function(t, e, i) {
            var p = t("../math/vec2");
            t("../utils/Utils");

            function o(t) {
                this.lowerBound = p.create(), t && t.lowerBound && p.copy(this.lowerBound, t.lowerBound), this.upperBound = p.create(), t && t.upperBound && p.copy(this.upperBound, t.upperBound)
            }
            e.exports = o;
            var b = p.create();
            o.prototype.setFromPoints = function(t, e, i, o) {
                var s = this.lowerBound,
                    n = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? p.rotate(s, t[0], i) : p.copy(s, t[0]), p.copy(n, s);
                for (var r = Math.cos(i), a = Math.sin(i), h = 1; h < t.length; h++) {
                    var l = t[h];
                    if (0 !== i) {
                        var d = l[0],
                            c = l[1];
                        b[0] = r * d - a * c, b[1] = a * d + r * c, l = b
                    }
                    for (var u = 0; u < 2; u++) l[u] > n[u] && (n[u] = l[u]), l[u] < s[u] && (s[u] = l[u])
                }
                e && (p.add(this.lowerBound, this.lowerBound, e), p.add(this.upperBound, this.upperBound, e)), o && (this.lowerBound[0] -= o, this.lowerBound[1] -= o, this.upperBound[0] += o, this.upperBound[1] += o)
            }, o.prototype.copy = function(t) {
                p.copy(this.lowerBound, t.lowerBound), p.copy(this.upperBound, t.upperBound)
            }, o.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var o = t.upperBound[e];
                    this.upperBound[e] < o && (this.upperBound[e] = o)
                }
            }, o.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    o = t.lowerBound,
                    s = t.upperBound;
                return (o[0] <= i[0] && i[0] <= s[0] || e[0] <= s[0] && s[0] <= i[0]) && (o[1] <= i[1] && i[1] <= s[1] || e[1] <= s[1] && s[1] <= i[1])
            }, o.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, o.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    o = (this.lowerBound[0] - t.from[0]) * e,
                    s = (this.upperBound[0] - t.from[0]) * e,
                    n = (this.lowerBound[1] - t.from[1]) * i,
                    r = (this.upperBound[1] - t.from[1]) * i,
                    a = Math.max(Math.max(Math.min(o, s), Math.min(n, r))),
                    h = Math.min(Math.min(Math.max(o, s), Math.max(n, r)));
                return h < 0 ? -1 : h < a ? -1 : a
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(t, e, i) {
            var s = t("../math/vec2"),
                n = t("../objects/Body");

            function o(t) {
                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = o.AABB
            }(e.exports = o).AABB = 1, o.BOUNDING_CIRCLE = 2, o.prototype.setWorld = function(t) {
                this.world = t
            }, o.prototype.getCollisionPairs = function(t) {};
            var r = s.create();
            o.boundingRadiusCheck = function(t, e) {
                s.sub(r, t.position, e.position);
                var i = s.squaredLength(r),
                    o = t.boundingRadius + e.boundingRadius;
                return i <= o * o
            }, o.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            }, o.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case o.BOUNDING_CIRCLE:
                        i = o.boundingRadiusCheck(t, e);
                        break;
                    case o.AABB:
                        i = o.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, o.canCollide = function(t, e) {
                var i = n.KINEMATIC,
                    o = n.STATIC;
                return (t.type !== o || e.type !== o) && (!(t.type === i && e.type === o || t.type === o && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== n.SLEEPING || e.sleepState !== n.SLEEPING) && !(t.sleepState === n.SLEEPING && e.type === o || e.sleepState === n.SLEEPING && t.type === o))))
            }, o.NAIVE = 1, o.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(t, e, i) {
            t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle");
            var h = t("../collision/Broadphase");
            t("../math/vec2");

            function o() {
                h.call(this, h.NAIVE)
            }(((e.exports = o).prototype = new h).constructor = o).prototype.getCollisionPairs = function(t) {
                for (var e = t.bodies, i = this.result, o = i.length = 0, s = e.length; o !== s; o++)
                    for (var n = e[o], r = 0; r < o; r++) {
                        var a = e[r];
                        h.canCollide(n, a) && this.boundingVolumeCheck(n, a) && i.push(n, a)
                    }
                return i
            }, o.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var o = t.bodies, s = 0; s < o.length; s++) {
                    var n = o[s];
                    n.aabbNeedsUpdate && n.updateAABB(), n.aabb.overlaps(e) && i.push(n)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(t, e, i) {
            var J = t("../math/vec2"),
                U = J.sub,
                W = J.add,
                X = J.dot,
                o = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                s = t("../utils/FrictionEquationPool"),
                n = t("../utils/TupleDictionary"),
                r = t("../equations/Equation"),
                a = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                h = t("../shapes/Convex"),
                l = t("../shapes/Shape"),
                C = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = $;
            var w = J.fromValues(0, 1),
                q = J.fromValues(0, 0),
                j = J.fromValues(0, 0),
                Y = J.fromValues(0, 0),
                z = J.fromValues(0, 0),
                H = J.fromValues(0, 0),
                L = J.fromValues(0, 0),
                K = J.fromValues(0, 0),
                Q = J.fromValues(0, 0),
                Z = J.fromValues(0, 0),
                D = J.fromValues(0, 0),
                F = J.fromValues(0, 0),
                k = J.fromValues(0, 0),
                G = J.fromValues(0, 0),
                O = J.fromValues(0, 0),
                E = J.fromValues(0, 0),
                I = J.fromValues(0, 0),
                B = J.fromValues(0, 0),
                M = J.fromValues(0, 0),
                N = [];

            function $() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new o({
                    size: 32
                }), this.frictionEquationPool = new s({
                    size: 64
                }), this.restitution = 0, this.stiffness = r.DEFAULT_STIFFNESS, this.relaxation = r.DEFAULT_RELAXATION, this.frictionStiffness = r.DEFAULT_STIFFNESS, this.frictionRelaxation = r.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new n, this.contactSkinSize = .01
            }
            var d = J.create(),
                c = J.create();

            function g(t, e) {
                J.set(t.vertices[0], .5 * -e.length, -e.radius), J.set(t.vertices[1], .5 * e.length, -e.radius), J.set(t.vertices[2], .5 * e.length, e.radius), J.set(t.vertices[3], .5 * -e.length, e.radius)
            }
            $.prototype.bodiesOverlap = function(t, e) {
                for (var i = d, o = c, s = 0, n = t.shapes.length; s !== n; s++) {
                    var r = t.shapes[s];
                    t.toWorldFrame(i, r.position);
                    for (var a = 0, h = e.shapes.length; a !== h; a++) {
                        var l = e.shapes[a];
                        if (e.toWorldFrame(o, l.position), this[r.type | l.type](t, r, i, r.angle + t.angle, e, l, o, l.angle + e.angle, !0)) return !0
                    }
                }
                return !1
            }, $.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                    o = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(i, o)
            }, $.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        o = i.bodyA.id,
                        s = i.bodyB.id;
                    this.collidingBodiesLastStep.set(o, s, !0)
                }
                for (var n = this.contactEquations, r = this.frictionEquations, a = 0; a < n.length; a++) this.contactEquationPool.release(n[a]);
                for (a = 0; a < r.length; a++) this.frictionEquationPool.release(r[a]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, $.prototype.createContactEquation = function(t, e, i, o) {
                var s = this.contactEquationPool.get();
                return s.bodyA = t, s.bodyB = e, s.shapeA = i, s.shapeB = o, s.restitution = this.restitution, s.firstImpact = !this.collidedLastStep(t, e), s.stiffness = this.stiffness, s.relaxation = this.relaxation, s.needsUpdate = !0, s.enabled = this.enabledEquations, s.offset = this.contactSkinSize, s
            }, $.prototype.createFrictionEquation = function(t, e, i, o) {
                var s = this.frictionEquationPool.get();
                return s.bodyA = t, s.bodyB = e, s.shapeA = i, s.shapeB = o, s.setSlipForce(this.slipForce), s.frictionCoefficient = this.frictionCoefficient, s.relativeVelocity = this.surfaceVelocity, s.enabled = this.enabledEquations, s.needsUpdate = !0, s.stiffness = this.frictionStiffness, s.relaxation = this.frictionRelaxation, s.contactEquations.length = 0, s
            }, $.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return J.copy(e.contactPointA, t.contactPointA), J.copy(e.contactPointB, t.contactPointB), J.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
            }, $.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    o = e.bodyA;
                e.bodyB;
                J.set(i.contactPointA, 0, 0), J.set(i.contactPointB, 0, 0), J.set(i.t, 0, 0);
                for (var s = 0; s !== t; s++)(e = this.contactEquations[this.contactEquations.length - 1 - s]).bodyA === o ? (J.add(i.t, i.t, e.normalA), J.add(i.contactPointA, i.contactPointA, e.contactPointA), J.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (J.sub(i.t, i.t, e.normalA), J.add(i.contactPointA, i.contactPointA, e.contactPointB), J.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var n = 1 / t;
                return J.scale(i.contactPointA, i.contactPointA, n), J.scale(i.contactPointB, i.contactPointB, n), J.normalize(i.t, i.t), J.rotate90cw(i.t, i.t), i
            }, $.prototype[l.LINE | l.CONVEX] = $.prototype.convexLine = function(t, e, i, o, s, n, r, a, h) {
                return !h && 0
            }, $.prototype[l.LINE | l.BOX] = $.prototype.lineBox = function(t, e, i, o, s, n, r, a, h) {
                return !h && 0
            };
            var p = new C({
                    width: 1,
                    height: 1
                }),
                b = J.create();
            $.prototype[l.CAPSULE | l.CONVEX] = $.prototype[l.CAPSULE | l.BOX] = $.prototype.convexCapsule = function(t, e, i, o, s, n, r, a, h) {
                var l = b;
                J.set(l, n.length / 2, 0), J.rotate(l, l, a), J.add(l, l, r);
                var d = this.circleConvex(s, n, l, a, t, e, i, o, h, n.radius);
                J.set(l, -n.length / 2, 0), J.rotate(l, l, a), J.add(l, l, r);
                var c = this.circleConvex(s, n, l, a, t, e, i, o, h, n.radius);
                if (h && (d || c)) return !0;
                var u = p;
                return g(u, n), this.convexConvex(t, e, i, o, s, u, r, a, h) + d + c
            }, $.prototype[l.CAPSULE | l.LINE] = $.prototype.lineCapsule = function(t, e, i, o, s, n, r, a, h) {
                return !h && 0
            };
            var _ = J.create(),
                v = J.create(),
                S = new C({
                    width: 1,
                    height: 1
                });
            $.prototype[l.CAPSULE | l.CAPSULE] = $.prototype.capsuleCapsule = function(t, e, i, o, s, n, r, a, h) {
                for (var l = _, d = v, c = 0, u = 0; u < 2; u++) {
                    J.set(l, (0 === u ? -1 : 1) * e.length / 2, 0), J.rotate(l, l, o), J.add(l, l, i);
                    for (var p = 0; p < 2; p++) {
                        J.set(d, (0 === p ? -1 : 1) * n.length / 2, 0), J.rotate(d, d, a), J.add(d, d, r), this.enableFrictionReduction && (f = this.enableFriction, this.enableFriction = !1);
                        var b = this.circleCircle(t, e, l, o, s, n, d, a, h, e.radius, n.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = f), h && b) return !0;
                        c += b
                    }
                }
                this.enableFrictionReduction && (f = this.enableFriction, this.enableFriction = !1);
                var m = S;
                g(m, e);
                var y = this.convexCapsule(t, m, i, o, s, n, r, a, h);
                if (this.enableFrictionReduction && (this.enableFriction = f), h && y) return !0;
                if (c += y, this.enableFrictionReduction) {
                    var f = this.enableFriction;
                    this.enableFriction = !1
                }
                g(m, n);
                var x = this.convexCapsule(s, m, r, a, t, e, i, o, h);
                return this.enableFrictionReduction && (this.enableFriction = f), !(!h || !x) || (c += x, this.enableFrictionReduction && c && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(c)), c)
            }, $.prototype[l.LINE | l.LINE] = $.prototype.lineLine = function(t, e, i, o, s, n, r, a, h) {
                return !h && 0
            }, $.prototype[l.PLANE | l.LINE] = $.prototype.planeLine = function(t, e, i, o, s, n, r, a, h) {
                var l = q,
                    d = j,
                    c = Y,
                    u = z,
                    p = H,
                    b = L,
                    m = K,
                    y = Q,
                    f = Z,
                    x = N,
                    g = 0;
                J.set(l, -n.length / 2, 0), J.set(d, n.length / 2, 0), J.rotate(c, l, a), J.rotate(u, d, a), W(c, c, r), W(u, u, r), J.copy(l, c), J.copy(d, u), U(p, d, l), J.normalize(b, p), J.rotate90cw(f, b), J.rotate(y, w, o), x[0] = l, x[1] = d;
                for (var _ = 0; _ < x.length; _++) {
                    var v = x[_];
                    U(m, v, i);
                    var S = X(m, y);
                    if (S < 0) {
                        if (h) return !0;
                        var C = this.createContactEquation(t, s, e, n);
                        g++, J.copy(C.normalA, y), J.normalize(C.normalA, C.normalA), J.scale(m, y, S), U(C.contactPointA, v, m), U(C.contactPointA, C.contactPointA, t.position), U(C.contactPointB, v, r), W(C.contactPointB, C.contactPointB, r), U(C.contactPointB, C.contactPointB, s.position), this.contactEquations.push(C), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C))
                    }
                }
                return !h && (this.enableFrictionReduction || g && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(g)), g)
            }, $.prototype[l.PARTICLE | l.CAPSULE] = $.prototype.particleCapsule = function(t, e, i, o, s, n, r, a, h) {
                return this.circleLine(t, e, i, o, s, n, r, a, h, n.radius, 0)
            }, $.prototype[l.CIRCLE | l.LINE] = $.prototype.circleLine = function(t, e, i, o, s, n, r, a, h, l, d) {
                l = l || 0, d = void 0 !== d ? d : e.radius;
                var c = q,
                    u = j,
                    p = Y,
                    b = z,
                    m = H,
                    y = L,
                    f = K,
                    x = Q,
                    g = Z,
                    _ = D,
                    v = F,
                    S = k,
                    C = G,
                    w = O,
                    A = N;
                J.set(x, -n.length / 2, 0), J.set(g, n.length / 2, 0), J.rotate(_, x, a), J.rotate(v, g, a), W(_, _, r), W(v, v, r), J.copy(x, _), J.copy(g, v), U(y, g, x), J.normalize(f, y), J.rotate90cw(m, f), U(S, i, x);
                var P = X(S, m);
                U(b, x, r), U(C, i, r);
                var T = d + l;
                if (Math.abs(P) < T) {
                    J.scale(c, m, P), U(p, i, c), J.scale(u, m, X(m, C)), J.normalize(u, u), J.scale(u, u, l), W(p, p, u);
                    var B = X(f, p),
                        M = X(f, x),
                        E = X(f, g);
                    if (M < B && B < E) {
                        if (h) return !0;
                        var I = this.createContactEquation(t, s, e, n);
                        return J.scale(I.normalA, c, -1), J.normalize(I.normalA, I.normalA), J.scale(I.contactPointA, I.normalA, d), W(I.contactPointA, I.contactPointA, i), U(I.contactPointA, I.contactPointA, t.position), U(I.contactPointB, p, r), W(I.contactPointB, I.contactPointB, r), U(I.contactPointB, I.contactPointB, s.position), this.contactEquations.push(I), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(I)), 1
                    }
                }
                A[0] = x, A[1] = g;
                for (var V = 0; V < A.length; V++) {
                    var R = A[V];
                    if (U(S, R, i), J.squaredLength(S) < Math.pow(T, 2)) {
                        if (h) return !0;
                        I = this.createContactEquation(t, s, e, n);
                        return J.copy(I.normalA, S), J.normalize(I.normalA, I.normalA), J.scale(I.contactPointA, I.normalA, d), W(I.contactPointA, I.contactPointA, i), U(I.contactPointA, I.contactPointA, t.position), U(I.contactPointB, R, r), J.scale(w, I.normalA, -l), W(I.contactPointB, I.contactPointB, w), W(I.contactPointB, I.contactPointB, r), U(I.contactPointB, I.contactPointB, s.position), this.contactEquations.push(I), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(I)), 1
                    }
                }
                return 0
            }, $.prototype[l.CIRCLE | l.CAPSULE] = $.prototype.circleCapsule = function(t, e, i, o, s, n, r, a, h) {
                return this.circleLine(t, e, i, o, s, n, r, a, h, n.radius)
            }, $.prototype[l.CIRCLE | l.CONVEX] = $.prototype[l.CIRCLE | l.BOX] = $.prototype.circleConvex = function(t, e, i, o, s, n, r, a, h, l) {
                l = "number" == typeof l ? l : e.radius;
                for (var d = q, c = j, u = Y, p = z, b = H, m = D, y = F, f = G, x = O, g = E, _ = I, v = !1, S = Number.MAX_VALUE, C = n.vertices, w = 0; w !== C.length + 1; w++) {
                    var A = C[w % C.length],
                        P = C[(w + 1) % C.length];
                    if (J.rotate(d, A, a), J.rotate(c, P, a), W(d, d, r), W(c, c, r), U(u, c, d), J.normalize(p, u), J.rotate90cw(b, p), J.scale(x, b, -e.radius), W(x, x, i), V(x, n, r, a)) {
                        J.sub(g, d, x);
                        var T = Math.abs(J.dot(g, b));
                        T < S && (J.copy(_, x), S = T, J.scale(f, b, T), J.add(f, f, x), v = !0)
                    }
                }
                if (v) {
                    if (h) return !0;
                    var B = this.createContactEquation(t, s, e, n);
                    return J.sub(B.normalA, _, i), J.normalize(B.normalA, B.normalA), J.scale(B.contactPointA, B.normalA, l), W(B.contactPointA, B.contactPointA, i), U(B.contactPointA, B.contactPointA, t.position), U(B.contactPointB, f, r), W(B.contactPointB, B.contactPointB, r), U(B.contactPointB, B.contactPointB, s.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1
                }
                if (0 < l)
                    for (w = 0; w < C.length; w++) {
                        var M = C[w];
                        if (J.rotate(y, M, a), W(y, y, r), U(m, y, i), J.squaredLength(m) < Math.pow(l, 2)) {
                            if (h) return !0;
                            B = this.createContactEquation(t, s, e, n);
                            return J.copy(B.normalA, m), J.normalize(B.normalA, B.normalA), J.scale(B.contactPointA, B.normalA, l), W(B.contactPointA, B.contactPointA, i), U(B.contactPointA, B.contactPointA, t.position), U(B.contactPointB, y, r), W(B.contactPointB, B.contactPointB, r), U(B.contactPointB, B.contactPointB, s.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1
                        }
                    }
                return 0
            };
            var m = J.create(),
                y = J.create(),
                f = J.create(),
                x = J.create();

            function V(t, e, i, o) {
                for (var s = m, n = y, r = f, a = x, h = t, l = e.vertices, d = null, c = 0; c !== l.length + 1; c++) {
                    var u = l[c % l.length],
                        p = l[(c + 1) % l.length];
                    J.rotate(s, u, o), J.rotate(n, p, o), W(s, s, i), W(n, n, i), U(r, s, h), U(a, n, h);
                    var b = J.crossLength(r, a);
                    if (null === d && (d = b), b * d <= 0) return !1;
                    d = b
                }
                return !0
            }
            $.prototype[l.PARTICLE | l.CONVEX] = $.prototype[l.PARTICLE | l.BOX] = $.prototype.particleConvex = function(t, e, i, o, s, n, r, a, h) {
                var l = q,
                    d = j,
                    c = Y,
                    u = z,
                    p = H,
                    b = L,
                    m = K,
                    y = D,
                    f = G,
                    x = B,
                    g = M,
                    _ = Number.MAX_VALUE,
                    v = !1,
                    S = n.vertices;
                if (!V(i, n, r, a)) return 0;
                if (h) return !0;
                for (var C = 0; C !== S.length + 1; C++) {
                    var w = S[C % S.length],
                        A = S[(C + 1) % S.length];
                    J.rotate(l, w, a), J.rotate(d, A, a), W(l, l, r), W(d, d, r), U(c, d, l), J.normalize(u, c), J.rotate90cw(p, u), U(y, i, l);
                    X(y, p);
                    U(b, l, r), U(m, i, r), J.sub(x, l, i);
                    var P = Math.abs(J.dot(x, p));
                    P < _ && (_ = P, J.scale(f, p, P), J.add(f, f, i), J.copy(g, p), v = !0)
                }
                if (v) {
                    var T = this.createContactEquation(t, s, e, n);
                    return J.scale(T.normalA, g, -1), J.normalize(T.normalA, T.normalA), J.set(T.contactPointA, 0, 0), W(T.contactPointA, T.contactPointA, i), U(T.contactPointA, T.contactPointA, t.position), U(T.contactPointB, f, r), W(T.contactPointB, T.contactPointB, r), U(T.contactPointB, T.contactPointB, s.position), this.contactEquations.push(T), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(T)), 1
                }
                return 0
            }, $.prototype[l.CIRCLE] = $.prototype.circleCircle = function(t, e, i, o, s, n, r, a, h, l, d) {
                var c = q;
                l = l || e.radius, d = d || n.radius;
                U(c, i, r);
                var u = l + d;
                if (J.squaredLength(c) > Math.pow(u, 2)) return 0;
                if (h) return !0;
                var p = this.createContactEquation(t, s, e, n);
                return U(p.normalA, r, i), J.normalize(p.normalA, p.normalA), J.scale(p.contactPointA, p.normalA, l), J.scale(p.contactPointB, p.normalA, -d), W(p.contactPointA, p.contactPointA, i), U(p.contactPointA, p.contactPointA, t.position), W(p.contactPointB, p.contactPointB, r), U(p.contactPointB, p.contactPointB, s.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
            }, $.prototype[l.PLANE | l.CONVEX] = $.prototype[l.PLANE | l.BOX] = $.prototype.planeConvex = function(t, e, i, o, s, n, r, a, h) {
                var l = q,
                    d = j,
                    c = Y,
                    u = 0;
                J.rotate(d, w, o);
                for (var p = 0; p !== n.vertices.length; p++) {
                    var b = n.vertices[p];
                    if (J.rotate(l, b, a), W(l, l, r), U(c, l, i), X(c, d) <= 0) {
                        if (h) return !0;
                        u++;
                        var m = this.createContactEquation(t, s, e, n);
                        U(c, l, i), J.copy(m.normalA, d);
                        var y = X(c, m.normalA);
                        J.scale(c, m.normalA, y), U(m.contactPointB, l, s.position), U(m.contactPointA, l, c), U(m.contactPointA, m.contactPointA, t.position), this.contactEquations.push(m), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(m))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && u && this.frictionEquations.push(this.createFrictionFromAverage(u)), u
            }, $.prototype[l.PARTICLE | l.PLANE] = $.prototype.particlePlane = function(t, e, i, o, s, n, r, a, h) {
                var l = q,
                    d = j;
                a = a || 0, U(l, i, r), J.rotate(d, w, a);
                var c = X(l, d);
                if (0 < c) return 0;
                if (h) return !0;
                var u = this.createContactEquation(s, t, n, e);
                return J.copy(u.normalA, d), J.scale(l, u.normalA, c), U(u.contactPointA, i, l), U(u.contactPointA, u.contactPointA, s.position), U(u.contactPointB, i, t.position), this.contactEquations.push(u), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(u)), 1
            }, $.prototype[l.CIRCLE | l.PARTICLE] = $.prototype.circleParticle = function(t, e, i, o, s, n, r, a, h) {
                var l = q;
                if (U(l, r, i), J.squaredLength(l) > Math.pow(e.radius, 2)) return 0;
                if (h) return !0;
                var d = this.createContactEquation(t, s, e, n);
                return J.copy(d.normalA, l), J.normalize(d.normalA, d.normalA), J.scale(d.contactPointA, d.normalA, e.radius), W(d.contactPointA, d.contactPointA, i), U(d.contactPointA, d.contactPointA, t.position), U(d.contactPointB, r, s.position), this.contactEquations.push(d), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d)), 1
            };
            var A = new a({
                    radius: 1
                }),
                P = J.create(),
                T = J.create();
            J.create();
            $.prototype[l.PLANE | l.CAPSULE] = $.prototype.planeCapsule = function(t, e, i, o, s, n, r, a, h) {
                var l, d = P,
                    c = T,
                    u = A;
                J.set(d, -n.length / 2, 0), J.rotate(d, d, a), W(d, d, r), J.set(c, n.length / 2, 0), J.rotate(c, c, a), W(c, c, r), u.radius = n.radius, this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                var p = this.circlePlane(s, u, d, 0, t, e, i, o, h),
                    b = this.circlePlane(s, u, c, 0, t, e, i, o, h);
                if (this.enableFrictionReduction && (this.enableFriction = l), h) return p || b;
                var m = p + b;
                return this.enableFrictionReduction && m && this.frictionEquations.push(this.createFrictionFromAverage(m)), m
            }, $.prototype[l.CIRCLE | l.PLANE] = $.prototype.circlePlane = function(t, e, i, o, s, n, r, a, h) {
                var l = t,
                    d = e,
                    c = i,
                    u = s,
                    p = r,
                    b = a;
                b = b || 0;
                var m = q,
                    y = j,
                    f = Y;
                U(m, c, p), J.rotate(y, w, b);
                var x = X(y, m);
                if (x > d.radius) return 0;
                if (h) return !0;
                var g = this.createContactEquation(u, l, n, e);
                return J.copy(g.normalA, y), J.scale(g.contactPointB, g.normalA, -d.radius), W(g.contactPointB, g.contactPointB, c), U(g.contactPointB, g.contactPointB, l.position), J.scale(f, g.normalA, x), U(g.contactPointA, m, f), W(g.contactPointA, g.contactPointA, p), U(g.contactPointA, g.contactPointA, u.position), this.contactEquations.push(g), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g)), 1
            }, $.prototype[l.CONVEX] = $.prototype[l.CONVEX | l.BOX] = $.prototype[l.BOX] = $.prototype.convexConvex = function(t, e, i, o, s, n, r, a, h, l) {
                var d = q,
                    c = j,
                    u = Y,
                    p = z,
                    b = H,
                    m = K,
                    y = Q,
                    f = Z,
                    x = 0;
                l = "number" == typeof l ? l : 0;
                if (!$.findSeparatingAxis(e, i, o, n, r, a, d)) return 0;
                U(y, r, i), 0 < X(d, y) && J.scale(d, d, -1);
                var g = $.getClosestEdge(e, o, d, !0),
                    _ = $.getClosestEdge(n, a, d);
                if (-1 === g || -1 === _) return 0;
                for (var v = 0; v < 2; v++) {
                    var S, C = g,
                        w = _,
                        A = e,
                        P = n,
                        T = i,
                        B = r,
                        M = o,
                        E = a,
                        I = t,
                        V = s;
                    if (0 === v) S = C, C = w, w = S, S = A, A = P, P = S, S = T, T = B, B = S, S = M, M = E, E = S, S = I, I = V, V = S;
                    for (var R = w; R < w + 2; R++) {
                        var L = P.vertices[(R + P.vertices.length) % P.vertices.length];
                        J.rotate(c, L, E), W(c, c, B);
                        for (var D = 0, F = C - 1; F < C + 2; F++) {
                            var k = A.vertices[(F + A.vertices.length) % A.vertices.length],
                                G = A.vertices[(F + 1 + A.vertices.length) % A.vertices.length];
                            J.rotate(u, k, M), J.rotate(p, G, M), W(u, u, T), W(p, p, T), U(b, p, u), J.rotate90cw(f, b), J.normalize(f, f), U(y, c, u);
                            var O = X(f, y);
                            (F === C && O <= l || F !== C && O <= 0) && D++
                        }
                        if (3 <= D) {
                            if (h) return !0;
                            var N = this.createContactEquation(I, V, A, P);
                            x++;
                            k = A.vertices[C % A.vertices.length], G = A.vertices[(C + 1) % A.vertices.length];
                            J.rotate(u, k, M), J.rotate(p, G, M), W(u, u, T), W(p, p, T), U(b, p, u), J.rotate90cw(N.normalA, b), J.normalize(N.normalA, N.normalA), U(y, c, u);
                            O = X(N.normalA, y);
                            J.scale(m, N.normalA, O), U(N.contactPointA, c, T), U(N.contactPointA, N.contactPointA, m), W(N.contactPointA, N.contactPointA, T), U(N.contactPointA, N.contactPointA, I.position), U(N.contactPointB, c, B), W(N.contactPointB, N.contactPointB, B), U(N.contactPointB, N.contactPointB, V.position), this.contactEquations.push(N), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(N))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && x && this.frictionEquations.push(this.createFrictionFromAverage(x)), x
            };
            var R = J.fromValues(0, 0);
            $.projectConvexOntoAxis = function(t, e, i, o, s) {
                var n, r, a = null,
                    h = null,
                    l = R;
                J.rotate(l, o, -i);
                for (var d = 0; d < t.vertices.length; d++) n = t.vertices[d], r = X(n, l), (null === a || a < r) && (a = r), (null === h || r < h) && (h = r);
                if (a < h) {
                    var c = h;
                    h = a, a = c
                }
                var u = X(e, o);
                J.set(s, h + u, a + u)
            };
            var tt = J.fromValues(0, 0),
                et = J.fromValues(0, 0),
                it = J.fromValues(0, 0),
                ot = J.fromValues(0, 0),
                st = J.fromValues(0, 0),
                nt = J.fromValues(0, 0);
            $.findSeparatingAxis = function(t, e, i, o, s, n, r) {
                var a = null,
                    h = !1,
                    l = !1,
                    d = tt,
                    c = et,
                    u = it,
                    p = ot,
                    b = st,
                    m = nt;
                if (t instanceof C && o instanceof C)
                    for (var y = 0; 2 !== y; y++) {
                        var f = t,
                            x = i;
                        1 === y && (f = o, x = n);
                        for (var g = 0; 2 !== g; g++) {
                            0 === g ? J.set(p, 0, 1) : 1 === g && J.set(p, 1, 0), 0 !== x && J.rotate(p, p, x), $.projectConvexOntoAxis(t, e, i, p, b), $.projectConvexOntoAxis(o, s, n, p, m);
                            var _ = b,
                                v = m;
                            b[0] > m[0] && (v = b, _ = m, !0), h = (S = v[0] - _[1]) <= 0, (null === a || a < S) && (J.copy(r, p), a = S, l = h)
                        }
                    } else
                        for (y = 0; 2 !== y; y++) {
                            f = t, x = i;
                            1 === y && (f = o, x = n);
                            for (g = 0; g !== f.vertices.length; g++) {
                                J.rotate(c, f.vertices[g], x), J.rotate(u, f.vertices[(g + 1) % f.vertices.length], x), U(d, u, c), J.rotate90cw(p, d), J.normalize(p, p), $.projectConvexOntoAxis(t, e, i, p, b), $.projectConvexOntoAxis(o, s, n, p, m);
                                var S;
                                _ = b, v = m;
                                b[0] > m[0] && (v = b, _ = m, !0), h = (S = v[0] - _[1]) <= 0, (null === a || a < S) && (J.copy(r, p), a = S, l = h)
                            }
                        }
                return l
            };
            var u = J.fromValues(0, 0),
                rt = J.fromValues(0, 0),
                at = J.fromValues(0, 0);
            $.getClosestEdge = function(t, e, i, o) {
                var s = u,
                    n = rt,
                    r = at;
                J.rotate(s, i, -e), o && J.scale(s, s, -1);
                for (var a = -1, h = t.vertices.length, l = -1, d = 0; d !== h; d++) {
                    U(n, t.vertices[(d + 1) % h], t.vertices[d % h]), J.rotate90cw(r, n), J.normalize(r, r);
                    var c = X(r, s);
                    (-1 === a || l < c) && (a = d % h, l = c)
                }
                return a
            };
            var ht = J.create(),
                lt = J.create(),
                dt = J.create(),
                ct = J.create(),
                ut = J.create(),
                pt = J.create(),
                bt = J.create();
            $.prototype[l.CIRCLE | l.HEIGHTFIELD] = $.prototype.circleHeightfield = function(t, e, i, o, s, n, r, a, h, l) {
                var d = n.heights,
                    c = (l = l || e.radius, n.elementWidth),
                    u = lt,
                    p = ht,
                    b = ut,
                    m = bt,
                    y = pt,
                    f = dt,
                    x = ct,
                    g = Math.floor((i[0] - l - r[0]) / c),
                    _ = Math.ceil((i[0] + l - r[0]) / c);
                g < 0 && (g = 0), _ >= d.length && (_ = d.length - 1);
                for (var v = d[g], S = d[_], C = g; C < _; C++) d[C] < S && (S = d[C]), d[C] > v && (v = d[C]);
                if (i[1] - l > v) return !h && 0;
                var w = !1;
                for (C = g; C < _; C++) {
                    J.set(f, C * c, d[C]), J.set(x, (C + 1) * c, d[C + 1]), J.add(f, f, r), J.add(x, x, r), J.sub(y, x, f), J.rotate(y, y, Math.PI / 2), J.normalize(y, y), J.scale(p, y, -l), J.add(p, p, i), J.sub(u, p, f);
                    var A = J.dot(u, y);
                    if (p[0] >= f[0] && p[0] < x[0] && A <= 0) {
                        if (h) return !0;
                        w = !0, J.scale(u, y, -A), J.add(b, p, u), J.copy(m, y);
                        var P = this.createContactEquation(s, t, n, e);
                        J.copy(P.normalA, m), J.scale(P.contactPointB, P.normalA, -l), W(P.contactPointB, P.contactPointB, i), U(P.contactPointB, P.contactPointB, t.position), J.copy(P.contactPointA, b), J.sub(P.contactPointA, P.contactPointA, s.position), this.contactEquations.push(P), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P))
                    }
                }
                if (w = !1, 0 < l)
                    for (C = g; C <= _; C++)
                        if (J.set(f, C * c, d[C]), J.add(f, f, r), J.sub(u, i, f), J.squaredLength(u) < Math.pow(l, 2)) {
                            if (h) return !0;
                            w = !0;
                            P = this.createContactEquation(s, t, n, e);
                            J.copy(P.normalA, u), J.normalize(P.normalA, P.normalA), J.scale(P.contactPointB, P.normalA, -l), W(P.contactPointB, P.contactPointB, i), U(P.contactPointB, P.contactPointB, t.position), U(P.contactPointA, f, r), W(P.contactPointA, P.contactPointA, r), U(P.contactPointA, P.contactPointA, s.position), this.contactEquations.push(P), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P))
                        }
                return w ? 1 : 0
            };
            var mt = J.create(),
                yt = J.create(),
                ft = J.create(),
                xt = new h({
                    vertices: [J.create(), J.create(), J.create(), J.create()]
                });
            $.prototype[l.BOX | l.HEIGHTFIELD] = $.prototype[l.CONVEX | l.HEIGHTFIELD] = $.prototype.convexHeightfield = function(t, e, i, o, s, n, r, a, h) {
                var l = n.heights,
                    d = n.elementWidth,
                    c = mt,
                    u = yt,
                    p = ft,
                    b = xt,
                    m = Math.floor((t.aabb.lowerBound[0] - r[0]) / d),
                    y = Math.ceil((t.aabb.upperBound[0] - r[0]) / d);
                m < 0 && (m = 0), y >= l.length && (y = l.length - 1);
                for (var f = l[m], x = l[y], g = m; g < y; g++) l[g] < x && (x = l[g]), l[g] > f && (f = l[g]);
                if (t.aabb.lowerBound[1] > f) return !h && 0;
                var _ = 0;
                for (g = m; g < y; g++) {
                    J.set(c, g * d, l[g]), J.set(u, (g + 1) * d, l[g + 1]), J.add(c, c, r), J.add(u, u, r);
                    J.set(p, .5 * (u[0] + c[0]), .5 * (u[1] + c[1] - 100)), J.sub(b.vertices[0], u, p), J.sub(b.vertices[1], c, p), J.copy(b.vertices[2], b.vertices[1]), J.copy(b.vertices[3], b.vertices[0]), b.vertices[2][1] -= 100, b.vertices[3][1] -= 100, _ += this.convexConvex(t, e, i, o, s, b, p, 0, h)
                }
                return _
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(t, e, i) {
            e.exports = r;
            var h = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB");

            function r(t) {
                t = t || {}, this.from = t.from ? h.fromValues(t.from[0], t.from[1]) : h.create(), this.to = t.to ? h.fromValues(t.to[0], t.to[1]) : h.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : r.ANY, this.callback = t.callback || function(t) {}, this.direction = h.create(), this.length = 1, this.update()
            }(r.prototype.constructor = r).CLOSEST = 1, r.ANY = 2, r.ALL = 4, r.prototype.update = function() {
                var t = this.direction;
                h.sub(t, this.to, this.from), this.length = h.length(t), h.normalize(t, t)
            }, r.prototype.intersectBodies = function(t, e) {
                for (var i = 0, o = e.length; !t.shouldStop(this) && i < o; i++) {
                    var s = e[i],
                        n = s.getAABB();
                    (0 <= n.overlapsRay(this) || n.containsPoint(this.from)) && this.intersectBody(t, s)
                }
            };
            var l = h.create();
            r.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var o = l, s = 0, n = e.shapes.length; s < n; s++) {
                        var r = e.shapes[s];
                        if ((!i || r.collisionResponse) && (0 != (this.collisionGroup & r.collisionMask) && 0 != (r.collisionGroup & this.collisionMask))) {
                            h.rotate(o, r.position, e.angle), h.add(o, o, e.position);
                            var a = r.angle + e.angle;
                            if (this.intersectShape(t, r, a, o, e), t.shouldStop(this)) break
                        }
                    }
            }, r.prototype.intersectShape = function(t, e, i, o, s) {
                (function(t, e, i) {
                    h.sub(n, i, t);
                    var o = h.dot(n, e);
                    return h.scale(a, e, o), h.add(a, a, t), h.squaredDistance(i, a)
                })(this.from, this.direction, o) > e.boundingRadius * e.boundingRadius || (this._currentBody = s, (this._currentShape = e).raycast(t, this, o, i), this._currentBody = this._currentShape = null)
            }, r.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                h.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), h.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            };
            h.create();
            r.prototype.reportIntersection = function(t, e, i, o) {
                this.from, this.to;
                var s = this._currentShape,
                    n = this._currentBody;
                if (!(this.skipBackfaces && 0 < h.dot(i, this.direction))) switch (this.mode) {
                    case r.ALL:
                        t.set(i, s, n, e, o), this.callback(t);
                        break;
                    case r.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, s, n, e, o);
                        break;
                    case r.ANY:
                        t.set(i, s, n, e, o)
                }
            };
            var n = h.create(),
                a = h.create()
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(t, e, i) {
            var n = t("../math/vec2"),
                o = t("../collision/Ray");

            function s() {
                this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }(e.exports = s).prototype.reset = function() {
                n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }, s.prototype.getHitDistance = function(t) {
                return n.distance(t.from, t.to) * this.fraction
            }, s.prototype.hasHit = function() {
                return -1 !== this.fraction
            }, s.prototype.getHitPoint = function(t, e) {
                n.lerp(t, e.from, e.to, this.fraction)
            }, s.prototype.stop = function() {
                this.isStopped = !0
            }, s.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === o.ANY
            }, s.prototype.set = function(t, e, i, o, s) {
                n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = o, this.faceIndex = s
            }
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(t, e, i) {
            var o = t("../utils/Utils"),
                c = t("../collision/Broadphase");

            function s() {
                c.call(this, c.SAP), this.axisList = [], this.axisIndex = 0;
                var i = this;
                this._addBodyHandler = function(t) {
                    i.axisList.push(t.body)
                }, this._removeBodyHandler = function(t) {
                    var e = i.axisList.indexOf(t.body); - 1 !== e && i.axisList.splice(e, 1)
                }
            }(((e.exports = s).prototype = new c).constructor = s).prototype.setWorld = function(t) {
                this.axisList.length = 0, o.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
            }, s.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, o = t.length; i < o; i++) {
                    for (var s = t[i], n = i - 1; 0 <= n && !(t[n].aabb.lowerBound[e] <= s.aabb.lowerBound[e]); n--) t[n + 1] = t[n];
                    t[n + 1] = s
                }
                return t
            }, s.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                s.sortAxisList(t, e)
            }, s.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    o = this.axisIndex;
                i.length = 0;
                for (var s = e.length; s--;) {
                    var n = e[s];
                    n.aabbNeedsUpdate && n.updateAABB()
                }
                this.sortList();
                for (var r = 0, a = 0 | e.length; r !== a; r++)
                    for (var h = e[r], l = r + 1; l < a; l++) {
                        var d = e[l];
                        if (!(d.aabb.lowerBound[o] <= h.aabb.upperBound[o])) break;
                        c.canCollide(h, d) && this.boundingVolumeCheck(h, d) && i.push(h, d)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                var o = this.axisIndex,
                    s = "x";
                1 === o && (s = "y"), 2 === o && (s = "z");
                for (var n = this.axisList, r = (e.lowerBound[s], e.upperBound[s], 0); r < n.length; r++) {
                    var a = n[r];
                    a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(t, e, i) {
            e.exports = o;
            var s = t("../utils/Utils");

            function o(t, e, i, o) {
                this.type = i, o = s.defaults(o, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = o.collideConnected, o.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            o.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }, o.DISTANCE = 1, o.GEAR = 2, o.LOCK = 3, o.PRISMATIC = 4, o.REVOLUTE = 5, o.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var o = e[i];
                    o.stiffness = t, o.needsUpdate = !0
                }
            }, o.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var o = e[i];
                    o.relaxation = t, o.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 57
        }],
        15: [function(t, e, i) {
            var p = t("./Constraint"),
                b = t("../equations/Equation"),
                m = t("../math/vec2"),
                y = t("../utils/Utils");

            function o(t, e, i) {
                i = y.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }), p.call(this, t, e, p.DISTANCE, i), this.localAnchorA = m.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = m.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var o, s = this.localAnchorA,
                    n = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var r = m.create(),
                        a = m.create(),
                        h = m.create();
                    m.rotate(r, s, t.angle), m.rotate(a, n, e.angle), m.add(h, e.position, a), m.sub(h, h, r), m.sub(h, h, t.position), this.distance = m.length(h)
                }
                o = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                var l = new b(t, e, -o, o);
                this.equations = [l], this.maxForce = o;
                h = m.create();
                var d = m.create(),
                    c = m.create(),
                    u = this;
                l.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        o = e.position;
                    return m.rotate(d, s, t.angle), m.rotate(c, n, e.angle), m.add(h, o, c), m.sub(h, h, d), m.sub(h, h, i), m.length(h) - u.distance
                }, this.setMaxForce(o), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }((e.exports = o).prototype = new p).constructor = o;
            var d = m.create(),
                c = m.create(),
                u = m.create();
            o.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    o = (this.distance, e.position),
                    s = i.position,
                    n = this.equations[0],
                    r = t.G;
                m.rotate(c, this.localAnchorA, e.angle), m.rotate(u, this.localAnchorB, i.angle), m.add(d, s, u), m.sub(d, d, c), m.sub(d, d, o), this.position = m.length(d);
                var a = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (n.maxForce = 0, n.minForce = -this.maxForce, this.distance = this.upperLimit, a = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (n.maxForce = this.maxForce, n.minForce = 0, this.distance = this.lowerLimit, a = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || a) {
                    n.enabled = !0, m.normalize(d, d);
                    var h = m.crossLength(c, d),
                        l = m.crossLength(u, d);
                    r[0] = -d[0], r[1] = -d[1], r[2] = -h, r[3] = d[0], r[4] = d[1], r[5] = l
                } else n.enabled = !1
            }, o.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, o.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(t, e, i) {
            var o = t("./Constraint"),
                s = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2");

            function n(t, e, i) {
                i = i || {}, o.call(this, t, e, o.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new s(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }(((e.exports = n).prototype = new o).constructor = n).prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, n.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            }, n.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(t, e, i) {
            var u = t("./Constraint"),
                p = t("../math/vec2"),
                b = t("../equations/Equation");

            function o(t, e, i) {
                i = i || {}, u.call(this, t, e, u.LOCK, i);
                var o = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    s = (i.localAngleB, new b(t, e, -o, o)),
                    n = new b(t, e, -o, o),
                    r = new b(t, e, -o, o),
                    a = p.create(),
                    h = p.create(),
                    l = this;
                s.computeGq = function() {
                    return p.rotate(a, l.localOffsetB, t.angle), p.sub(h, e.position, t.position), p.sub(h, h, a), h[0]
                }, n.computeGq = function() {
                    return p.rotate(a, l.localOffsetB, t.angle), p.sub(h, e.position, t.position), p.sub(h, h, a), h[1]
                };
                var d = p.create(),
                    c = p.create();
                r.computeGq = function() {
                    return p.rotate(d, l.localOffsetB, e.angle - l.localAngleB), p.scale(d, d, -1), p.sub(h, t.position, e.position), p.add(h, h, d), p.rotate(c, d, -Math.PI / 2), p.normalize(c, c), p.dot(h, c)
                }, this.localOffsetB = p.create(), i.localOffsetB ? p.copy(this.localOffsetB, i.localOffsetB) : (p.sub(this.localOffsetB, e.position, t.position), p.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(s, n, r), this.setMaxForce(o)
            }(((e.exports = o).prototype = new u).constructor = o).prototype.setMaxForce = function(t) {
                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
            }, o.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var n = p.create(),
                r = p.create(),
                a = p.create(),
                h = p.fromValues(1, 0),
                l = p.fromValues(0, 1);
            o.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    o = this.bodyA,
                    s = this.bodyB;
                p.rotate(n, this.localOffsetB, o.angle), p.rotate(r, this.localOffsetB, s.angle - this.localAngleB), p.scale(r, r, -1), p.rotate(a, r, Math.PI / 2), p.normalize(a, a), t.G[0] = -1, t.G[1] = 0, t.G[2] = -p.crossLength(n, h), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -p.crossLength(n, l), e.G[4] = 1, i.G[0] = -a[0], i.G[1] = -a[1], i.G[3] = a[0], i.G[4] = a[1], i.G[5] = p.crossLength(r, a)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(t, e, i) {
            var m = t("./Constraint"),
                y = t("../equations/ContactEquation"),
                f = t("../equations/Equation"),
                x = t("../math/vec2"),
                g = t("../equations/RotationalLockEquation");

            function o(o, s, t) {
                t = t || {}, m.call(this, o, s, m.PRISMATIC, t);
                var n = x.fromValues(0, 0),
                    r = x.fromValues(1, 0),
                    a = x.fromValues(0, 0);
                t.localAnchorA && x.copy(n, t.localAnchorA), t.localAxisA && x.copy(r, t.localAxisA), t.localAnchorB && x.copy(a, t.localAnchorB), this.localAnchorA = n, this.localAnchorB = a, this.localAxisA = r;
                var e = this.maxForce = void 0 !== t.maxForce ? t.maxForce : Number.MAX_VALUE,
                    i = new f(o, s, -e, e),
                    h = new x.create,
                    l = new x.create,
                    d = new x.create,
                    c = new x.create;
                if (i.computeGq = function() {
                        return x.dot(d, c)
                    }, i.updateJacobian = function() {
                        var t = this.G,
                            e = o.position,
                            i = s.position;
                        x.rotate(h, n, o.angle), x.rotate(l, a, s.angle), x.add(d, i, l), x.sub(d, d, e), x.sub(d, d, h), x.rotate(c, r, o.angle + Math.PI / 2), t[0] = -c[0], t[1] = -c[1], t[2] = -x.crossLength(h, c) + x.crossLength(c, d), t[3] = c[0], t[4] = c[1], t[5] = x.crossLength(l, c)
                    }, this.equations.push(i), !t.disableRotationalLock) {
                    var u = new g(o, s, -e, e);
                    this.equations.push(u)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== t.lowerLimit, this.upperLimitEnabled = void 0 !== t.upperLimit, this.lowerLimit = void 0 !== t.lowerLimit ? t.lowerLimit : 0, this.upperLimit = void 0 !== t.upperLimit ? t.upperLimit : 1, this.upperLimitEquation = new y(o, s), this.lowerLimitEquation = new y(o, s), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = e, this.motorEquation = new f(o, s), this.motorEnabled = !1, this.motorSpeed = 0;
                var p = this,
                    b = this.motorEquation;
                b.computeGW;
                b.computeGq = function() {
                    return 0
                }, b.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        o = e.velocity,
                        s = i.velocity,
                        n = e.angularVelocity,
                        r = i.angularVelocity;
                    return this.gmult(t, o, n, s, r) + p.motorSpeed
                }
            }((e.exports = o).prototype = new m).constructor = o;
            var b = x.create(),
                _ = x.create(),
                v = x.create(),
                S = x.create(),
                C = x.create(),
                w = x.create();
            o.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    o = this.lowerLimit,
                    s = this.upperLimitEquation,
                    n = this.lowerLimitEquation,
                    r = this.bodyA,
                    a = this.bodyB,
                    h = this.localAxisA,
                    l = this.localAnchorA,
                    d = this.localAnchorB;
                e.updateJacobian(), x.rotate(b, h, r.angle), x.rotate(S, l, r.angle), x.add(_, S, r.position), x.rotate(C, d, a.angle), x.add(v, C, a.position);
                var c, u = this.position = x.dot(v, b) - x.dot(_, b);
                if (this.motorEnabled) {
                    var p = this.motorEquation.G;
                    p[0] = b[0], p[1] = b[1], p[2] = x.crossLength(b, C), p[3] = -b[0], p[4] = -b[1], p[5] = -x.crossLength(b, S)
                }
                this.upperLimitEnabled && i < u ? (x.scale(s.normalA, b, -1), x.sub(s.contactPointA, _, r.position), x.sub(s.contactPointB, v, a.position), x.scale(w, b, i), x.add(s.contactPointA, s.contactPointA, w), -1 === t.indexOf(s) && t.push(s)) : -1 !== (c = t.indexOf(s)) && t.splice(c, 1);
                this.lowerLimitEnabled && u < o ? (x.scale(n.normalA, b, 1), x.sub(n.contactPointA, _, r.position), x.sub(n.contactPointB, v, a.position), x.scale(w, b, o), x.sub(n.contactPointB, n.contactPointB, w), -1 === t.indexOf(n) && t.push(n)) : -1 !== (c = t.indexOf(n)) && t.splice(c, 1)
            }, o.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, o.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, o.prototype.setLimits = function(t, e) {
                this.lowerLimitEnabled = "number" == typeof t ? (this.lowerLimit = t, !0) : (this.lowerLimit = t, !1), this.upperLimitEnabled = "number" == typeof e ? (this.upperLimit = e, !0) : (this.upperLimit = e, !1)
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(t, e, i) {
            var h = t("./Constraint"),
                l = t("../equations/Equation"),
                d = t("../equations/RotationalVelocityEquation"),
                c = t("../equations/RotationalLockEquation"),
                p = t("../math/vec2");
            e.exports = o;
            var b = p.create(),
                m = p.create(),
                y = p.fromValues(1, 0),
                f = p.fromValues(0, 1),
                u = p.create();

            function o(t, e, i) {
                i = i || {}, h.call(this, t, e, h.REVOLUTE, i);
                var o = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = p.create(), this.pivotB = p.create(), i.worldPivot ? (p.sub(this.pivotA, i.worldPivot, t.position), p.sub(this.pivotB, i.worldPivot, e.position), p.rotate(this.pivotA, this.pivotA, -t.angle), p.rotate(this.pivotB, this.pivotB, -e.angle)) : (p.copy(this.pivotA, i.localPivotA), p.copy(this.pivotB, i.localPivotB));
                var s = this.equations = [new l(t, e, -o, o), new l(t, e, -o, o)],
                    n = s[0],
                    r = s[1],
                    a = this;
                n.computeGq = function() {
                    return p.rotate(b, a.pivotA, t.angle), p.rotate(m, a.pivotB, e.angle), p.add(u, e.position, m), p.sub(u, u, t.position), p.sub(u, u, b), p.dot(u, y)
                }, r.computeGq = function() {
                    return p.rotate(b, a.pivotA, t.angle), p.rotate(m, a.pivotB, e.angle), p.add(u, e.position, m), p.sub(u, u, t.position), p.sub(u, u, b), p.dot(u, f)
                }, r.minForce = n.minForce = -o, r.maxForce = n.maxForce = o, this.motorEquation = new d(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new c(t, e), this.lowerLimitEquation = new c(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }((o.prototype = new h).constructor = o).prototype.setLimits = function(t, e) {
                this.lowerLimitEnabled = "number" == typeof t ? (this.lowerLimit = t, !0) : (this.lowerLimit = t, !1), this.upperLimitEnabled = "number" == typeof e ? (this.upperLimit = e, !0) : (this.upperLimit = e, !1)
            }, o.prototype.update = function() {
                var t, e = this.bodyA,
                    i = this.bodyB,
                    o = this.pivotA,
                    s = this.pivotB,
                    n = this.equations,
                    r = (n[0], n[1], n[0]),
                    a = n[1],
                    h = this.upperLimit,
                    l = this.lowerLimit,
                    d = this.upperLimitEquation,
                    c = this.lowerLimitEquation,
                    u = this.angle = i.angle - e.angle;
                this.upperLimitEnabled && h < u ? (d.angle = h, -1 === n.indexOf(d) && n.push(d)) : -1 !== (t = n.indexOf(d)) && n.splice(t, 1);
                this.lowerLimitEnabled && u < l ? (c.angle = l, -1 === n.indexOf(c) && n.push(c)) : -1 !== (t = n.indexOf(c)) && n.splice(t, 1);
                p.rotate(b, o, e.angle), p.rotate(m, s, i.angle), r.G[0] = -1, r.G[1] = 0, r.G[2] = -p.crossLength(b, y), r.G[3] = 1, r.G[4] = 0, r.G[5] = p.crossLength(m, y), a.G[0] = 0, a.G[1] = -1, a.G[2] = -p.crossLength(b, f), a.G[3] = 0, a.G[4] = 1, a.G[5] = p.crossLength(m, f)
            }, o.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, o.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, o.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            }, o.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            }, o.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(t, e, i) {
            var o = t("./Equation");
            t("../math/vec2");

            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }, s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, s.prototype.setMaxTorque = function(t) {
                this.maxForce = t, this.minForce = -t
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(t, e, i) {
            var o = t("./Equation"),
                y = t("../math/vec2");

            function s(t, e) {
                o.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = y.create(), this.penetrationVec = y.create(), this.contactPointB = y.create(), this.normalA = y.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeB = function(t, e, i) {
                var o, s, n = this.bodyA,
                    r = this.bodyB,
                    a = this.contactPointA,
                    h = this.contactPointB,
                    l = n.position,
                    d = r.position,
                    c = this.penetrationVec,
                    u = this.normalA,
                    p = this.G,
                    b = y.crossLength(a, u),
                    m = y.crossLength(h, u);
                return p[0] = -u[0], p[1] = -u[1], p[2] = -b, p[3] = u[0], p[4] = u[1], p[5] = m, y.add(c, d, h), y.sub(c, c, l), y.sub(c, c, a), o = this.firstImpact && 0 !== this.restitution ? (s = 0, 1 / e * (1 + this.restitution) * this.computeGW()) : (s = y.dot(u, c) + this.offset, this.computeGW()), -s * t - o * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(t, e, i) {
            e.exports = r;
            var c = t("../math/vec2"),
                n = t("../utils/Utils");
            t("../objects/Body");

            function r(t, e, i, o) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === o ? Number.MAX_VALUE : o, this.bodyA = t, this.bodyB = e, this.stiffness = r.DEFAULT_STIFFNESS, this.relaxation = r.DEFAULT_RELAXATION, this.G = new n.ARRAY_TYPE(6);
                for (var s = 0; s < 6; s++) this.G[s] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }(r.prototype.constructor = r).DEFAULT_STIFFNESS = 1e6, r.DEFAULT_RELAXATION = 4, r.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, r.prototype.gmult = function(t, e, i, o, s) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * o[0] + t[4] * o[1] + t[5] * s
            }, r.prototype.computeB = function(t, e, i) {
                var o = this.computeGW();
                return -this.computeGq() * t - o * e - this.computeGiMf() * i
            };
            var a = c.create(),
                h = c.create();
            r.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = (e.position, i.position, e.angle),
                    s = i.angle;
                return this.gmult(t, a, o, h, s) + this.offset
            }, r.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = e.velocity,
                    s = i.velocity,
                    n = e.angularVelocity,
                    r = i.angularVelocity;
                return this.gmult(t, o, n, s, r) + this.relativeVelocity
            }, r.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = e.vlambda,
                    s = i.vlambda,
                    n = e.wlambda,
                    r = i.wlambda;
                return this.gmult(t, o, n, s, r)
            };
            var u = c.create(),
                p = c.create();
            r.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    o = t.angularForce,
                    s = e.force,
                    n = e.angularForce,
                    r = t.invMassSolve,
                    a = e.invMassSolve,
                    h = t.invInertiaSolve,
                    l = e.invInertiaSolve,
                    d = this.G;
                return c.scale(u, i, r), c.multiply(u, t.massMultiplier, u), c.scale(p, s, a), c.multiply(p, e.massMultiplier, p), this.gmult(d, u, o * h, p, n * l)
            }, r.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    o = e.invMassSolve,
                    s = t.invInertiaSolve,
                    n = e.invInertiaSolve,
                    r = this.G;
                return r[0] * r[0] * i * t.massMultiplier[0] + r[1] * r[1] * i * t.massMultiplier[1] + r[2] * r[2] * s + r[3] * r[3] * o * e.massMultiplier[0] + r[4] * r[4] * o * e.massMultiplier[1] + r[5] * r[5] * n
            };
            var b = c.create(),
                m = c.create(),
                y = c.create();
            c.create(), c.create(), c.create();
            r.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    o = b,
                    s = m,
                    n = y,
                    r = e.invMassSolve,
                    a = i.invMassSolve,
                    h = e.invInertiaSolve,
                    l = i.invInertiaSolve,
                    d = this.G;
                s[0] = d[0], s[1] = d[1], n[0] = d[3], n[1] = d[4], c.scale(o, s, r * t), c.multiply(o, o, e.massMultiplier), c.add(e.vlambda, e.vlambda, o), e.wlambda += h * d[2] * t, c.scale(o, n, a * t), c.multiply(o, o, i.massMultiplier), c.add(i.vlambda, i.vlambda, o), i.wlambda += l * d[5] * t
            }, r.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(t, e, i) {
            var a = t("../math/vec2"),
                o = t("./Equation");
            t("../utils/Utils");

            function s(t, e, i) {
                o.call(this, t, e, -i, i), this.contactPointA = a.create(), this.contactPointB = a.create(), this.t = a.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
            }(((e.exports = s).prototype = new o).constructor = s).prototype.setSlipForce = function(t) {
                this.maxForce = t, this.minForce = -t
            }, s.prototype.getSlipForce = function() {
                return this.maxForce
            }, s.prototype.computeB = function(t, e, i) {
                this.bodyA, this.bodyB;
                var o = this.contactPointA,
                    s = this.contactPointB,
                    n = this.t,
                    r = this.G;
                return r[0] = -n[0], r[1] = -n[1], r[2] = -a.crossLength(o, n), r[3] = n[0], r[4] = n[1], r[5] = a.crossLength(s, n), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(t, e, i) {
            var s = t("./Equation"),
                o = t("../math/vec2");

            function n(t, e, i) {
                i = i || {}, s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                var o = this.G;
                o[2] = 1, o[5] = -1
            }((e.exports = n).prototype = new s).constructor = n;
            var r = o.create(),
                a = o.create(),
                h = o.fromValues(1, 0),
                l = o.fromValues(0, 1);
            n.prototype.computeGq = function() {
                return o.rotate(r, h, this.bodyA.angle + this.angle), o.rotate(a, l, this.bodyB.angle), o.dot(r, a)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(t, e, i) {
            var o = t("./Equation");
            t("../math/vec2");

            function s(t, e) {
                o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeB = function(t, e, i) {
                var o = this.G;
                o[2] = -1, o[5] = this.ratio;
                var s = this.computeGiMf();
                return -this.computeGW() * e - i * s
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(t, e, i) {
            var o = function() {};
            (e.exports = o).prototype = {
                constructor: o,
                on: function(t, e, i) {
                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                    var o = this._listeners;
                    return void 0 === o[t] && (o[t] = []), -1 === o[t].indexOf(e) && o[t].push(e), this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                    } else if (void 0 !== i[t]) return !0;
                    return !1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        o = i[t].indexOf(e);
                    return -1 !== o && i[t].splice(o, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, o = e.length; i < o; i++) {
                            var s = e[i];
                            s.call(s.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            var o = t("./Material"),
                s = t("../equations/Equation");

            function n(t, e, i) {
                if (i = i || {}, !(t instanceof o && e instanceof o)) throw new Error("First two arguments must be Material instances.");
                this.id = n.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : s.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : s.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : s.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : s.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }(e.exports = n).idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(t, e, i) {
            function o(t) {
                this.id = t || o.idCounter++
            }(e.exports = o).idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var x = {
                GetArea: function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2, i = 0, o = 0; o < e; o += 2) i += (t[o + 2] - t[o]) * (t[o + 1] + t[o + 3]);
                    return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
                },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], o = [], s = 0; s < e; s++) o.push(s);
                    s = 0;
                    for (var n = e; 3 < n;) {
                        var r = o[(s + 0) % n],
                            a = o[(s + 1) % n],
                            h = o[(s + 2) % n],
                            l = t[2 * r],
                            d = t[2 * r + 1],
                            c = t[2 * a],
                            u = t[2 * a + 1],
                            p = t[2 * h],
                            b = t[2 * h + 1],
                            m = !1;
                        if (x._convex(l, d, c, u, p, b)) {
                            m = !0;
                            for (var y = 0; y < n; y++) {
                                var f = o[y];
                                if (f != r && f != a && f != h && x._PointInTriangle(t[2 * f], t[2 * f + 1], l, d, c, u, p, b)) {
                                    m = !1;
                                    break
                                }
                            }
                        }
                        if (m) i.push(r, a, h), o.splice((s + 1) % n, 1), n--, s = 0;
                        else if (s++ > 3 * n) break
                    }
                    return i.push(o[0], o[1], o[2]), i
                },
                _PointInTriangle: function(t, e, i, o, s, n, r, a) {
                    var h = r - i,
                        l = a - o,
                        d = s - i,
                        c = n - o,
                        u = t - i,
                        p = e - o,
                        b = h * h + l * l,
                        m = h * d + l * c,
                        y = h * u + l * p,
                        f = d * d + c * c,
                        x = d * u + c * p,
                        g = 1 / (b * f - m * m),
                        _ = (f * y - m * x) * g,
                        v = (b * x - m * y) * g;
                    return 0 <= _ && 0 <= v && _ + v < 1
                },
                _convex: function(t, e, i, o, s, n) {
                    return 0 <= (e - o) * (s - i) + (i - t) * (n - o)
                }
            };
            e.exports = x
        }, {}],
        30: [function(t, e, i) {
            var r = e.exports = {},
                o = t("../utils/Utils");
            r.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            }, r.crossVZ = function(t, e, i) {
                return r.rotate(t, e, -Math.PI / 2), r.scale(t, t, i), t
            }, r.crossZV = function(t, e, i) {
                return r.rotate(t, i, Math.PI / 2), r.scale(t, t, e), t
            }, r.rotate = function(t, e, i) {
                if (0 !== i) {
                    var o = Math.cos(i),
                        s = Math.sin(i),
                        n = e[0],
                        r = e[1];
                    t[0] = o * n - s * r, t[1] = s * n + o * r
                } else t[0] = e[0], t[1] = e[1]
            }, r.rotate90cw = function(t, e) {
                var i = e[0],
                    o = e[1];
                t[0] = o, t[1] = -i
            }, r.toLocalFrame = function(t, e, i, o) {
                r.copy(t, e), r.sub(t, t, i), r.rotate(t, t, -o)
            }, r.toGlobalFrame = function(t, e, i, o) {
                r.copy(t, e), r.rotate(t, t, o), r.add(t, t, i)
            }, r.vectorToLocalFrame = function(t, e, i) {
                r.rotate(t, e, -i)
            }, r.vectorToGlobalFrame = function(t, e, i) {
                r.rotate(t, e, i)
            }, r.centroid = function(t, e, i, o) {
                return r.add(t, e, i), r.add(t, t, o), r.scale(t, t, 1 / 3), t
            }, r.create = function() {
                var t = new o.ARRAY_TYPE(2);
                return t[0] = 0, t[1] = 0, t
            }, r.clone = function(t) {
                var e = new o.ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e
            }, r.fromValues = function(t, e) {
                var i = new o.ARRAY_TYPE(2);
                return i[0] = t, i[1] = e, i
            }, r.copy = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, r.set = function(t, e, i) {
                return t[0] = e, t[1] = i, t
            }, r.add = function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, r.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, r.sub = r.subtract, r.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, r.mul = r.multiply, r.divide = function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, r.div = r.divide, r.scale = function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, r.distance = function(t, e) {
                var i = e[0] - t[0],
                    o = e[1] - t[1];
                return Math.sqrt(i * i + o * o)
            }, r.dist = r.distance, r.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    o = e[1] - t[1];
                return i * i + o * o
            }, r.sqrDist = r.squaredDistance, r.length = function(t) {
                var e = t[0],
                    i = t[1];
                return Math.sqrt(e * e + i * i)
            }, r.len = r.length, r.squaredLength = function(t) {
                var e = t[0],
                    i = t[1];
                return e * e + i * i
            }, r.sqrLen = r.squaredLength, r.negate = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, r.normalize = function(t, e) {
                var i = e[0],
                    o = e[1],
                    s = i * i + o * o;
                return 0 < s && (s = 1 / Math.sqrt(s), t[0] = e[0] * s, t[1] = e[1] * s), t
            }, r.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, r.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }, r.lerp = function(t, e, i, o) {
                var s = e[0],
                    n = e[1];
                return t[0] = s + o * (i[0] - s), t[1] = n + o * (i[1] - n), t
            }, r.reflect = function(t, e, i) {
                var o = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * o, t[1] = e[1] - 2 * i[1] * o
            }, r.getLineSegmentsIntersection = function(t, e, i, o, s) {
                var n = r.getLineSegmentsIntersectionFraction(e, i, o, s);
                return !(n < 0) && (t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), !0)
            }, r.getLineSegmentsIntersectionFraction = function(t, e, i, o) {
                var s, n, r = e[0] - t[0],
                    a = e[1] - t[1],
                    h = o[0] - i[0],
                    l = o[1] - i[1];
                return s = (-a * (t[0] - i[0]) + r * (t[1] - i[1])) / (-h * a + r * l), n = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * a + r * l), 0 <= s && s <= 1 && 0 <= n && n <= 1 ? n : -1
            }
        }, {
            "../utils/Utils": 57
        }],
        31: [function(t, e, i) {
            var c = t("../math/vec2"),
                l = t("poly-decomp"),
                d = t("../shapes/Convex"),
                o = t("../collision/RaycastResult"),
                s = t("../collision/Ray"),
                n = t("../collision/AABB"),
                r = t("../events/EventEmitter");

            function a(t) {
                t = t || {}, r.call(this), this.id = t.id || ++a._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = c.create(), this.position = c.fromValues(0, 0), t.position && c.copy(this.position, t.position), this.interpolatedPosition = c.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = c.fromValues(0, 0), this.previousAngle = 0, this.velocity = c.fromValues(0, 0), t.velocity && c.copy(this.velocity, t.velocity), this.vlambda = c.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = c.create(), t.force && c.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = a.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = a.DYNAMIC : this.type = a.STATIC, this.boundingRadius = 0, this.aabb = new n, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = a.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
            }(((e.exports = a).prototype = new r).constructor = a)._idCounter = 0, a.prototype.updateSolveMassProperties = function() {
                this.sleepState === a.SLEEPING || this.type === a.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            }, a.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, a.prototype.getArea = function() {
                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            }, a.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
            };
            var h = new n,
                u = c.create();
            a.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = u, o = this.angle, s = 0; s !== e; s++) {
                    var n = t[s],
                        r = n.angle + o;
                    c.rotate(i, n.position, o), c.add(i, i, this.position), n.computeAABB(h, i, r), 0 === s ? this.aabb.copy(h) : this.aabb.extend(h)
                }
                this.aabbNeedsUpdate = !1
            }, a.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, o = 0; o !== e; o++) {
                    var s = t[o],
                        n = c.length(s.position),
                        r = s.boundingRadius;
                    i < n + r && (i = n + r)
                }
                this.boundingRadius = i
            }, a.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? c.copy(t.position, e) : c.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, a.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, !(t.body = null))
            }, a.prototype.updateMassProperties = function() {
                if (this.type === a.STATIC || this.type === a.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        o = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var s = 0; s < e; s++) {
                            var n = t[s],
                                r = c.squaredLength(n.position);
                            o += n.computeMomentOfInertia(i) + i * r
                        }
                        this.inertia = o, this.invInertia = 0 < o ? 1 / o : 0
                    }
                    this.invMass = 1 / this.mass, c.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            };
            c.create();
            a.prototype.applyForce = function(t, e) {
                if (c.add(this.force, this.force, t), e) {
                    var i = c.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var p = c.create(),
                b = c.create(),
                m = c.create();
            a.prototype.applyForceLocal = function(t, e) {
                e = e || m;
                var i = p,
                    o = b;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(o, e), this.applyForce(i, o)
            };
            var y = c.create();
            a.prototype.applyImpulse = function(t, e) {
                if (this.type === a.DYNAMIC) {
                    var i = y;
                    if (c.scale(i, t, this.invMass), c.multiply(i, this.massMultiplier, i), c.add(this.velocity, i, this.velocity), e) {
                        var o = c.crossLength(e, t);
                        o *= this.invInertia, this.angularVelocity += o
                    }
                }
            };
            var f = c.create(),
                x = c.create(),
                g = c.create();
            a.prototype.applyImpulseLocal = function(t, e) {
                e = e || g;
                var i = f,
                    o = x;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(o, e), this.applyImpulse(i, o)
            }, a.prototype.toLocalFrame = function(t, e) {
                c.toLocalFrame(t, e, this.position, this.angle)
            }, a.prototype.toWorldFrame = function(t, e) {
                c.toGlobalFrame(t, e, this.position, this.angle)
            }, a.prototype.vectorToLocalFrame = function(t, e) {
                c.vectorToLocalFrame(t, e, this.angle)
            }, a.prototype.vectorToWorldFrame = function(t, e) {
                c.vectorToGlobalFrame(t, e, this.angle)
            }, a.prototype.fromPolygon = function(t, e) {
                e = e || {};
                for (var i = this.shapes.length; 0 <= i; --i) this.removeShape(this.shapes[i]);
                var o, s = new l.Polygon;
                if (s.vertices = t, s.makeCCW(), "number" == typeof e.removeCollinearPoints && s.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !s.isSimple()) return !1;
                this.concavePath = s.vertices.slice(0);
                for (i = 0; i < this.concavePath.length; i++) {
                    var n = [0, 0];
                    c.copy(n, this.concavePath[i]), this.concavePath[i] = n
                }
                o = e.optimalDecomp ? s.decomp() : s.quickDecomp();
                var r = c.create();
                for (i = 0; i !== o.length; i++) {
                    for (var a = new d({
                            vertices: o[i].vertices
                        }), h = 0; h !== a.vertices.length; h++) {
                        n = a.vertices[h];
                        c.sub(n, n, a.centerOfMass)
                    }
                    c.scale(r, a.centerOfMass, 1), a.updateTriangles(), a.updateCenterOfMass(), a.updateBoundingRadius(), this.addShape(a, r)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0
            };
            c.fromValues(0, 0);
            var _ = c.fromValues(0, 0),
                v = c.fromValues(0, 0),
                S = c.fromValues(0, 0);
            a.prototype.adjustCenterOfMass = function() {
                var t = _,
                    e = v,
                    i = S,
                    o = 0;
                c.set(e, 0, 0);
                for (var s = 0; s !== this.shapes.length; s++) {
                    var n = this.shapes[s];
                    c.scale(t, n.position, n.area), c.add(e, e, t), o += n.area
                }
                c.scale(i, e, 1 / o);
                for (s = 0; s !== this.shapes.length; s++) {
                    n = this.shapes[s];
                    c.sub(n.position, n.position, i)
                }
                c.add(this.position, this.position, i);
                for (s = 0; this.concavePath && s < this.concavePath.length; s++) c.sub(this.concavePath[s], this.concavePath[s], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, a.prototype.setZeroForce = function() {
                c.set(this.force, 0, 0), this.angularForce = 0
            }, a.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                c.set(t, 0, 0), this.wlambda = 0
            }, a.prototype.addConstraintVelocity = function() {
                var t = this.velocity;
                c.add(t, t, this.vlambda), this.angularVelocity += this.wlambda
            }, a.prototype.applyDamping = function(t) {
                if (this.type === a.DYNAMIC) {
                    var e = this.velocity;
                    c.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            }, a.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = a.AWAKE, this.idleTime = 0, t !== a.AWAKE && this.emit(a.wakeUpEvent)
            }, a.prototype.sleep = function() {
                this.sleepState = a.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, c.set(this.velocity, 0, 0), c.set(this.force, 0, 0), this.emit(a.sleepEvent)
            }, a.prototype.sleepTick = function(t, e, i) {
                if (this.allowSleep && this.type !== a.SLEEPING) {
                    this.wantsToSleep = !1;
                    this.sleepState;
                    var o = c.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2),
                        s = Math.pow(this.sleepSpeedLimit, 2);
                    this.sleepState = s <= o ? (this.idleTime = 0, a.AWAKE) : (this.idleTime += i, a.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                }
            }, a.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var C = c.create(),
                w = c.create();
            a.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    o = this.position,
                    s = this.velocity;
                c.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), c.scale(C, i, t * e), c.multiply(C, this.massMultiplier, C), c.add(s, C, s), this.integrateToTimeOfImpact(t) || (c.scale(w, s, t), c.add(o, o, w), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var A = new o,
                P = new s({
                    mode: s.ALL
                }),
                T = c.create(),
                B = c.create(),
                M = c.create(),
                E = c.create();
            a.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || c.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                c.normalize(T, this.velocity), c.scale(B, this.velocity, t), c.add(B, B, this.position), c.sub(M, B, this.position);
                var e, i = this.angularVelocity * t,
                    o = c.length(M),
                    s = 1,
                    n = this;
                if (A.reset(), P.callback = function(t) {
                        t.body !== n && (e = t.body, t.getHitPoint(B, P), c.sub(M, B, n.position), s = c.length(M) / o, t.stop())
                    }, c.copy(P.from, this.position), c.copy(P.to, B), P.update(), this.world.raycast(A, P), !e) return !1;
                var r = this.angle;
                c.copy(E, this.position);
                for (var a = 0, h = 0, l = 0, d = s; h <= d && a < this.ccdIterations;) {
                    a++, l = (d - h) / 2, c.scale(w, M, s), c.add(this.position, E, w), this.angle = r + i * s, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? h = l : d = l
                }
                return s = l, c.copy(this.position, E), this.angle = r, c.scale(w, M, s), c.add(this.position, this.position, w), this.fixedRotation || (this.angle += i * s), !0
            }, a.prototype.getVelocityAtPoint = function(t, e) {
                return c.crossVZ(t, e, this.angularVelocity), c.subtract(t, this.velocity, t), t
            }, a.sleepyEvent = {
                type: "sleepy"
            }, a.sleepEvent = {
                type: "sleep"
            }, a.wakeUpEvent = {
                type: "wakeup"
            }, a.DYNAMIC = 1, a.STATIC = 2, a.KINEMATIC = 4, a.AWAKE = 0, a.SLEEPY = 1, a.SLEEPING = 2
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(t, e, i) {
            var f = t("../math/vec2"),
                r = t("./Spring");
            t("../utils/Utils");

            function o(t, e, i) {
                i = i || {}, r.call(this, t, e, i), this.localAnchorA = f.fromValues(0, 0), this.localAnchorB = f.fromValues(0, 0), i.localAnchorA && f.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && f.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var o = f.create(),
                    s = f.create();
                this.getWorldAnchorA(o), this.getWorldAnchorB(s);
                var n = f.distance(o, s);
                this.restLength = "number" == typeof i.restLength ? i.restLength : n
            }(((e.exports = o).prototype = new r).constructor = o).prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            }, o.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            }, o.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            }, o.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var x = f.create(),
                g = f.create(),
                _ = f.create(),
                v = f.create(),
                S = f.create(),
                C = f.create(),
                w = f.create(),
                A = f.create(),
                P = f.create();
            o.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    o = this.bodyA,
                    s = this.bodyB,
                    n = x,
                    r = g,
                    a = _,
                    h = v,
                    l = P,
                    d = S,
                    c = C,
                    u = w,
                    p = A;
                this.getWorldAnchorA(d), this.getWorldAnchorB(c), f.sub(u, d, o.position), f.sub(p, c, s.position), f.sub(n, c, d);
                var b = f.len(n);
                f.normalize(r, n), f.sub(a, s.velocity, o.velocity), f.crossZV(l, s.angularVelocity, p), f.add(a, a, l), f.crossZV(l, o.angularVelocity, u), f.sub(a, a, l), f.scale(h, r, -t * (b - i) - e * f.dot(a, r)), f.sub(o.force, o.force, h), f.add(s.force, s.force, h);
                var m = f.crossLength(u, h),
                    y = f.crossLength(p, h);
                o.angularForce -= m, s.angularForce += y
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(t, e, i) {
            t("../math/vec2");
            var o = t("./Spring");

            function s(t, e, i) {
                i = i || {}, o.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
            }(((e.exports = s).prototype = new o).constructor = s).prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    o = this.bodyA,
                    s = this.bodyB,
                    n = -t * (s.angle - o.angle - i) - e * (s.angularVelocity - o.angularVelocity) * 0;
                o.angularForce -= n, s.angularForce += n
            }
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(t, e, i) {
            t("../math/vec2");
            var o = t("../utils/Utils");

            function s(t, e, i) {
                i = o.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
            }(e.exports = s).prototype.applyForce = function() {}
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(t, e, i) {
            var o = t("../math/vec2"),
                s = (t("../utils/Utils"), t("../constraints/Constraint")),
                n = t("../equations/FrictionEquation"),
                r = t("../objects/Body");

            function a(t, e) {
                e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new r({
                    mass: 0
                }), this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }

            function h(t, e) {
                e = e || {}, this.vehicle = t, this.forwardEquation = new n(t.chassisBody, t.groundBody), this.sideEquation = new n(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = o.fromValues(0, 1), e.localForwardVector && o.copy(this.localForwardVector, e.localForwardVector), this.localPosition = o.fromValues(0, 0), e.localPosition && o.copy(this.localPosition, e.localPosition), s.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
            }(e.exports = a).prototype.addToWorld = function(t) {
                (this.world = t).addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, a.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, a.prototype.addWheel = function(t) {
                var e = new h(this, t);
                return this.wheels.push(e), e
            }, a.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            }, (h.prototype = new s).setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            }, h.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = o.create(),
                d = o.create();
            h.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(d, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, d), o.dot(l, d)
            };
            var c = o.create();
            h.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), o.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), o.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), o.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), o.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), o.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), o.normalize(c, this.forwardEquation.t), o.scale(c, c, this.engineForce), this.vehicle.chassisBody.applyForce(c, this.forwardEquation.contactPointA)
            }
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(t, e, i) {
            var o = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(o, "Rectangle", {
                get: function() {
                    return this.Box
                }
            })
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(t, e, i) {
            var n = t("../math/vec2"),
                r = t("./Shape"),
                a = t("./Convex");

            function o(t) {
                "number" == typeof t && "number" == typeof arguments[1] && (t = {
                    width: t,
                    height: arguments[1]
                }), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    o = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    s = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = o, t.axes = s, t.type = r.BOX, a.call(this, t)
            }(((e.exports = o).prototype = new a).constructor = o).prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, o.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            };
            n.create(), n.create(), n.create(), n.create();
            o.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            }, o.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(t, e, i) {
            var o = t("./Shape"),
                S = t("../math/vec2");

            function s(t) {
                "number" == typeof t && "number" == typeof arguments[1] && (t = {
                    length: t,
                    radius: arguments[1]
                }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = o.CAPSULE, o.call(this, t)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    o = 2 * e;
                return t * (o * o + i * i) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var n = S.create();
            s.prototype.computeAABB = function(t, e, i) {
                var o = this.radius;
                S.set(n, this.length / 2, 0), 0 !== i && S.rotate(n, n, i), S.set(t.upperBound, Math.max(n[0] + o, -n[0] + o), Math.max(n[1] + o, -n[1] + o)), S.set(t.lowerBound, Math.min(n[0] - o, -n[0] - o), Math.min(n[1] - o, -n[1] - o)), S.add(t.lowerBound, t.lowerBound, e), S.add(t.upperBound, t.upperBound, e)
            };
            var C = S.create(),
                w = S.create(),
                A = S.create(),
                P = S.create(),
                T = S.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, o) {
                for (var s = e.from, n = e.to, r = (e.direction, C), a = w, h = A, l = P, d = this.length / 2, c = 0; c < 2; c++) {
                    var u = this.radius * (2 * c - 1);
                    if (S.set(h, -d, u), S.set(l, d, u), S.toGlobalFrame(h, h, i, o), S.toGlobalFrame(l, l, i, o), 0 <= (b = S.getLineSegmentsIntersectionFraction(s, n, h, l)) && (S.rotate(a, T, o), S.scale(a, a, 2 * c - 1), e.reportIntersection(t, b, a, -1), t.shouldStop(e))) return
                }
                var p = Math.pow(this.radius, 2) + Math.pow(d, 2);
                for (c = 0; c < 2; c++) {
                    S.set(h, d * (2 * c - 1), 0), S.toGlobalFrame(h, h, i, o);
                    var b, m = Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2),
                        y = 2 * ((n[0] - s[0]) * (s[0] - h[0]) + (n[1] - s[1]) * (s[1] - h[1])),
                        f = Math.pow(s[0] - h[0], 2) + Math.pow(s[1] - h[1], 2) - Math.pow(this.radius, 2);
                    if (!((b = Math.pow(y, 2) - 4 * m * f) < 0))
                        if (0 === b) {
                            if (S.lerp(r, s, n, b), S.squaredDistance(r, i) > p && (S.sub(a, r, h), S.normalize(a, a), e.reportIntersection(t, b, a, -1), t.shouldStop(e))) return
                        } else {
                            var x = Math.sqrt(b),
                                g = 1 / (2 * m),
                                _ = (-y - x) * g,
                                v = (-y + x) * g;
                            if (0 <= _ && _ <= 1 && (S.lerp(r, s, n, _), S.squaredDistance(r, i) > p && (S.sub(a, r, h), S.normalize(a, a), e.reportIntersection(t, _, a, -1), t.shouldStop(e)))) return;
                            if (0 <= v && v <= 1 && (S.lerp(r, s, n, v), S.squaredDistance(r, i) > p && (S.sub(a, r, h), S.normalize(a, a), e.reportIntersection(t, v, a, -1), t.shouldStop(e)))) return
                        }
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(t, e, i) {
            var o = t("./Shape"),
                f = t("../math/vec2");

            function s(t) {
                "number" == typeof t && (t = {
                    radius: t
                }), t = t || {}, this.radius = t.radius || 1, t.type = o.CIRCLE, o.call(this, t)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }, s.prototype.computeAABB = function(t, e, i) {
                var o = this.radius;
                f.set(t.upperBound, o, o), f.set(t.lowerBound, -o, -o), e && (f.add(t.lowerBound, t.lowerBound, e), f.add(t.upperBound, t.upperBound, e))
            };
            var x = f.create(),
                g = f.create();
            s.prototype.raycast = function(t, e, i, o) {
                var s = e.from,
                    n = e.to,
                    r = this.radius,
                    a = Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2),
                    h = 2 * ((n[0] - s[0]) * (s[0] - i[0]) + (n[1] - s[1]) * (s[1] - i[1])),
                    l = Math.pow(s[0] - i[0], 2) + Math.pow(s[1] - i[1], 2) - Math.pow(r, 2),
                    d = Math.pow(h, 2) - 4 * a * l,
                    c = x,
                    u = g;
                if (!(d < 0))
                    if (0 === d) f.lerp(c, s, n, d), f.sub(u, c, i), f.normalize(u, u), e.reportIntersection(t, d, u, -1);
                    else {
                        var p = Math.sqrt(d),
                            b = 1 / (2 * a),
                            m = (-h - p) * b,
                            y = (-h + p) * b;
                        if (0 <= m && m <= 1 && (f.lerp(c, s, n, m), f.sub(u, c, i), f.normalize(u, u), e.reportIntersection(t, m, u, -1), t.shouldStop(e))) return;
                        0 <= y && y <= 1 && (f.lerp(c, s, n, y), f.sub(u, c, i), f.normalize(u, u), e.reportIntersection(t, y, u, -1))
                    }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(t, e, i) {
            var h = t("./Shape"),
                p = t("../math/vec2"),
                a = t("../math/polyk");
            t("poly-decomp");

            function u(t) {
                Array.isArray(t) && (t = {
                    vertices: t,
                    axes: arguments[1]
                }), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var o = p.create();
                    p.copy(o, e[i]), this.vertices.push(o)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var s = p.create();
                        p.copy(s, t.axes[i]), this.axes.push(s)
                    } else
                        for (i = 0; i < this.vertices.length; i++) {
                            var n = this.vertices[i],
                                r = this.vertices[(i + 1) % this.vertices.length],
                                a = p.create();
                            p.sub(a, r, n), p.rotate90cw(a, a), p.normalize(a, a), this.axes.push(a)
                        }
                if (this.centerOfMass = p.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = h.CONVEX, h.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }((e.exports = u).prototype = new h).constructor = u;
            var l = p.create(),
                r = p.create();
            u.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, o, s = null, n = null, r = (t = l, 0); r < this.vertices.length; r++) i = this.vertices[r], o = p.dot(i, t), (null === s || s < o) && (s = o), (null === n || o < n) && (n = o);
                if (s < n) {
                    var a = n;
                    n = s, s = a
                }
                p.set(e, n, s)
            }, u.prototype.projectOntoWorldAxis = function(t, e, i, o) {
                var s = r;
                this.projectOntoLocalAxis(t, o), 0 !== i ? p.rotate(s, t, i) : s = t;
                var n = p.dot(e, s);
                p.set(o, o[0] + n, o[1] + n)
            }, u.prototype.updateTriangles = function() {
                for (var t = [], e = this.triangles.length = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                var o = a.Triangulate(t);
                for (e = 0; e < o.length; e += 3) {
                    var s = o[e],
                        n = o[e + 1],
                        r = o[e + 2];
                    this.triangles.push([s, n, r])
                }
            };
            var b = p.create(),
                m = p.create(),
                y = p.create(),
                f = p.create(),
                x = p.create();
            p.create(), p.create(), p.create(), p.create();
            u.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    o = b,
                    s = y,
                    n = f,
                    r = x,
                    a = m;
                p.set(i, 0, 0);
                for (var h = 0, l = 0; l !== t.length; l++) {
                    var d = t[l];
                    s = e[d[0]], n = e[d[1]], r = e[d[2]];
                    p.centroid(o, s, n, r);
                    var c = u.triangleArea(s, n, r);
                    h += c, p.scale(a, o, c), p.add(i, i, a)
                }
                p.scale(i, i, 1 / h)
            }, u.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, o = this.vertices.length, s = o - 1, n = 0; n < o; s = n, n++) {
                    var r = this.vertices[s],
                        a = this.vertices[n],
                        h = Math.abs(p.crossLength(r, a));
                    e += h * (p.dot(a, a) + p.dot(a, r) + p.dot(r, r)), i += h
                }
                return t / 6 * (e / i)
            }, u.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var o = p.squaredLength(t[i]);
                    e < o && (e = o)
                }
                this.boundingRadius = Math.sqrt(e)
            }, u.triangleArea = function(t, e, i) {
                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            }, u.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var o = t[i],
                        s = e[o[0]],
                        n = e[o[1]],
                        r = e[o[2]],
                        a = u.triangleArea(s, n, r);
                    this.area += a
                }
            }, u.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var g = p.create(),
                _ = p.create(),
                v = p.create();
            u.prototype.raycast = function(t, e, i, o) {
                var s = g,
                    n = _,
                    r = v,
                    a = this.vertices;
                p.toLocalFrame(s, e.from, i, o), p.toLocalFrame(n, e.to, i, o);
                for (var h = a.length, l = 0; l < h && !t.shouldStop(e); l++) {
                    var d = a[l],
                        c = a[(l + 1) % h],
                        u = p.getLineSegmentsIntersectionFraction(s, n, d, c);
                    0 <= u && (p.sub(r, c, d), p.rotate(r, r, -Math.PI / 2 + o), p.normalize(r, r), e.reportIntersection(t, u, r, l))
                }
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(t, e, i) {
            var o = t("./Shape"),
                y = t("../math/vec2");
            t("../utils/Utils");

            function s(t) {
                if (Array.isArray(t) && (t = {
                        heights: t
                    }, "object" == typeof arguments[1]))
                    for (var e in arguments[1]) t[e] = arguments[1][e];
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = o.HEIGHTFIELD, o.call(this, t)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], o = 0; o !== t.length; o++) {
                    var s = t[o];
                    e < s && (e = s), s < i && (i = s)
                }
                this.maxValue = e, this.minValue = i
            }, s.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var n = [y.create(), y.create(), y.create(), y.create()];
            s.prototype.computeAABB = function(t, e, i) {
                y.set(n[0], 0, this.maxValue), y.set(n[1], this.elementWidth * this.heights.length, this.maxValue), y.set(n[2], this.elementWidth * this.heights.length, this.minValue), y.set(n[3], 0, this.minValue), t.setFromPoints(n, e, i)
            }, s.prototype.getLineSegment = function(t, e, i) {
                var o = this.heights,
                    s = this.elementWidth;
                y.set(t, i * s, o[i]), y.set(e, (i + 1) * s, o[i + 1])
            }, s.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            }, s.prototype.getClampedSegmentIndex = function(t) {
                var e = this.getSegmentIndex(t);
                return e = Math.min(this.heights.length, Math.max(e, 0))
            };
            y.create();
            var f = y.create(),
                x = y.create(),
                g = y.create(),
                _ = y.create(),
                v = y.create();
            y.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, o) {
                var s = e.from,
                    n = e.to,
                    r = (e.direction, f),
                    a = x,
                    h = g,
                    l = _,
                    d = v;
                y.toLocalFrame(l, s, i, o), y.toLocalFrame(d, n, i, o);
                var c = this.getClampedSegmentIndex(l),
                    u = this.getClampedSegmentIndex(d);
                if (u < c) {
                    var p = c;
                    c = u, u = p
                }
                for (var b = 0; b < this.heights.length - 1; b++) {
                    this.getLineSegment(a, h, b);
                    var m = y.getLineSegmentsIntersectionFraction(l, d, a, h);
                    if (0 <= m && (y.sub(r, h, a), y.rotate(r, r, o + Math.PI / 2), y.normalize(r, r), e.reportIntersection(t, m, r, -1), t.shouldStop(e))) return
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(t, e, i) {
            var o = t("./Shape"),
                c = t("../math/vec2");

            function s(t) {
                "number" == typeof t && (t = {
                    length: t
                }), t = t || {}, this.length = t.length || 1, t.type = o.LINE, o.call(this, t)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var n = [c.create(), c.create()];
            s.prototype.computeAABB = function(t, e, i) {
                var o = this.length / 2;
                c.set(n[0], -o, 0), c.set(n[1], o, 0), t.setFromPoints(n, e, i, 0)
            };
            c.create();
            var u = c.create(),
                p = c.create(),
                b = c.create(),
                m = c.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, o) {
                var s = e.from,
                    n = e.to,
                    r = p,
                    a = b,
                    h = this.length / 2;
                c.set(r, -h, 0), c.set(a, h, 0), c.toGlobalFrame(r, r, i, o), c.toGlobalFrame(a, a, i, o);
                var l = c.getLineSegmentsIntersectionFraction(r, a, s, n);
                if (0 <= l) {
                    var d = u;
                    c.rotate(d, m, o), e.reportIntersection(t, l, d, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(t, e, i) {
            var o = t("./Shape"),
                s = t("../math/vec2");

            function n(t) {
                (t = t || {}).type = o.PARTICLE, o.call(this, t)
            }(((e.exports = n).prototype = new o).constructor = n).prototype.computeMomentOfInertia = function(t) {
                return 0
            }, n.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }, n.prototype.computeAABB = function(t, e, i) {
                s.copy(t.lowerBound, e), s.copy(t.upperBound, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(t, e, i) {
            var o = t("./Shape"),
                p = t("../math/vec2");
            t("../utils/Utils");

            function s(t) {
                (t = t || {}).type = o.PLANE, o.call(this, t)
            }(((e.exports = s).prototype = new o).constructor = s).prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.computeAABB = function(t, e, i) {
                var o = i % (2 * Math.PI),
                    s = p.set,
                    n = Number.MAX_VALUE,
                    r = t.lowerBound,
                    a = t.upperBound;
                0 === o ? (s(r, -n, -n), s(a, n, 0)) : o === Math.PI / 2 ? (s(r, 0, -n), s(a, n, n)) : o === Math.PI ? (s(r, -n, 0), s(a, n, n)) : o === 3 * Math.PI / 2 ? (s(r, -n, -n), s(a, 0, n)) : (s(r, -n, -n), s(a, n, n)), p.add(r, r, e), p.add(a, a, e)
            }, s.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var b = p.create(),
                m = (p.create(), p.create(), p.create()),
                y = p.create();
            s.prototype.raycast = function(t, e, i, o) {
                var s = e.from,
                    n = e.to,
                    r = e.direction,
                    a = b,
                    h = m,
                    l = y;
                p.set(h, 0, 1), p.rotate(h, h, o), p.sub(l, s, i);
                var d = p.dot(l, h);
                if (p.sub(l, n, i), !(0 < d * p.dot(l, h) || p.squaredDistance(s, n) < d * d)) {
                    var c = p.dot(h, r);
                    p.sub(a, s, i);
                    var u = -p.dot(h, a) / c / e.length;
                    e.reportIntersection(t, u, h, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(t, e, i) {
            e.exports = s;
            var o = t("../math/vec2");

            function s(t) {
                t = t || {}, this.body = null, this.position = o.fromValues(0, 0), t.position && o.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
            }
            s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, Object.defineProperty(s, "RECTANGLE", {
                get: function() {
                    return s.BOX
                }
            }), s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, o) {}
        }, {
            "../math/vec2": 30
        }],
        46: [function(t, e, i) {
            var S = t("../math/vec2"),
                o = t("./Solver"),
                C = t("../utils/Utils"),
                w = t("../equations/FrictionEquation");

            function A(t) {
                o.call(this, t, o.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new C.ARRAY_TYPE(this.arrayStep), this.Bs = new C.ARRAY_TYPE(this.arrayStep), this.invCs = new C.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
            }(((e.exports = A).prototype = new o).constructor = A).prototype.solve = function(t, e) {
                this.sortEquations();
                var i = 0,
                    o = this.iterations,
                    s = this.frictionIterations,
                    n = this.equations,
                    r = n.length,
                    a = Math.pow(this.tolerance * r, 2),
                    h = e.bodies,
                    l = e.bodies.length,
                    d = (S.add, S.set, this.useZeroRHS),
                    c = this.lambda;
                if (this.usedIterations = 0, r)
                    for (var u = 0; u !== l; u++) {
                        h[u].updateSolveMassProperties()
                    }
                c.length < r && (c = this.lambda = new C.ARRAY_TYPE(r + this.arrayStep), this.Bs = new C.ARRAY_TYPE(r + this.arrayStep), this.invCs = new C.ARRAY_TYPE(r + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--;) t[e] = 0
                    }(c);
                var p, b, m = this.invCs,
                    y = this.Bs;
                for (c = this.lambda, u = 0; u !== n.length; u++) {
                    var f;
                    ((f = n[u]).timeStep !== t || f.needsUpdate) && (f.timeStep = t, f.update()), y[u] = f.computeB(f.a, f.b, t), m[u] = f.computeInvC(f.epsilon)
                }
                if (0 !== r) {
                    for (u = 0; u !== l; u++) {
                        h[u].resetConstraintVelocity()
                    }
                    if (s) {
                        for (i = 0; i !== s; i++) {
                            for (b = p = 0; b !== r; b++) {
                                f = n[b];
                                var x = A.iterateEquation(b, f, f.epsilon, y, m, c, d, t, i);
                                p += Math.abs(x)
                            }
                            if (this.usedIterations++, p * p <= a) break
                        }
                        for (A.updateMultipliers(n, c, 1 / t), b = 0; b !== r; b++) {
                            var g = n[b];
                            if (g instanceof w) {
                                for (var _ = 0, v = 0; v !== g.contactEquations.length; v++) _ += g.contactEquations[v].multiplier;
                                _ *= g.frictionCoefficient / g.contactEquations.length, g.maxForce = _, g.minForce = -_
                            }
                        }
                    }
                    for (i = 0; i !== o; i++) {
                        for (b = p = 0; b !== r; b++) {
                            f = n[b];
                            x = A.iterateEquation(b, f, f.epsilon, y, m, c, d, t, i);
                            p += Math.abs(x)
                        }
                        if (this.usedIterations++, p * p <= a) break
                    }
                    for (u = 0; u !== l; u++) h[u].addConstraintVelocity();
                    A.updateMultipliers(n, c, 1 / t)
                }
            }, A.updateMultipliers = function(t, e, i) {
                for (var o = t.length; o--;) t[o].multiplier = e[o] * i
            }, A.iterateEquation = function(t, e, i, o, s, n, r, a, h) {
                var l = o[t],
                    d = s[t],
                    c = n[t],
                    u = e.computeGWlambda(),
                    p = e.maxForce,
                    b = e.minForce;
                r && (l = 0);
                var m = d * (l - u - i * c),
                    y = c + m;
                return y < b * a ? m = b * a - c : p * a < y && (m = p * a - c), n[t] += m, e.addToWlambda(m), m
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(t, e, i) {
            t("../utils/Utils");
            var o = t("../events/EventEmitter");

            function s(t, e) {
                t = t || {}, o.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
            }(((e.exports = s).prototype = new o).constructor = s).prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var n = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), n.bodies.length = 0, e.getBodies(n.bodies), n.bodies.length && this.solve(t, n))
            }, s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }, s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            }, s.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var o = t[e];
                    o.enabled && this.equations.push(o)
                }
            }, s.prototype.removeEquation = function(t) {
                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
            }, s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }, s.GS = 1, s.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(t, e, i) {
            var o = t("../equations/ContactEquation"),
                s = t("./Pool");

            function n() {
                s.apply(this, arguments)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.create = function() {
                return new o
            }, n.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(t, e, i) {
            var o = t("../equations/FrictionEquation"),
                s = t("./Pool");

            function n() {
                s.apply(this, arguments)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.create = function() {
                return new o
            }, n.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(t, e, i) {
            var o = t("../world/IslandNode"),
                s = t("./Pool");

            function n() {
                s.apply(this, arguments)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.create = function() {
                return new o
            }, n.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(t, e, i) {
            var o = t("../world/Island"),
                s = t("./Pool");

            function n() {
                s.apply(this, arguments)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.create = function() {
                return new o
            }, n.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(t, e, i) {
            var o = t("./TupleDictionary"),
                s = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils");

            function n() {
                this.overlappingShapesLastState = new o, this.overlappingShapesCurrentState = new o, this.recordPool = new s({
                    size: 16
                }), this.tmpDict = new o, this.tmpArray1 = []
            }(e.exports = n).prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var o = t.keys[i],
                        s = t.getByKey(o);
                    e.getByKey(o);
                    s && this.recordPool.release(s)
                }
                t.reset(), t.copy(e), e.reset()
            }, n.prototype.setOverlapping = function(t, e, i, o) {
                this.overlappingShapesLastState;
                var s = this.overlappingShapesCurrentState;
                if (!s.get(e.id, o.id)) {
                    var n = this.recordPool.get();
                    n.set(t, e, i, o), s.set(e.id, o.id, n)
                }
            }, n.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            }, n.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            }, n.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, o = i.keys.length; o--;) {
                    var s = i.keys[o],
                        n = i.data[s];
                    if (n.bodyA === t && n.bodyB === e || n.bodyA === e && n.bodyB === t) return !0
                }
                return !1
            }, n.prototype.getDiff = function(t, e, i) {
                var o = t,
                    s = e;
                (i = i || []).length = 0;
                for (var n = s.keys.length; n--;) {
                    var r = s.keys[n],
                        a = s.data[r];
                    if (!a) throw new Error("Key " + r + " had no data!");
                    o.data[r] || i.push(a)
                }
                return i
            }, n.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    o = 0 | e.id,
                    s = this.overlappingShapesLastState,
                    n = this.overlappingShapesCurrentState;
                return !s.get(i, o) && !!n.get(i, o)
            }, n.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, n.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, n.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, o = t.length; o--;) {
                    var s = t[o];
                    i.set(0 | s.bodyA.id, 0 | s.bodyB.id, s)
                }
                for (o = i.keys.length; o--;) {
                    (s = i.getByKey(i.keys[o])) && e.push(s.bodyA, s.bodyB)
                }
                return i.reset(), e
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(t, e, i) {
            function s(t, e, i, o) {
                this.shapeA = e, this.shapeB = o, this.bodyA = t, this.bodyB = i
            }(e.exports = s).prototype.set = function(t, e, i, o) {
                s.call(this, t, e, i, o)
            }
        }, {}],
        54: [function(t, e, i) {
            var o = t("./OverlapKeeperRecord"),
                s = t("./Pool");

            function n() {
                s.apply(this, arguments)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.create = function() {
                return new o
            }, n.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(t, e, i) {
            function o(t) {
                t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
            }(e.exports = o).prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            }, o.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            }, o.prototype.release = function(t) {
                return this.destroy(t), this.objects.push(t), this
            }
        }, {}],
        56: [function(t, e, i) {
            var o = t("./Utils");

            function s() {
                this.data = {}, this.keys = []
            }(e.exports = s).prototype.getKey = function(t, e) {
                return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | e) < (0 | t) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
            }, s.prototype.getByKey = function(t) {
                return t |= 0, this.data[t]
            }, s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            }, s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                var o = this.getKey(t, e);
                return this.data[o] || this.keys.push(o), this.data[o] = i, o
            }, s.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, s.prototype.copy = function(t) {
                this.reset(), o.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, {
            "./Utils": 57
        }],
        57: [function(t, e, i) {
            function o() {}(e.exports = o).appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, o = e.length; i !== o; ++i) t.push(e[i])
            }, o.splice = function(t, e, i) {
                i = i || 1;
                for (var o = e, s = t.length - i; o < s; o++) t[o] = t[o + i];
                t.length = s
            }, o.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, o.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            }, o.defaults = function(t, e) {
                for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                return t
            }
        }, {}],
        58: [function(t, e, i) {
            var o = t("../objects/Body");

            function s() {
                this.equations = [], this.bodies = []
            }(e.exports = s).prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var n = [];
            s.prototype.getBodies = function(t) {
                for (var e = t || [], i = this.equations, o = n.length = 0; o !== i.length; o++) {
                    var s = i[o]; - 1 === n.indexOf(s.bodyA.id) && (e.push(s.bodyA), n.push(s.bodyA.id)), -1 === n.indexOf(s.bodyB.id) && (e.push(s.bodyB), n.push(s.bodyB.id))
                }
                return e
            }, s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === o.DYNAMIC && !e.wantsToSleep) return !1
                }
                return !0
            }, s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    this.bodies[t].sleep()
                }
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        59: [function(t, e, i) {
            t("../math/vec2"), t("./Island"), t("./IslandNode");
            var o = t("./../utils/IslandNodePool"),
                s = t("./../utils/IslandPool"),
                r = t("../objects/Body");

            function b(t) {
                this.nodePool = new o({
                    size: 16
                }), this.islandPool = new s({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
            }(e.exports = b).getUnvisitedNode = function(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var o = t[i];
                    if (!o.visited && o.body.type === r.DYNAMIC) return o
                }
                return !1
            }, b.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var o = t.equations.length, s = 0; s !== o; s++) {
                    var n = t.equations[s]; - 1 === i.indexOf(n) && i.push(n)
                }
            }, b.prototype.bfs = function(t, e, i) {
                var o = this.queue;
                for (o.length = 0, o.push(t), t.visited = !0, this.visit(t, e, i); o.length;)
                    for (var s, n = o.pop(); s = b.getUnvisitedNode(n.neighbors);) s.visited = !0, this.visit(s, e, i), s.body.type === r.DYNAMIC && o.push(s)
            }, b.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, o = this.equations; i.length;) this.nodePool.release(i.pop());
                for (var s = 0; s !== e.length; s++) {
                    var n = this.nodePool.get();
                    n.body = e[s], i.push(n)
                }
                for (var r = 0; r !== o.length; r++) {
                    var a = o[r],
                        h = (s = e.indexOf(a.bodyA), e.indexOf(a.bodyB)),
                        l = i[s],
                        d = i[h];
                    l.neighbors.push(d), d.neighbors.push(l), l.equations.push(a), d.equations.push(a)
                }
                var c, u = this.islands;
                for (s = 0; s < u.length; s++) this.islandPool.release(u[s]);
                for (u.length = 0; c = b.getUnvisitedNode(i);) {
                    var p = this.islandPool.get();
                    this.bfs(c, p.bodies, p.equations), u.push(p)
                }
                return u
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(t, e, i) {
            function o(t) {
                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
            }(e.exports = o).prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
            }
        }, {}],
        61: [function(t, e, i) {
            var o = t("../solver/GSSolver"),
                q = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                f = t("../shapes/Circle"),
                x = t("../shapes/Convex"),
                g = (t("../shapes/Line"), t("../shapes/Plane")),
                _ = t("../shapes/Capsule"),
                v = t("../shapes/Particle"),
                s = t("../events/EventEmitter"),
                j = t("../objects/Body"),
                n = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                r = t("../material/ContactMaterial"),
                a = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                h = t("../collision/SAPBroadphase"),
                l = t("../collision/Narrowphase"),
                Y = t("../utils/Utils"),
                d = t("../utils/OverlapKeeper"),
                c = t("./IslandManager");
            t("../objects/RotationalSpring");

            function z(t) {
                s.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new o, this.narrowphase = new l(this), this.islandManager = new c, this.gravity = q.fromValues(0, -9.78), t.gravity && q.copy(this.gravity, t.gravity), this.frictionGravity = q.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new h, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new n, this.defaultContactMaterial = new r(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = z.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new d
            }(((e.exports = z).prototype = new Object(s.prototype)).constructor = z).NO_SLEEPING = 1, z.BODY_SLEEPING = 2, z.ISLAND_SLEEPING = 4, z.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            }, z.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            }, z.prototype.removeContactMaterial = function(t) {
                var e = this.contactMaterials.indexOf(t); - 1 !== e && Y.splice(this.contactMaterials, e, 1)
            }, z.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials, o = 0, s = i.length; o !== s; o++) {
                    var n = i[o];
                    if (n.materialA.id === t.id && n.materialB.id === e.id || n.materialA.id === e.id && n.materialB.id === t.id) return n
                }
                return !1
            }, z.prototype.removeConstraint = function(t) {
                var e = this.constraints.indexOf(t); - 1 !== e && Y.splice(this.constraints, e, 1)
            };
            q.create(), q.create(), q.create(), q.create(), q.create(), q.create();
            var H = q.create(),
                w = q.fromValues(0, 0),
                A = q.fromValues(0, 0);
            q.fromValues(0, 0), q.fromValues(0, 0);
            z.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var o = 0; this.accumulator >= t && o < i;) this.internalStep(t), this.time += t, this.accumulator -= t, o++;
                    for (var s = this.accumulator % t / t, n = 0; n !== this.bodies.length; n++) {
                        var r = this.bodies[n];
                        q.lerp(r.interpolatedPosition, r.previousPosition, r.position, s), r.interpolatedAngle = r.previousAngle + s * (r.angle - r.previousAngle)
                    }
                }
            };
            var K = [];
            z.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                    i = this.springs,
                    o = this.bodies,
                    s = this.gravity,
                    n = this.solver,
                    r = this.bodies.length,
                    a = this.broadphase,
                    h = this.narrowphase,
                    l = this.constraints,
                    d = H,
                    c = (q.scale, q.add),
                    u = (q.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var p = q.length(this.gravity);
                    0 === p && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = p)
                }
                if (this.applyGravity)
                    for (var b = 0; b !== r; b++) {
                        var m = (y = o[b]).force;
                        y.type === j.DYNAMIC && y.sleepState !== j.SLEEPING && (q.scale(d, s, y.mass * y.gravityScale), c(m, m, d))
                    }
                if (this.applySpringForces)
                    for (b = 0; b !== e; b++) {
                        i[b].applyForce()
                    }
                if (this.applyDamping)
                    for (b = 0; b !== r; b++) {
                        var y;
                        (y = o[b]).type === j.DYNAMIC && y.applyDamping(t)
                    }
                var f = a.getCollisionPairs(this),
                    x = this.disabledBodyCollisionPairs;
                for (b = x.length - 2; 0 <= b; b -= 2)
                    for (var g = f.length - 2; 0 <= g; g -= 2)(x[b] === f[g] && x[b + 1] === f[g + 1] || x[b + 1] === f[g] && x[b] === f[g + 1]) && f.splice(g, 2);
                var _ = l.length;
                for (b = 0; b !== _; b++) {
                    var v = l[b];
                    if (!v.collideConnected)
                        for (g = f.length - 2; 0 <= g; g -= 2)(v.bodyA === f[g] && v.bodyB === f[g + 1] || v.bodyB === f[g] && v.bodyA === f[g + 1]) && f.splice(g, 2)
                }
                this.postBroadphaseEvent.pairs = f, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, h.reset(this);
                b = 0;
                for (var S = f.length; b !== S; b += 2)
                    for (var C = f[b], w = f[b + 1], A = 0, P = C.shapes.length; A !== P; A++)
                        for (var T = C.shapes[A], B = T.position, M = T.angle, E = 0, I = w.shapes.length; E !== I; E++) {
                            var V = w.shapes[E],
                                R = V.position,
                                L = V.angle,
                                D = this.defaultContactMaterial;
                            if (T.material && V.material) {
                                var F = this.getContactMaterial(T.material, V.material);
                                F && (D = F)
                            }
                            this.runNarrowphase(h, C, T, B, M, w, V, R, L, D, this.frictionGravity)
                        }
                for (b = 0; b !== r; b++) {
                    (N = o[b])._wakeUpAfterNarrowphase && (N.wakeUp(), N._wakeUpAfterNarrowphase = !1)
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(K);
                    var k = this.endContactEvent;
                    for (E = K.length; E--;) {
                        var G = K[E];
                        k.shapeA = G.shapeA, k.shapeB = G.shapeB, k.bodyA = G.bodyA, k.bodyB = G.bodyB, this.emit(k)
                    }
                    K.length = 0
                }
                var O = this.preSolveEvent;
                O.contactEquations = h.contactEquations, O.frictionEquations = h.frictionEquations, this.emit(O), O.contactEquations = O.frictionEquations = null;
                _ = l.length;
                for (b = 0; b !== _; b++) l[b].update();
                if (h.contactEquations.length || h.frictionEquations.length || _)
                    if (this.islandSplit) {
                        for (u.equations.length = 0, Y.appendArray(u.equations, h.contactEquations), Y.appendArray(u.equations, h.frictionEquations), b = 0; b !== _; b++) Y.appendArray(u.equations, l[b].equations);
                        u.split(this);
                        for (b = 0; b !== u.islands.length; b++) {
                            (W = u.islands[b]).equations.length && n.solveIsland(t, W)
                        }
                    } else {
                        for (n.addEquations(h.contactEquations), n.addEquations(h.frictionEquations), b = 0; b !== _; b++) n.addEquations(l[b].equations);
                        this.solveConstraints && n.solve(t, this), n.removeAllEquations()
                    }
                for (b = 0; b !== r; b++) {
                    var N;
                    (N = o[b]).integrate(t)
                }
                for (b = 0; b !== r; b++) o[b].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) {
                    var J = this.impactEvent;
                    for (b = 0; b !== h.contactEquations.length; b++) {
                        var U = h.contactEquations[b];
                        U.firstImpact && (J.bodyA = U.bodyA, J.bodyB = U.bodyB, J.shapeA = U.shapeA, J.shapeB = U.shapeB, J.contactEquation = U, this.emit(J))
                    }
                }
                if (this.sleepMode === z.BODY_SLEEPING)
                    for (b = 0; b !== r; b++) o[b].sleepTick(this.time, !1, t);
                else if (this.sleepMode === z.ISLAND_SLEEPING && this.islandSplit) {
                    for (b = 0; b !== r; b++) o[b].sleepTick(this.time, !0, t);
                    for (b = 0; b < this.islandManager.islands.length; b++) {
                        var W;
                        (W = this.islandManager.islands[b]).wantsToSleep() && W.sleep()
                    }
                }
                this.stepping = !1;
                var X = this.bodiesToBeRemoved;
                for (b = 0; b !== X.length; b++) this.removeBody(X[b]);
                X.length = 0, this.emit(this.postStepEvent)
            }, z.prototype.runNarrowphase = function(t, e, i, o, s, n, r, a, h, l, d) {
                if (0 != (i.collisionGroup & r.collisionMask) && 0 != (r.collisionGroup & i.collisionMask)) {
                    q.rotate(w, o, e.angle), q.rotate(A, a, n.angle), q.add(w, w, e.position), q.add(A, A, n.position);
                    var c, u = s + e.angle,
                        p = h + n.angle;
                    t.enableFriction = 0 < l.friction, t.frictionCoefficient = l.friction, c = e.type === j.STATIC || e.type === j.KINEMATIC ? n.mass : n.type === j.STATIC || n.type === j.KINEMATIC ? e.mass : e.mass * n.mass / (e.mass + n.mass), t.slipForce = l.friction * d * c, t.restitution = l.restitution, t.surfaceVelocity = l.surfaceVelocity, t.frictionStiffness = l.frictionStiffness, t.frictionRelaxation = l.frictionRelaxation, t.stiffness = l.stiffness, t.relaxation = l.relaxation, t.contactSkinSize = l.contactSkinSize, t.enabledEquations = e.collisionResponse && n.collisionResponse && i.collisionResponse && r.collisionResponse;
                    var b = t[i.type | r.type],
                        m = 0;
                    if (b) {
                        var y = i.sensor || r.sensor,
                            f = t.frictionEquations.length;
                        m = i.type < r.type ? b.call(t, e, i, w, u, n, r, A, p, y) : b.call(t, n, r, A, p, e, i, w, u, y);
                        var x = t.frictionEquations.length - f;
                        if (m) {
                            if (e.allowSleep && e.type === j.DYNAMIC && e.sleepState === j.SLEEPING && n.sleepState === j.AWAKE && n.type !== j.STATIC) {
                                var g = q.squaredLength(n.velocity) + Math.pow(n.angularVelocity, 2);
                                2 * Math.pow(n.sleepSpeedLimit, 2) <= g && (e._wakeUpAfterNarrowphase = !0)
                            }
                            if (n.allowSleep && n.type === j.DYNAMIC && n.sleepState === j.SLEEPING && e.sleepState === j.AWAKE && e.type !== j.STATIC) {
                                var _ = q.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2);
                                2 * Math.pow(e.sleepSpeedLimit, 2) <= _ && (n._wakeUpAfterNarrowphase = !0)
                            }
                            if (this.overlapKeeper.setOverlapping(e, i, n, r), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, r)) {
                                var v = this.beginContactEvent;
                                if (v.shapeA = i, v.shapeB = r, v.bodyA = e, v.bodyB = n, v.contactEquations.length = 0, "number" == typeof m)
                                    for (var S = t.contactEquations.length - m; S < t.contactEquations.length; S++) v.contactEquations.push(t.contactEquations[S]);
                                this.emit(v)
                            }
                            if ("number" == typeof m && 1 < x)
                                for (S = t.frictionEquations.length - x; S < t.frictionEquations.length; S++) {
                                    var C = t.frictionEquations[S];
                                    C.setSlipForce(C.getSlipForce() / x)
                                }
                        }
                    }
                }
            }, z.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, z.prototype.removeSpring = function(t) {
                var e = this.springs.indexOf(t); - 1 !== e && Y.splice(this.springs, e, 1)
            }, z.prototype.addBody = function(t) {
                if (-1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t);
                    var e = (t.world = this).addBodyEvent;
                    e.body = t, this.emit(e), e.body = null
                }
            }, z.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else {
                    t.world = null;
                    var e = this.bodies.indexOf(t); - 1 !== e && (Y.splice(this.bodies, e, 1), (this.removeBodyEvent.body = t).resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            }, z.prototype.getBodyById = function(t) {
                for (var e = this.bodies, i = 0; i < e.length; i++) {
                    var o = e[i];
                    if (o.id === t) return o
                }
                return !1
            }, z.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            }, z.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, o = 0; o < i.length; o += 2)
                    if (i[o] === t && i[o + 1] === e || i[o + 1] === t && i[o] === e) return void i.splice(o, 2)
            }, z.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; 0 <= e; e--) this.removeConstraint(t[e]);
                var i = this.bodies;
                for (e = i.length - 1; 0 <= e; e--) this.removeBody(i[e]);
                var o = this.springs;
                for (e = o.length - 1; 0 <= e; e--) this.removeSpring(o[e]);
                var s = this.contactMaterials;
                for (e = s.length - 1; 0 <= e; e--) this.removeContactMaterial(s[e]);
                z.apply(this)
            };
            var S = q.create(),
                C = (q.fromValues(0, 0), q.fromValues(0, 0));
            z.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var o = new j({
                        position: t
                    }),
                    s = new v,
                    n = t,
                    r = S,
                    a = C;
                o.addShape(s);
                for (var h = this.narrowphase, l = [], d = 0, c = e.length; d !== c; d++)
                    for (var u = e[d], p = 0, b = u.shapes.length; p !== b; p++) {
                        var m = u.shapes[p];
                        q.rotate(r, m.position, u.angle), q.add(r, r, u.position);
                        var y = m.angle + u.angle;
                        (m instanceof f && h.circleParticle(u, m, r, y, o, s, n, 0, !0) || m instanceof x && h.particleConvex(o, s, n, 0, u, m, r, y, !0) || m instanceof g && h.particlePlane(o, s, n, 0, u, m, r, y, !0) || m instanceof _ && h.particleCapsule(o, s, n, 0, u, m, r, y, !0) || m instanceof v && q.squaredLength(q.sub(a, r, t)) < i * i) && l.push(u)
                    }
                return l
            }, z.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var o = e[i], s = 0; s !== o.equations.length; s++) {
                        var n = o.equations[s];
                        n.stiffness = t, n.needsUpdate = !0
                    }
                var r = this.contactMaterials;
                for (i = 0; i !== r.length; i++) {
                    (o = r[i]).stiffness = o.frictionStiffness = t
                }(o = this.defaultContactMaterial).stiffness = o.frictionStiffness = t
            }, z.prototype.setGlobalRelaxation = function(t) {
                for (var e = 0; e !== this.constraints.length; e++)
                    for (var i = this.constraints[e], o = 0; o !== i.equations.length; o++) {
                        var s = i.equations[o];
                        s.relaxation = t, s.needsUpdate = !0
                    }
                for (e = 0; e !== this.contactMaterials.length; e++) {
                    (i = this.contactMaterials[e]).relaxation = i.frictionRelaxation = t
                }(i = this.defaultContactMaterial).relaxation = i.frictionRelaxation = t
            };
            var u = new a,
                p = [];
            z.prototype.raycast = function(t, e) {
                return e.getAABB(u), this.broadphase.aabbQuery(this, u, p), e.intersectBodies(t, p), p.length = 0, t.hasHit()
            }
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}),
function() {
    var t = this,
        L = L || {};
    return L.game = null, L.WEBGL_RENDERER = 0, L.CANVAS_RENDERER = 1, L.VERSION = "v2.2.9", L._UID = 0, "undefined" != typeof Float32Array ? (L.Float32Array = Float32Array, L.Uint16Array = Uint16Array, L.Uint32Array = Uint32Array, L.ArrayBuffer = ArrayBuffer) : (L.Float32Array = Array, L.Uint16Array = Array), L.PI_2 = 2 * Math.PI, L.RAD_TO_DEG = 180 / Math.PI, L.DEG_TO_RAD = Math.PI / 180, L.RETINA_PREFIX = "@2x", L.DisplayObject = function() {
        this.position = new L.Point(0, 0), this.scale = new L.Point(1, 1), this.pivot = new L.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new L.Matrix, this.worldPosition = new L.Point(0, 0), this.worldScale = new L.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new L.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
    }, L.DisplayObject.prototype.constructor = L.DisplayObject, L.DisplayObject.prototype = {
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var e = this.parent;
            t ? e = t : this.parent || (e = this.game.world);
            var i, o, s, n, r, a, h = e.worldTransform,
                l = this.worldTransform;
            return this.rotation % L.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, o = this._sr * this.scale.x, s = -this._sr * this.scale.y, n = this._cr * this.scale.y, r = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (r -= this.pivot.x * i + this.pivot.y * s, a -= this.pivot.x * o + this.pivot.y * n), l.a = i * h.a + o * h.c, l.b = i * h.b + o * h.d, l.c = s * h.a + n * h.c, l.d = s * h.b + n * h.d) : (i = this.scale.x, n = this.scale.y, r = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * n, l.a = i * h.a, l.b = i * h.b, l.c = n * h.c, l.d = n * h.d), l.tx = r * h.a + a * h.c + h.tx, l.ty = r * h.b + a * h.d + h.ty, this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.set(l.tx, l.ty), this.worldScale.set(this.scale.x * Math.sqrt(l.a * l.a + l.c * l.c), this.scale.y * Math.sqrt(l.b * l.b + l.d * l.d)), this.worldRotation = Math.atan2(-l.c, l.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
        },
        preUpdate: function() {},
        generateTexture: function(t, e, i) {
            var o = this.getLocalBounds(),
                s = new L.RenderTexture(0 | o.width, 0 | o.height, i, e, t);
            return L.DisplayObject._tempMatrix.tx = -o.x, L.DisplayObject._tempMatrix.ty = -o.y, s.render(this, L.DisplayObject._tempMatrix), s
        },
        updateCache: function() {
            return this._generateCachedSprite(), this
        },
        toGlobal: function(t) {
            return this.updateTransform(), this.worldTransform.apply(t)
        },
        toLocal: function(t, e) {
            return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
        },
        _renderCachedSprite: function(t) {
            this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? L.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : L.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var e = new L.RenderTexture(t.width, t.height);
                this._cachedSprite = new L.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform
            }
            var i = this._filters;
            this._filters = null, this._cachedSprite.filters = i, L.DisplayObject._tempMatrix.tx = -t.x, L.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, L.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = i, this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    }, L.DisplayObject.prototype.displayObjectUpdateTransform = L.DisplayObject.prototype.updateTransform, Object.defineProperties(L.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(t) {
                this._mask && (this._mask.isMask = !1), (this._mask = t) && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var e = [], i = 0; i < t.length; i++)
                        for (var o = t[i].passes, s = 0; s < o.length; s++) e.push(o[s]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: e
                    }
                }
                this._filters = t, this.blendMode && this.blendMode === L.blendModes.MULTIPLY && (this.blendMode = L.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }), L.DisplayObjectContainer = function() {
        L.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
    }, L.DisplayObjectContainer.prototype = Object.create(L.DisplayObject.prototype), L.DisplayObjectContainer.prototype.constructor = L.DisplayObjectContainer, L.DisplayObjectContainer.prototype.addChild = function(t) {
        return this.addChildAt(t, this.children.length)
    }, L.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
        if (0 <= e && e <= this.children.length) return t.parent && t.parent.removeChild(t), (t.parent = this).children.splice(e, 0, t), t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    }, L.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
                o = this.getChildIndex(e);
            if (i < 0 || o < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[o] = t
        }
    }, L.DisplayObjectContainer.prototype.getChildIndex = function(t) {
        var e = this.children.indexOf(t);
        if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }, L.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, L.DisplayObjectContainer.prototype.getChildAt = function(t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    }, L.DisplayObjectContainer.prototype.removeChild = function(t) {
        var e = this.children.indexOf(t);
        if (-1 !== e) return this.removeChildAt(e)
    }, L.DisplayObjectContainer.prototype.removeChildAt = function(t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)), e
    }, L.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var i = e - t;
        if (0 < i && i <= e) {
            for (var o = this.children.splice(begin, i), s = 0; s < o.length; s++) {
                o[s].parent = void 0
            }
            return o
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }, L.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, L.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = L.DisplayObjectContainer.prototype.updateTransform, L.DisplayObjectContainer.prototype.getBounds = function(t) {
        var e, i = t && t instanceof L.DisplayObject,
            o = !0;
        if (i ? o = t instanceof L.DisplayObjectContainer && t.contains(this) : t = this, i) {
            var s = t.worldTransform;
            for (t.worldTransform = L.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
        }
        var n, r, a, h = 1 / 0,
            l = 1 / 0,
            d = -1 / 0,
            c = -1 / 0,
            u = !1;
        for (e = 0; e < this.children.length; e++) {
            this.children[e].visible && (u = !0, h = h < (n = this.children[e].getBounds()).x ? h : n.x, l = l < n.y ? l : n.y, d = (r = n.width + n.x) < d ? d : r, c = (a = n.height + n.y) < c ? c : a)
        }
        var p = this._bounds;
        if (!u) {
            var b = (p = new L.Rectangle).x,
                m = p.width + p.x,
                y = p.y,
                f = p.height + p.y,
                x = this.worldTransform,
                g = x.a,
                _ = x.b,
                v = x.c,
                S = x.d,
                C = x.tx,
                w = x.ty,
                A = g * m + v * f + C,
                P = S * f + _ * m + w,
                T = g * b + v * f + C,
                B = S * f + _ * b + w,
                M = g * b + v * y + C,
                E = S * y + _ * b + w,
                I = g * m + v * y + C,
                V = S * y + _ * m + w;
            h = I < (h = M < (h = T < (h = d = A) ? T : h) ? M : h) ? I : h, l = V < (l = E < (l = B < (l = c = P) ? B : l) ? E : l) ? V : l, d = (d = (d = d < T ? T : d) < M ? M : d) < I ? I : d, c = (c = (c = c < B ? B : c) < E ? E : c) < V ? V : c
        }
        if (p.x = h, p.y = l, p.width = d - h, p.height = c - l, i)
            for (t.worldTransform = s, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
        if (!o) {
            var R = t.getBounds();
            p.x -= R.x, p.y -= R.y
        }
        return p
    }, L.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    }, L.DisplayObjectContainer.prototype.contains = function(t) {
        return !!t && (t === this || this.contains(t.parent))
    }, L.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        var e;
        if (this.visible && !(this.alpha <= 0))
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else if (this._mask || this._filters) {
            for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
        } else
            for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
    }, L.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha)
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else {
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
    }, Object.defineProperty(L.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(L.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), L.Sprite = function(t) {
        L.DisplayObjectContainer.call(this), this.anchor = new L.Point, this.texture = t || L.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = L.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
    }, L.Sprite.prototype = Object.create(L.DisplayObjectContainer.prototype), L.Sprite.prototype.constructor = L.Sprite, Object.defineProperty(L.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }), Object.defineProperty(L.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }), L.Sprite.prototype.setTexture = function(t, e) {
        void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
    }, L.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
    }, L.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
            i = this.texture.frame.height,
            o = e * (1 - this.anchor.x),
            s = e * -this.anchor.x,
            n = i * (1 - this.anchor.y),
            r = i * -this.anchor.y,
            a = t || this.worldTransform,
            h = a.a,
            l = a.b,
            d = a.c,
            c = a.d,
            u = a.tx,
            p = a.ty,
            b = -1 / 0,
            m = -1 / 0,
            y = 1 / 0,
            f = 1 / 0;
        if (0 === l && 0 === d) {
            if (h < 0) {
                h *= -1;
                var x = o;
                o = -s, s = -x
            }
            if (c < 0) {
                c *= -1;
                x = n;
                n = -r, r = -x
            }
            y = h * s + u, b = h * o + u, f = c * r + p, m = c * n + p
        } else {
            var g = h * s + d * r + u,
                _ = c * r + l * s + p,
                v = h * o + d * r + u,
                S = c * r + l * o + p,
                C = h * o + d * n + u,
                w = c * n + l * o + p,
                A = h * s + d * n + u,
                P = c * n + l * s + p;
            y = A < (y = C < (y = v < (y = g < y ? g : y) ? v : y) ? C : y) ? A : y, f = P < (f = w < (f = S < (f = _ < f ? _ : f) ? S : f) ? w : f) ? P : f, b = (b = (b = (b = b < g ? g : b) < v ? v : b) < C ? C : b) < A ? A : b, m = (m = (m = (m = m < _ ? _ : m) < S ? S : m) < w ? w : m) < P ? P : m
        }
        var T = this._bounds;
        return T.x = y, T.width = b - y, T.y = f, T.height = m - f, this._currentBounds = T
    }, L.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = L.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    }, L.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var o = t.spriteBatch;
                this._filters && (o.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (o.stop(), t.maskManager.pushMask(this.mask, t), o.start()), o.render(this);
                for (var s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t);
                o.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), o.start()
            } else {
                t.spriteBatch.render(this);
                for (s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t, i)
            }
        }
    }, L.Sprite.prototype._renderCanvas = function(t, e) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var i = this.worldTransform;
            if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = L.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var o = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === L.scaleModes.LINEAR);
                var s = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    n = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    r = i.tx * t.resolution + t.shakeX,
                    a = i.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | r, 0 | a), s |= 0, n |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, r, a);
                var h = this.texture.crop.width,
                    l = this.texture.crop.height;
                if (s /= o, n /= o, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = L.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, h, l, s, n, h / o, l / o);
                else {
                    var d = this.texture.crop.x,
                        c = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, d, c, h, l, s, n, h / o, l / o)
                }
            }
            for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, L.SpriteBatch = function(t) {
        L.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
    }, L.SpriteBatch.prototype = Object.create(L.DisplayObjectContainer.prototype), L.SpriteBatch.prototype.constructor = L.SpriteBatch, L.SpriteBatch.prototype.initWebGL = function(t) {
        this.fastSpriteBatch = new L.WebGLFastSpriteBatch(t), this.ready = !0
    }, L.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform()
    }, L.SpriteBatch.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
    }, L.SpriteBatch.prototype._renderCanvas = function(t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var i = this.worldTransform, o = !0, s = 0; s < this.children.length; s++) {
                var n = this.children[s];
                if (n.visible) {
                    var r = n.texture,
                        a = r.frame;
                    if (e.globalAlpha = this.worldAlpha * n.alpha, n.rotation % (2 * Math.PI) == 0) o && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), o = !1), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, n.anchor.x * (-a.width * n.scale.x) + n.position.x + .5 + t.shakeX | 0, n.anchor.y * (-a.height * n.scale.y) + n.position.y + .5 + t.shakeY | 0, a.width * n.scale.x, a.height * n.scale.y);
                    else {
                        o || (o = !0), n.displayObjectUpdateTransform();
                        var h = n.worldTransform,
                            l = h.tx * t.resolution + t.shakeX,
                            d = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | d) : e.setTransform(h.a, h.b, h.c, h.d, l, d), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, n.anchor.x * -a.width + .5 | 0, n.anchor.y * -a.height + .5 | 0, a.width, a.height)
                    }
                }
            }
        }
    }, L.hex2rgb = function(t) {
        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
    }, L.rgb2hex = function(t) {
        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
    }, L.canUseNewCanvasBlendModes = function() {
        if (void 0 === document) return !1;
        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            i = new Image;
        i.src = t + "AP804Oa6" + e;
        var o = new Image;
        o.src = t + "/wCKxvRF" + e;
        var s = L.CanvasPool.create(this, 6, 1).getContext("2d");
        if (s.globalCompositeOperation = "multiply", s.drawImage(i, 0, 0), s.drawImage(o, 2, 0), !s.getImageData(2, 0, 1, 1)) return !1;
        var n = s.getImageData(2, 0, 1, 1).data;
        return L.CanvasPool.remove(this), 255 === n[0] && 0 === n[1] && 0 === n[2]
    }, L.getNextPowerOfTwo = function(t) {
        if (0 < t && 0 == (t & t - 1)) return t;
        for (var e = 1; e < t;) e <<= 1;
        return e
    }, L.isPowerOfTwo = function(t, e) {
        return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
    }, L.CanvasPool = {
        create: function(t, e, i) {
            var o, s = L.CanvasPool.getFirst();
            if (-1 === s) {
                var n = {
                    parent: t,
                    canvas: document.createElement("canvas")
                };
                L.CanvasPool.pool.push(n), o = n.canvas
            } else L.CanvasPool.pool[s].parent = t, o = L.CanvasPool.pool[s].canvas;
            return void 0 !== e && (o.width = e, o.height = i), o
        },
        getFirst: function() {
            for (var t = L.CanvasPool.pool, e = 0; e < t.length; e++)
                if (!t[e].parent) return e;
            return -1
        },
        remove: function(t) {
            for (var e = L.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
        },
        removeByCanvas: function(t) {
            for (var e = L.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
        },
        getTotal: function() {
            for (var t = L.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++;
            return e
        },
        getFree: function() {
            for (var t = L.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++;
            return e
        }
    }, L.CanvasPool.pool = [], L.initDefaultShaders = function() {}, L.CompileVertexShader = function(t, e) {
        return L._CompileShader(t, e, t.VERTEX_SHADER)
    }, L.CompileFragmentShader = function(t, e) {
        return L._CompileShader(t, e, t.FRAGMENT_SHADER)
    }, L._CompileShader = function(t, e, i) {
        var o = e;
        Array.isArray(e) && (o = e.join("\n"));
        var s = t.createShader(i);
        return t.shaderSource(s, o), t.compileShader(s), t.getShaderParameter(s, t.COMPILE_STATUS) ? s : (window.console.log(t.getShaderInfoLog(s)), null)
    }, L.compileProgram = function(t, e, i) {
        var o = L.CompileFragmentShader(t, i),
            s = L.CompileVertexShader(t, e),
            n = t.createProgram();
        return t.attachShader(n, s), t.attachShader(n, o), t.linkProgram(n), t.getProgramParameter(n, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(n)), window.console.log("Could not initialise shaders")), n
    }, L.PixiShader = function(t) {
        this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
    }, L.PixiShader.prototype.constructor = L.PixiShader, L.PixiShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc || L.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var i in t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
        this.initUniforms(), this.program = e
    }, L.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var o = (t = this.uniforms[i]).type;
            "sampler2D" === o ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === o || "mat3" === o || "mat4" === o ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === o ? t.glFunc = e.uniformMatrix2fv : "mat3" === o ? t.glFunc = e.uniformMatrix3fv : "mat4" === o && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + o], t.glValueLength = "2f" === o || "2i" === o ? 2 : "3f" === o || "3i" === o ? 3 : "4f" === o || "4i" === o ? 4 : 1)
        }
    }, L.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                    o = i.magFilter ? i.magFilter : e.LINEAR,
                    s = i.minFilter ? i.minFilter : e.LINEAR,
                    n = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    r = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    a = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (n = e.REPEAT, r = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        d = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, d, a, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, o), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, r)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, L.PixiShader.prototype.syncUniforms = function() {
        var t;
        this.textureCount = 1;
        var e = this.gl;
        for (var i in this.uniforms) 1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? L.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, L.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, L.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], L.PixiFastShader = function(t) {
        this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
    }, L.PixiFastShader.prototype.constructor = L.PixiFastShader, L.PixiFastShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
    }, L.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, L.StripShader = function(t) {
        this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
    }, L.StripShader.prototype.constructor = L.StripShader, L.StripShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, L.PrimitiveShader = function(t) {
        this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
    }, L.PrimitiveShader.prototype.constructor = L.PrimitiveShader, L.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, L.ComplexPrimitiveShader = function(t) {
        this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
    }, L.ComplexPrimitiveShader.prototype.constructor = L.ComplexPrimitiveShader, L.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, L.glContexts = [], L.instances = [], L.WebGLRenderer = function(t) {
        this.game = t, L.defaultRenderer || (L.defaultRenderer = this), this.type = L.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new L.Point, this.offset = new L.Point, this.shaderManager = new L.WebGLShaderManager, this.spriteBatch = new L.WebGLSpriteBatch, this.maskManager = new L.WebGLMaskManager, this.filterManager = new L.WebGLFilterManager, this.stencilManager = new L.WebGLStencilManager, this.blendModeManager = new L.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, (this.renderSession.renderer = this).renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
    }, L.WebGLRenderer.prototype.constructor = L.WebGLRenderer, L.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (!(this.gl = t)) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = L.WebGLRenderer.glContextId++, L.glContexts[this.glContextId] = t, L.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
    }, L.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, L.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, o) {
        this.renderSession.blendModeManager.setBlendMode(L.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, o), this.spriteBatch.end()
    }, L.WebGLRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
    }, L.WebGLRenderer.prototype.updateTexture = function(t) {
        if (!t.hasLoaded) return !1;
        var e = this.gl;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && L.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), !(t._dirty[e.id] = !1)
    }, L.WebGLRenderer.prototype.destroy = function() {
        L.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, L.CanvasPool.remove(this), L.instances[this.glContextId] = null, L.WebGLRenderer.glContextId--
    }, L.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!L.blendModesWebGL) {
            var e = [],
                i = L.blendModes;
            e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], L.blendModesWebGL = e
        }
    }, L.WebGLRenderer.glContextId = 0, L.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    }, L.WebGLBlendModeManager.prototype.constructor = L.WebGLBlendModeManager, L.WebGLBlendModeManager.prototype.setContext = function(t) {
        this.gl = t
    }, L.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var e = L.blendModesWebGL[this.currentBlendMode];
        return e && this.gl.blendFunc(e[0], e[1]), !0
    }, L.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    }, L.WebGLMaskManager = function() {}, L.WebGLMaskManager.prototype.constructor = L.WebGLMaskManager, L.WebGLMaskManager.prototype.setContext = function(t) {
        this.gl = t
    }, L.WebGLMaskManager.prototype.pushMask = function(t, e) {
        var i = e.gl;
        t.dirty && L.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
    }, L.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    }, L.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    }, L.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0
    }, L.WebGLStencilManager.prototype.setContext = function(t) {
        this.gl = t
    }, L.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var o = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (o.enable(o.STENCIL_TEST), o.clear(o.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var s = this.count;
        o.colorMask(!1, !1, !1, !1), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), 1 === e.mode ? (o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0), this.reverse ? (o.stencilFunc(o.EQUAL, 255 - s, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, s, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? o.stencilFunc(o.EQUAL, 255 - (s + 1), 255) : o.stencilFunc(o.EQUAL, s + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (o.stencilFunc(o.EQUAL, s, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, 255 - s, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, s + 1, 255) : o.stencilFunc(o.EQUAL, 255 - (s + 1), 255)), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP), this.count++
    }, L.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
        this._currentGraphics = t;
        var o, s = this.gl,
            n = i.projection,
            r = i.offset;
        1 === e.mode ? (o = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(o), s.uniform1f(o.flipY, i.flipY), s.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform2f(o.projectionVector, n.x, -n.y), s.uniform2f(o.offsetVector, -r.x, -r.y), s.uniform3fv(o.tintColor, L.hex2rgb(t.tint)), s.uniform3fv(o.color, e.color), s.uniform1f(o.alpha, t.worldAlpha * e.alpha), s.bindBuffer(s.ARRAY_BUFFER, e.buffer), s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, !1, 8, 0)) : (o = i.shaderManager.primitiveShader, i.shaderManager.setShader(o), s.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(o.flipY, i.flipY), s.uniform2f(o.projectionVector, n.x, -n.y), s.uniform2f(o.offsetVector, -r.x, -r.y), s.uniform3fv(o.tintColor, L.hex2rgb(t.tint)), s.uniform1f(o.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, e.buffer), s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(o.colorAttribute, 4, s.FLOAT, !1, 24, 8)), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
    }, L.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var o = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) o.disable(o.STENCIL_TEST);
        else {
            var s = this.count;
            this.bindGraphics(t, e, i), o.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (o.stencilFunc(o.EQUAL, 255 - (s + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, s + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0)) : (this.reverse ? (o.stencilFunc(o.EQUAL, s + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, 255 - (s + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0)), this.reverse ? o.stencilFunc(o.EQUAL, s, 255) : o.stencilFunc(o.EQUAL, 255 - s, 255), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP)
        }
    }, L.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null
    }, L.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    }, L.WebGLShaderManager.prototype.constructor = L.WebGLShaderManager, L.WebGLShaderManager.prototype.setContext = function(t) {
        this.gl = t, this.primitiveShader = new L.PrimitiveShader(t), this.complexPrimitiveShader = new L.ComplexPrimitiveShader(t), this.defaultShader = new L.PixiShader(t), this.fastShader = new L.PixiFastShader(t), this.stripShader = new L.StripShader(t), this.setShader(this.defaultShader)
    }, L.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var o = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? o.enableVertexAttribArray(e) : o.disableVertexAttribArray(e))
    }, L.WebGLShaderManager.prototype.setShader = function(t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    }, L.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
    }, L.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var t = 4 * this.size * 4 * this.vertSize,
            e = 6 * this.size;
        this.vertices = new L.ArrayBuffer(t), this.positions = new L.Float32Array(this.vertices), this.colors = new L.Uint32Array(this.vertices), this.indices = new L.Uint16Array(e);
        for (var i = this.lastIndexCount = 0, o = 0; i < e; i += 6, o += 4) this.indices[i + 0] = o + 0, this.indices[i + 1] = o + 1, this.indices[i + 2] = o + 2, this.indices[i + 3] = o + 0, this.indices[i + 4] = o + 2, this.indices[i + 5] = o + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new L.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    }, L.WebGLSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var e = new L.PixiShader(t);
        e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[t.id] = e
    }, L.WebGLSpriteBatch.prototype.begin = function(t) {
        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
    }, L.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    }, L.WebGLSpriteBatch.prototype.render = function(t, e) {
        var i = t.texture,
            o = t.worldTransform;
        e && (o = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
        var s = i._uvs;
        if (s) {
            var n, r, a, h, l = t.anchor.x,
                d = t.anchor.y;
            if (i.trim) {
                var c = i.trim;
                n = (r = c.x - l * c.width) + i.crop.width, a = (h = c.y - d * c.height) + i.crop.height
            } else n = i.frame.width * (1 - l), r = i.frame.width * -l, a = i.frame.height * (1 - d), h = i.frame.height * -d;
            var u = 4 * this.currentBatchSize * this.vertSize,
                p = i.baseTexture.resolution,
                b = o.a / p,
                m = o.b / p,
                y = o.c / p,
                f = o.d / p,
                x = o.tx,
                g = o.ty,
                _ = this.colors,
                v = this.positions;
            this.renderSession.roundPixels ? (v[u] = b * r + y * h + x | 0, v[u + 1] = f * h + m * r + g | 0, v[u + 5] = b * n + y * h + x | 0, v[u + 6] = f * h + m * n + g | 0, v[u + 10] = b * n + y * a + x | 0, v[u + 11] = f * a + m * n + g | 0, v[u + 15] = b * r + y * a + x | 0, v[u + 16] = f * a + m * r + g | 0) : (v[u] = b * r + y * h + x, v[u + 1] = f * h + m * r + g, v[u + 5] = b * n + y * h + x, v[u + 6] = f * h + m * n + g, v[u + 10] = b * n + y * a + x, v[u + 11] = f * a + m * n + g, v[u + 15] = b * r + y * a + x, v[u + 16] = f * a + m * r + g), v[u + 2] = s.x0, v[u + 3] = s.y0, v[u + 7] = s.x1, v[u + 8] = s.y1, v[u + 12] = s.x2, v[u + 13] = s.y2, v[u + 17] = s.x3, v[u + 18] = s.y3;
            var S = t.tint;
            _[u + 4] = _[u + 9] = _[u + 14] = _[u + 19] = (S >> 16) + (65280 & S) + ((255 & S) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
        }
    }, L.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var e = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new L.TextureUvs);
        var i = t._uvs,
            o = e.baseTexture.width,
            s = e.baseTexture.height;
        t.tilePosition.x %= o * t.tileScaleOffset.x, t.tilePosition.y %= s * t.tileScaleOffset.y;
        var n = t.tilePosition.x / (o * t.tileScaleOffset.x),
            r = t.tilePosition.y / (s * t.tileScaleOffset.y),
            a = t.width / o / (t.tileScale.x * t.tileScaleOffset.x),
            h = t.height / s / (t.tileScale.y * t.tileScaleOffset.y);
        i.x0 = 0 - n, i.y0 = 0 - r, i.x1 = 1 * a - n, i.y1 = 0 - r, i.x2 = 1 * a - n, i.y2 = 1 * h - r, i.x3 = 0 - n, i.y3 = 1 * h - r;
        var l = t.tint,
            d = (l >> 16) + (65280 & l) + ((255 & l) << 16) + (255 * t.worldAlpha << 24),
            c = this.positions,
            u = this.colors,
            p = t.width,
            b = t.height,
            m = t.anchor.x,
            y = t.anchor.y,
            f = p * (1 - m),
            x = p * -m,
            g = b * (1 - y),
            _ = b * -y,
            v = 4 * this.currentBatchSize * this.vertSize,
            S = e.baseTexture.resolution,
            C = t.worldTransform,
            w = C.a / S,
            A = C.b / S,
            P = C.c / S,
            T = C.d / S,
            B = C.tx,
            M = C.ty;
        c[v++] = w * x + P * _ + B, c[v++] = T * _ + A * x + M, c[v++] = i.x0, c[v++] = i.y0, u[v++] = d, c[v++] = w * f + P * _ + B, c[v++] = T * _ + A * f + M, c[v++] = i.x1, c[v++] = i.y1, u[v++] = d, c[v++] = w * f + P * g + B, c[v++] = T * g + A * f + M, c[v++] = i.x2, c[v++] = i.y2, u[v++] = d, c[v++] = w * x + P * g + B, c[v++] = T * g + A * x + M, c[v++] = i.x3, c[v++] = i.y3, u[v++] = d, this.sprites[this.currentBatchSize++] = t
    }, L.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, e, i, o, s = this.gl;
            if (this.dirty) {
                this.dirty = !1, s.activeTexture(s.TEXTURE0), s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[s.id];
                var n = 4 * this.vertSize;
                s.vertexAttribPointer(t.aVertexPosition, 2, s.FLOAT, !1, n, 0), s.vertexAttribPointer(t.aTextureCoord, 2, s.FLOAT, !1, n, 8), s.vertexAttribPointer(t.colorAttribute, 4, s.UNSIGNED_BYTE, !0, n, 16)
            }
            if (this.currentBatchSize > .5 * this.size) s.bufferSubData(s.ARRAY_BUFFER, 0, this.vertices);
            else {
                var r = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                s.bufferSubData(s.ARRAY_BUFFER, 0, r)
            }
            for (var a, h = 0, l = 0, d = null, c = this.renderSession.blendModeManager.currentBlendMode, u = null, p = !1, b = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                e = (a = this.sprites[m]).tilingTexture ? a.tilingTexture.baseTexture : a.texture.baseTexture, p = c !== (i = a.blendMode), b = u !== (o = a.shader || this.defaultShader);
                var f = e.skipRender;
                if (f && 0 < a.children.length && (f = !1), (d !== e && !f || p || b) && (this.renderBatch(d, h, l), l = m, h = 0, d = e, p && (c = i, this.renderSession.blendModeManager.setBlendMode(c)), b)) {
                    (t = (u = o).shaders[s.id]) || ((t = new L.PixiShader(s)).fragmentSrc = u.fragmentSrc, t.uniforms = u.uniforms, t.init(), u.shaders[s.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var x = this.renderSession.projection;
                    s.uniform2f(t.projectionVector, x.x, x.y);
                    var g = this.renderSession.offset;
                    s.uniform2f(t.offsetVector, g.x, g.y)
                }
                h++
            }
            this.renderBatch(d, h, l), this.currentBatchSize = 0
        }
    }, L.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var o = this.gl;
            if (t._dirty[o.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else o.bindTexture(o.TEXTURE_2D, t._glTextures[o.id]);
            o.drawElements(o.TRIANGLES, 6 * e, o.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    }, L.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0
    }, L.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    }, L.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
    }, L.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var e = 4 * this.size * this.vertSize,
            i = 6 * this.maxSize;
        this.vertices = new L.Float32Array(e), this.indices = new L.Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null;
        for (var o = this.lastIndexCount = 0, s = 0; o < i; o += 6, s += 4) this.indices[o + 0] = s + 0, this.indices[o + 1] = s + 1, this.indices[o + 2] = s + 2, this.indices[o + 3] = s + 0, this.indices[o + 4] = s + 2, this.indices[o + 5] = s + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    }, L.WebGLFastSpriteBatch.prototype.constructor = L.WebGLFastSpriteBatch, L.WebGLFastSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    }, L.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
    }, L.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    }, L.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
            i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var o = 0, s = e.length; o < s; o++) this.renderSprite(e[o]);
            this.flush()
        }
    }, L.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
            var e, i, o, s, n, r, a = this.vertices;
            if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                var h = t.texture.trim;
                i = (o = h.x - t.anchor.x * h.width) + t.texture.crop.width, s = (n = h.y - t.anchor.y * h.height) + t.texture.crop.height
            } else i = t.texture.frame.width * (1 - t.anchor.x), o = t.texture.frame.width * -t.anchor.x, s = t.texture.frame.height * (1 - t.anchor.y), n = t.texture.frame.height * -t.anchor.y;
            r = 4 * this.currentBatchSize * this.vertSize, a[r++] = o, a[r++] = n, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x0, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = n, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x1, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x2, a[r++] = e.y2, a[r++] = t.alpha, a[r++] = o, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x3, a[r++] = e.y3, a[r++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
        }
    }, L.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
            else {
                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
            }
            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
        }
    }, L.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    }, L.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
    }, L.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0
    }, L.WebGLFilterManager.prototype.constructor = L.WebGLFilterManager, L.WebGLFilterManager.prototype.setContext = function(t) {
        this.gl = t, this.texturePool = [], this.initShaderBuffers()
    }, L.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    }, L.WebGLFilterManager.prototype.pushFilter = function(t) {
        var e = this.gl,
            i = this.renderSession.projection,
            o = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new L.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
        var s = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var n = this.texturePool.pop();
        n ? n.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : n = new L.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, n.texture);
        var r = t._filterArea,
            a = s.padding;
        r.x -= a, r.y -= a, r.width += 2 * a, r.height += 2 * a, r.x < 0 && (r.x = 0), r.width > this.width && (r.width = this.width), r.y < 0 && (r.y = 0), r.height > this.height && (r.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, n.frameBuffer), e.viewport(0, 0, r.width * this.renderSession.resolution, r.height * this.renderSession.resolution), i.x = r.width / 2, i.y = -r.height / 2, o.x = -r.x, o.y = -r.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = n
    }, L.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
            e = this.filterStack.pop(),
            i = e._filterArea,
            o = e._glFilterTexture,
            s = this.renderSession.projection,
            n = this.renderSession.offset;
        if (1 < e.filterPasses.length) {
            t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var r = o,
                a = this.texturePool.pop();
            a || (a = new L.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), a.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var h = 0; h < e.filterPasses.length - 1; h++) {
                var l = e.filterPasses[h];
                t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, r.texture), this.applyFilterPass(l, i, i.width, i.height);
                var d = r;
                r = a, a = d
            }
            t.enable(t.BLEND), o = r, this.texturePool.push(a)
        }
        var c = e.filterPasses[e.filterPasses.length - 1];
        this.offsetX -= i.x, this.offsetY -= i.y;
        var u = this.width,
            p = this.height,
            b = 0,
            m = 0,
            y = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var f = this.filterStack[this.filterStack.length - 1];
            u = (i = f._filterArea).width, p = i.height, b = i.x, m = i.y, y = f._glFilterTexture.frameBuffer
        }
        s.x = u / 2, s.y = -p / 2, n.x = b, n.y = m;
        var x = (i = e._filterArea).x - b,
            g = i.y - m;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = g + i.height, this.vertexArray[2] = x + i.width, this.vertexArray[3] = g + i.height, this.vertexArray[4] = x, this.vertexArray[5] = g, this.vertexArray[6] = x + i.width, this.vertexArray[7] = g, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, u * this.renderSession.resolution, p * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, 0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(c, i, u, p), this.texturePool.push(o), e._glFilterTexture = null
    }, L.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, o) {
        var s = this.gl,
            n = t.shaders[s.id];
        n || ((n = new L.PixiShader(s)).fragmentSrc = t.fragmentSrc, n.uniforms = t.uniforms, n.init(), t.shaders[s.id] = n), this.renderSession.shaderManager.setShader(n), s.uniform2f(n.projectionVector, i / 2, -o / 2), s.uniform2f(n.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), n.syncUniforms(), s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer), s.vertexAttribPointer(n.aVertexPosition, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, this.uvBuffer), s.vertexAttribPointer(n.aTextureCoord, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, this.colorBuffer), s.vertexAttribPointer(n.colorAttribute, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    }, L.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new L.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new L.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new L.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    }, L.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0;
        for (var e = this.offsetY = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    }, L.FilterTexture = function(t, e, i, o) {
        this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), o = o || L.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, o === L.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, o === L.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i)
    }, L.FilterTexture.prototype.constructor = L.FilterTexture, L.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    }, L.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    }, L.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    }, L.CanvasBuffer = function(t, e) {
        this.width = t, this.height = e, this.canvas = L.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
    }, L.CanvasBuffer.prototype.constructor = L.CanvasBuffer, L.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
    }, L.CanvasBuffer.prototype.resize = function(t, e) {
        this.width = this.canvas.width = t, this.height = this.canvas.height = e
    }, L.CanvasBuffer.prototype.destroy = function() {
        L.CanvasPool.remove(this)
    }, L.CanvasMaskManager = function() {}, L.CanvasMaskManager.prototype.constructor = L.CanvasMaskManager, L.CanvasMaskManager.prototype.pushMask = function(t, e) {
        var i = e.context;
        i.save();
        var o = t.alpha,
            s = t.worldTransform,
            n = e.resolution;
        i.setTransform(s.a * n, s.b * n, s.c * n, s.d * n, s.tx * n, s.ty * n), L.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = o
    }, L.CanvasMaskManager.prototype.popMask = function(t) {
        t.context.restore()
    }, L.CanvasTinter = function() {}, L.CanvasTinter.getTintedTexture = function(t, e) {
        var i = t.tintedTexture || L.CanvasPool.create(this);
        return L.CanvasTinter.tintMethod(t.texture, e, i), i
    }, L.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var o = i.getContext("2d"),
            s = t.crop;
        i.width === s.width && i.height === s.height || (i.width = s.width, i.height = s.height), o.clearRect(0, 0, s.width, s.height), o.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), o.fillRect(0, 0, s.width, s.height), o.globalCompositeOperation = "multiply", o.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height), o.globalCompositeOperation = "destination-atop", o.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height)
    }, L.CanvasTinter.tintWithPerPixel = function(t, e, i) {
        var o = i.getContext("2d"),
            s = t.crop;
        i.width = s.width, i.height = s.height, o.globalCompositeOperation = "copy", o.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height);
        for (var n = L.hex2rgb(e), r = n[0], a = n[1], h = n[2], l = o.getImageData(0, 0, s.width, s.height), d = l.data, c = 0; c < d.length; c += 4)
            if (d[c + 0] *= r, d[c + 1] *= a, d[c + 2] *= h, !L.CanvasTinter.canHandleAlpha) {
                var u = d[c + 3];
                d[c + 0] /= 255 / u, d[c + 1] /= 255 / u, d[c + 2] /= 255 / u
            }
        o.putImageData(l, 0, 0)
    }, L.CanvasTinter.checkInverseAlpha = function() {
        var t = new L.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
        var e = t.context.getImageData(0, 0, 1, 1);
        if (null === e) return !1;
        t.context.putImageData(e, 1, 0);
        var i = t.context.getImageData(1, 0, 1, 1);
        return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
    }, L.CanvasTinter.canHandleAlpha = L.CanvasTinter.checkInverseAlpha(), L.CanvasTinter.canUseMultiply = L.canUseNewCanvasBlendModes(), L.CanvasTinter.tintMethod = L.CanvasTinter.canUseMultiply ? L.CanvasTinter.tintWithMultiply : L.CanvasTinter.tintWithPerPixel, L.CanvasRenderer = function(t) {
        this.game = t, L.defaultRenderer || (L.defaultRenderer = this), this.type = L.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.count = 0, this.maskManager = new L.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(this.width, this.height)
    }, L.CanvasRenderer.prototype.constructor = L.CanvasRenderer, L.CanvasRenderer.prototype.render = function(t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
    }, L.CanvasRenderer.prototype.destroy = function(t) {
        void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
    }, L.CanvasRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === L.scaleModes.LINEAR)
    }, L.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
        this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
    }, L.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!L.blendModesCanvas) {
            var t = [],
                e = L.blendModes,
                i = L.canUseNewCanvasBlendModes();
            t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", L.blendModesCanvas = t
        }
    }, L.BaseTexture = function(t, e) {
        this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = e || L.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    }, L.BaseTexture.prototype.constructor = L.BaseTexture, L.BaseTexture.prototype.forceLoaded = function(t, e) {
        this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
    }, L.BaseTexture.prototype.destroy = function() {
        this.source && L.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
    }, L.BaseTexture.prototype.updateSourceImage = function(t) {}, L.BaseTexture.prototype.dirty = function() {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    }, L.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; 0 <= t; t--) {
            var e = this._glTextures[t],
                i = L.glContexts[t];
            i && e && i.deleteTexture(e)
        }
        this._glTextures.length = 0, this.dirty()
    }, L.BaseTexture.fromCanvas = function(t, e) {
        return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new L.BaseTexture(t, e)
    }, L.TextureSilentFail = !1, L.Texture = function(t, e, i, o) {
        this.noFrame = !1, e || (this.noFrame = !0, e = new L.Rectangle(0, 0, 1, 1)), t instanceof L.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = o, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new L.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (e = new L.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
    }, L.Texture.prototype.constructor = L.Texture, L.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new L.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    }, L.Texture.prototype.destroy = function(t) {
        t && this.baseTexture.destroy(), this.valid = !1
    }, L.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else {
            if (!L.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    }, L.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new L.TextureUvs);
        var t = this.crop,
            e = this.baseTexture.width,
            i = this.baseTexture.height;
        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
    }, L.Texture.fromCanvas = function(t, e) {
        var i = L.BaseTexture.fromCanvas(t, e);
        return new L.Texture(i)
    }, L.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
    }, L.RenderTexture = function(t, e, i, o, s) {
        if (this.width = t || 100, this.height = e || 100, this.resolution = s || 1, this.frame = new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new L.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = o || L.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, L.Texture.call(this, this.baseTexture, new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = i || L.defaultRenderer, this.renderer.type === L.WEBGL_RENDERER) {
            var n = this.renderer.gl;
            this.baseTexture._dirty[n.id] = !1, this.textureBuffer = new L.FilterTexture(n, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[n.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new L.Point(.5 * this.width, .5 * -this.height)
        } else this.render = this.renderCanvas, this.textureBuffer = new L.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
    }, L.RenderTexture.prototype = Object.create(L.Texture.prototype), L.RenderTexture.prototype.constructor = L.RenderTexture, L.RenderTexture.prototype.resize = function(t, e, i) {
        t === this.width && e === this.height || (this.valid = 0 < t && 0 < e, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === L.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
    }, L.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === L.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
    }, L.RenderTexture.prototype.renderWebGL = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var o = t.worldTransform;
            o.identity(), o.translate(0, 2 * this.projection.y), e && o.append(e), o.scale(1, -1);
            for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
            var n = this.renderer.gl;
            n.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), n.bindFramebuffer(n.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
        }
    }, L.RenderTexture.prototype.renderCanvas = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var o = t.worldTransform;
            o.identity(), e && o.append(e);
            for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
            i && this.textureBuffer.clear();
            var n = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = n
        }
    }, L.RenderTexture.prototype.getImage = function() {
        var t = new Image;
        return t.src = this.getBase64(), t
    }, L.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL()
    }, L.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type !== L.WEBGL_RENDERER) return this.textureBuffer.canvas;
        var t = this.renderer.gl,
            e = this.textureBuffer.width,
            i = this.textureBuffer.height,
            o = new Uint8Array(4 * e * i);
        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, o), t.bindFramebuffer(t.FRAMEBUFFER, null);
        var s = new L.CanvasBuffer(e, i),
            n = s.context.getImageData(0, 0, e, i);
        return n.data.set(o), s.context.putImageData(n, 0, 0), s.canvas
    }, L.AbstractFilter = function(t, e) {
        this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
    }, L.AbstractFilter.prototype.constructor = L.AbstractFilter, L.AbstractFilter.prototype.syncUniforms = function() {
        for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
    }, L.Strip = function(t) {
        L.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new L.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new L.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new L.Float32Array([1, 1, 1, 1]), this.indices = new L.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = L.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = L.Strip.DrawModes.TRIANGLE_STRIP
    }, L.Strip.prototype = Object.create(L.DisplayObjectContainer.prototype), L.Strip.prototype.constructor = L.Strip, L.Strip.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
    }, L.Strip.prototype._initWebGL = function(t) {
        var e = t.gl;
        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
    }, L.Strip.prototype._renderStrip = function(t) {
        var e = t.gl,
            i = t.projection,
            o = t.offset,
            s = t.shaderManager.stripShader,
            n = this.drawMode === L.Strip.DrawModes.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
        t.blendModeManager.setBlendMode(this.blendMode), e.uniformMatrix3fv(s.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(s.projectionVector, i.x, -i.y), e.uniform2f(s.offsetVector, -o.x, -o.y), e.uniform1f(s.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW), e.vertexAttribPointer(s.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(s.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices), e.vertexAttribPointer(s.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(s.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(n, this.indices.length, e.UNSIGNED_SHORT, 0)
    }, L.Strip.prototype._renderCanvas = function(t) {
        var e = t.context,
            i = this.worldTransform,
            o = i.tx * t.resolution + t.shakeX,
            s = i.ty * t.resolution + t.shakeY;
        t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | o, 0 | s) : e.setTransform(i.a, i.b, i.c, i.d, o, s), this.drawMode === L.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
    }, L.Strip.prototype._renderCanvasTriangleStrip = function(t) {
        var e = this.vertices,
            i = this.uvs,
            o = e.length / 2;
        this.count++;
        for (var s = 0; s < o - 2; s++) {
            var n = 2 * s;
            this._renderCanvasDrawTriangle(t, e, i, n, n + 2, n + 4)
        }
    }, L.Strip.prototype._renderCanvasTriangles = function(t) {
        var e = this.vertices,
            i = this.uvs,
            o = this.indices,
            s = o.length;
        this.count++;
        for (var n = 0; n < s; n += 3) {
            var r = 2 * o[n],
                a = 2 * o[n + 1],
                h = 2 * o[n + 2];
            this._renderCanvasDrawTriangle(t, e, i, r, a, h)
        }
    }, L.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, o, s, n) {
        var r = this.texture.baseTexture.source,
            a = this.texture.width,
            h = this.texture.height,
            l = e[o],
            d = e[s],
            c = e[n],
            u = e[o + 1],
            p = e[s + 1],
            b = e[n + 1],
            m = i[o] * a,
            y = i[s] * a,
            f = i[n] * a,
            x = i[o + 1] * h,
            g = i[s + 1] * h,
            _ = i[n + 1] * h;
        if (0 < this.canvasPadding) {
            var v = this.canvasPadding / this.worldTransform.a,
                S = this.canvasPadding / this.worldTransform.d,
                C = (l + d + c) / 3,
                w = (u + p + b) / 3,
                A = l - C,
                P = u - w,
                T = Math.sqrt(A * A + P * P);
            l = C + A / T * (T + v), u = w + P / T * (T + S), P = p - w, d = C + (A = d - C) / (T = Math.sqrt(A * A + P * P)) * (T + v), p = w + P / T * (T + S), P = b - w, c = C + (A = c - C) / (T = Math.sqrt(A * A + P * P)) * (T + v), b = w + P / T * (T + S)
        }
        t.save(), t.beginPath(), t.moveTo(l, u), t.lineTo(d, p), t.lineTo(c, b), t.closePath(), t.clip();
        var B = m * g + x * f + y * _ - g * f - x * y - m * _,
            M = l * g + x * c + d * _ - g * c - x * d - l * _,
            E = m * d + l * f + y * c - d * f - l * y - m * c,
            I = m * g * c + x * d * f + l * y * _ - l * g * f - x * y * c - m * d * _,
            V = u * g + x * b + p * _ - g * b - x * p - u * _,
            R = m * p + u * f + y * b - p * f - u * y - m * b,
            L = m * g * b + x * p * f + u * y * _ - u * g * f - x * y * b - m * p * _;
        t.transform(M / B, V / B, E / B, R / B, I / B, L / B), t.drawImage(r, 0, 0), t.restore()
    }, L.Strip.prototype.renderStripFlat = function(t) {
        var e = this.context,
            i = t.vertices,
            o = i.length / 2;
        this.count++, e.beginPath();
        for (var s = 1; s < o - 2; s++) {
            var n = 2 * s,
                r = i[n],
                a = i[n + 2],
                h = i[n + 4],
                l = i[n + 1],
                d = i[n + 3],
                c = i[n + 5];
            e.moveTo(r, l), e.lineTo(a, d), e.lineTo(h, c)
        }
        e.fillStyle = "#FF0000", e.fill(), e.closePath()
    }, L.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0
    }, L.Strip.prototype.getBounds = function(t) {
        for (var e = t || this.worldTransform, i = e.a, o = e.b, s = e.c, n = e.d, r = e.tx, a = e.ty, h = -1 / 0, l = -1 / 0, d = 1 / 0, c = 1 / 0, u = this.vertices, p = 0, b = u.length; p < b; p += 2) {
            var m = u[p],
                y = u[p + 1],
                f = i * m + s * y + r,
                x = n * y + o * m + a;
            d = f < d ? f : d, c = x < c ? x : c, h = h < f ? f : h, l = l < x ? x : l
        }
        if (d === -1 / 0 || l === 1 / 0) return L.EmptyRectangle;
        var g = this._bounds;
        return g.x = d, g.width = h - d, g.y = c, g.height = l - c, this._currentBounds = g
    }, L.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    }, L.Rope = function(t, e) {
        L.Strip.call(this, t), this.points = e, this.vertices = new L.Float32Array(4 * e.length), this.uvs = new L.Float32Array(4 * e.length), this.colors = new L.Float32Array(2 * e.length), this.indices = new L.Uint16Array(2 * e.length), this.refresh()
    }, L.Rope.prototype = Object.create(L.Strip.prototype), L.Rope.prototype.constructor = L.Rope, L.Rope.prototype.refresh = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e = this.uvs,
                i = (t[0], this.indices),
                o = this.colors;
            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, o[0] = 1, o[1] = 1, i[0] = 0, i[1] = 1;
            for (var s, n, r, a = t.length, h = 1; h < a; h++) s = t[h], r = h / (a - 1), e[(n = 4 * h) + 3] = (e[n] = r, e[n + 1] = 0, e[n + 2] = r, 1), o[n = 2 * h] = 1, o[n + 1] = 1, i[n = 2 * h] = n, i[n + 1] = n + 1, s
        }
    }, L.Rope.prototype.updateTransform = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e, i = t[0],
                o = {
                    x: 0,
                    y: 0
                };
            this.count -= .2;
            for (var s, n, r, a, h = this.vertices, l = t.length, d = 0; d < l; d++) s = t[d], n = 4 * d, e = d < t.length - 1 ? t[d + 1] : s, o.y = -(e.x - i.x), o.x = e.y - i.y, 1 < 10 * (1 - d / (l - 1)) && 1, r = Math.sqrt(o.x * o.x + o.y * o.y), a = this.texture.height / 2, o.x /= r, o.y /= r, o.x *= a, o.y *= a, h[n] = s.x + o.x, h[n + 1] = s.y + o.y, h[n + 2] = s.x - o.x, h[n + 3] = s.y - o.y, i = s;
            L.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    }, L.Rope.prototype.setTexture = function(t) {
        this.texture = t
    }, L.TilingSprite = function(t, e, i) {
        L.Sprite.call(this, t), this._width = e || 128, this._height = i || 128, this.tileScale = new L.Point(1, 1), this.tileScaleOffset = new L.Point(1, 1), this.tilePosition = new L.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = L.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
    }, L.TilingSprite.prototype = Object.create(L.Sprite.prototype), L.TilingSprite.prototype.constructor = L.TilingSprite, L.TilingSprite.prototype.setTexture = function(t) {
        this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
    }, L.TilingSprite.prototype._renderWebGL = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
            }
            t.spriteBatch.renderTilingSprite(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
        }
    }, L.TilingSprite.prototype._renderCanvas = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var e = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
            var i = this.worldTransform,
                o = t.resolution,
                s = i.tx * o + t.shakeX,
                n = i.ty * o + t.shakeY;
            if (e.setTransform(i.a * o, i.b * o, i.c * o, i.d * o, s, n), this.refreshTexture) {
                if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var r = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = L.blendModesCanvas[t.currentBlendMode]);
            var a = this.tilePosition,
                h = this.tileScale;
            a.x %= this.tilingTexture.baseTexture.width, a.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern;
            s = -a.x, n = -a.y;
            var l = this._width / h.x,
                d = this._height / h.y;
            t.roundPixels && (s |= 0, n |= 0, l |= 0, d |= 0), e.fillRect(s, n, l, d), e.scale(1 / h.x, 1 / h.y), e.translate(-a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
            for (var c = 0; c < this.children.length; c++) this.children[c]._renderCanvas(t);
            r !== this.blendMode && (t.currentBlendMode = r, e.globalCompositeOperation = L.blendModesCanvas[r])
        }
    }, L.TilingSprite.prototype.onTextureUpdate = function() {}, L.TilingSprite.prototype.generateTilingTexture = function(t, e) {
        if (this.texture.baseTexture.hasLoaded) {
            var i = this.texture,
                o = i.frame,
                s = this._frame.sourceSizeW || this._frame.width,
                n = this._frame.sourceSizeH || this._frame.height,
                r = 0,
                a = 0;
            this._frame.trimmed && (r = this._frame.spriteSourceSizeX, a = this._frame.spriteSourceSizeY), t && (s = L.getNextPowerOfTwo(s), n = L.getNextPowerOfTwo(n)), this.canvasBuffer ? (this.canvasBuffer.resize(s, n), this.tilingTexture.baseTexture.width = s, this.tilingTexture.baseTexture.height = n) : (this.canvasBuffer = new L.CanvasBuffer(s, n), this.tilingTexture = L.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0), this.tilingTexture.needsUpdate = !0, this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, s, n));
            var h = i.crop.width,
                l = i.crop.height;
            h === s && l === n || (h = s, l = n), this.canvasBuffer.context.drawImage(i.baseTexture.source, i.crop.x, i.crop.y, i.crop.width, i.crop.height, r, a, h, l), this.tileScaleOffset.x = o.width / s, this.tileScaleOffset.y = o.height / n, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
        }
    }, L.TilingSprite.prototype.getBounds = function() {
        var t = this._width,
            e = this._height,
            i = t * (1 - this.anchor.x),
            o = t * -this.anchor.x,
            s = e * (1 - this.anchor.y),
            n = e * -this.anchor.y,
            r = this.worldTransform,
            a = r.a,
            h = r.b,
            l = r.c,
            d = r.d,
            c = r.tx,
            u = r.ty,
            p = a * o + l * n + c,
            b = d * n + h * o + u,
            m = a * i + l * n + c,
            y = d * n + h * i + u,
            f = a * i + l * s + c,
            x = d * s + h * i + u,
            g = a * o + l * s + c,
            _ = d * s + h * o + u,
            v = -1 / 0,
            S = -1 / 0,
            C = 1 / 0,
            w = 1 / 0;
        C = g < (C = f < (C = m < (C = p < C ? p : C) ? m : C) ? f : C) ? g : C, w = _ < (w = x < (w = y < (w = b < w ? b : w) ? y : w) ? x : w) ? _ : w, v = (v = (v = (v = v < p ? p : v) < m ? m : v) < f ? f : v) < g ? g : v, S = (S = (S = (S = S < b ? b : S) < y ? y : S) < x ? x : S) < _ ? _ : S;
        var A = this._bounds;
        return A.x = C, A.width = v - C, A.y = w, A.height = S - w, this._currentBounds = A
    }, L.TilingSprite.prototype.destroy = function() {
        L.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
    }, Object.defineProperty(L.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(t) {
            this._width = t
        }
    }), Object.defineProperty(L.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(t) {
            this._height = t
        }
    }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = L), exports.PIXI = L) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = L) : t.PIXI = L, L
}.call(this),
    function() {
        var n, t = this,
            U = U || {
                VERSION: "2.6.13",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {}
            };
        if (Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = (n = Array.prototype.slice, function(e) {
                var i = this,
                    o = n.call(arguments, 1);
                if ("function" != typeof i) throw new TypeError;

                function s() {
                    var t = o.concat(n.call(arguments));
                    i.apply(this instanceof s ? this : e, t)
                }
                return s.prototype = function t(e) {
                    if (e && (t.prototype = e), !(this instanceof t)) return new t
                }(i.prototype), s
            })), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (null == this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var o = 2 <= arguments.length ? arguments[1] : void 0, s = 0; s < i; s++) s in e && t.call(o, e[s], s, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var e = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for (var e = 0; e < this.length; e++) this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for (e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            e("Uint32Array"), e("Int16Array")
        }

        function o(t, e) {
            this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
        }
        for (var i in window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), /firefox/i.test(navigator.userAgent) && (window.oldGetComputedStyle = window.getComputedStyle, window.getComputedStyle = function(t, e) {
                var i = window.oldGetComputedStyle(t, e);
                return null === i ? {
                    getPropertyValue: function() {}
                } : i
            }), U.Utils = {
                reverseString: function(t) {
                    return t.split("").reverse().join("")
                },
                getProperty: function(t, e) {
                    for (var i = e.split("."), o = i.pop(), s = i.length, n = 1, r = i[0]; n < s && (t = t[r]);) r = i[n], n++;
                    return t ? t[o] : null
                },
                setProperty: function(t, e, i) {
                    for (var o = e.split("."), s = o.pop(), n = o.length, r = 1, a = o[0]; r < n && (t = t[a]);) a = o[r], r++;
                    return t && (t[s] = i), t
                },
                chanceRoll: function(t) {
                    return void 0 === t && (t = 50), 0 < t && 100 * Math.random() <= t
                },
                randomChoice: function(t, e) {
                    return Math.random() < .5 ? t : e
                },
                parseDimension: function(t, e) {
                    var i = 0;
                    return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, 0 === e ? window.innerWidth * i : window.innerHeight * i) : parseInt(t, 10) : t
                },
                pad: function(t, e, i, o) {
                    if (void 0 === e) e = 0;
                    if (void 0 === i) i = " ";
                    if (void 0 === o) o = 3;
                    var s = 0;
                    if (e + 1 >= (t = t.toString()).length) switch (o) {
                        case 1:
                            t = new Array(e + 1 - t.length).join(i) + t;
                            break;
                        case 3:
                            var n = Math.ceil((s = e - t.length) / 2);
                            t = new Array(s - n + 1).join(i) + t + new Array(n + 1).join(i);
                            break;
                        default:
                            t += new Array(e + 1 - t.length).join(i)
                    }
                    return t
                },
                isPlainObject: function(t) {
                    if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                    try {
                        if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                    } catch (t) {
                        return !1
                    }
                    return !0
                },
                extend: function() {
                    var t, e, i, o, s, n, r = arguments[0] || {},
                        a = 1,
                        h = arguments.length,
                        l = !1;
                    for ("boolean" == typeof r && (l = r, r = arguments[1] || {}, a = 2), h === a && (r = this, --a); a < h; a++)
                        if (null != (t = arguments[a]))
                            for (e in t) i = r[e], r !== (o = t[e]) && (l && o && (U.Utils.isPlainObject(o) || (s = Array.isArray(o))) ? (n = s ? (s = !1, i && Array.isArray(i) ? i : []) : i && U.Utils.isPlainObject(i) ? i : {}, r[e] = U.Utils.extend(l, n, o)) : void 0 !== o && (r[e] = o));
                    return r
                },
                mixinPrototype: function(t, e, i) {
                    void 0 === i && (i = !1);
                    for (var o = Object.keys(e), s = 0; s < o.length; s++) {
                        var n = o[s],
                            r = e[n];
                        !i && n in t || (!r || "function" != typeof r.get && "function" != typeof r.set ? t[n] = r : "function" == typeof r.clone ? t[n] = r.clone() : Object.defineProperty(t, n, r))
                    }
                },
                mixin: function(t, e) {
                    if (!t || "object" != typeof t) return e;
                    for (var i in t) {
                        var o = t[i];
                        if (!o.childNodes && !o.cloneNode) {
                            var s = typeof t[i];
                            t[i] && "object" === s ? typeof e[i] === s ? e[i] = U.Utils.mixin(t[i], e[i]) : e[i] = U.Utils.mixin(t[i], new o.constructor) : e[i] = t[i]
                        }
                    }
                    return e
                }
            }, U.Circle = function(t, e, i) {
                t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, (this._radius = 0) < i && (this._radius = .5 * i), this.type = U.CIRCLE
            }, U.Circle.prototype = {
                circumference: function() {
                    return Math.PI * this._radius * 2
                },
                random: function(t) {
                    void 0 === t && (t = new U.Point);
                    var e = 2 * Math.PI * Math.random(),
                        i = Math.random() + Math.random(),
                        o = 1 < i ? 2 - i : i,
                        s = o * Math.cos(e),
                        n = o * Math.sin(e);
                    return t.x = this.x + s * this.radius, t.y = this.y + n * this.radius, t
                },
                getBounds: function() {
                    return new U.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                },
                setTo: function(t, e, i) {
                    return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.diameter)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                },
                distance: function(t, e) {
                    var i = U.Math.distance(this.x, this.y, t.x, t.y);
                    return e ? Math.round(i) : i
                },
                clone: function(t) {
                    return null == t ? t = new U.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                },
                contains: function(t, e) {
                    return U.Circle.contains(this, t, e)
                },
                circumferencePoint: function(t, e, i) {
                    return U.Circle.circumferencePoint(this, t, e, i)
                },
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                toString: function() {
                    return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                }
            }, U.Circle.prototype.constructor = U.Circle, Object.defineProperty(U.Circle.prototype, "diameter", {
                get: function() {
                    return this._diameter
                },
                set: function(t) {
                    0 < t && (this._diameter = t, this._radius = .5 * t)
                }
            }), Object.defineProperty(U.Circle.prototype, "radius", {
                get: function() {
                    return this._radius
                },
                set: function(t) {
                    0 < t && (this._radius = t, this._diameter = 2 * t)
                }
            }), Object.defineProperty(U.Circle.prototype, "left", {
                get: function() {
                    return this.x - this._radius
                },
                set: function(t) {
                    t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                }
            }), Object.defineProperty(U.Circle.prototype, "right", {
                get: function() {
                    return this.x + this._radius
                },
                set: function(t) {
                    t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                }
            }), Object.defineProperty(U.Circle.prototype, "top", {
                get: function() {
                    return this.y - this._radius
                },
                set: function(t) {
                    t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                }
            }), Object.defineProperty(U.Circle.prototype, "bottom", {
                get: function() {
                    return this.y + this._radius
                },
                set: function(t) {
                    t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                }
            }), Object.defineProperty(U.Circle.prototype, "area", {
                get: function() {
                    return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
                }
            }), Object.defineProperty(U.Circle.prototype, "empty", {
                get: function() {
                    return 0 === this._diameter
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0)
                }
            }), U.Circle.contains = function(t, e, i) {
                return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
            }, U.Circle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.diameter === e.diameter
            }, U.Circle.intersects = function(t, e) {
                return U.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
            }, U.Circle.circumferencePoint = function(t, e, i, o) {
                return void 0 === i && (i = !1), void 0 === o && (o = new U.Point), !0 === i && (e = U.Math.degToRad(e)), o.x = t.x + t.radius * Math.cos(e), o.y = t.y + t.radius * Math.sin(e), o
            }, U.Circle.intersectsRectangle = function(t, e) {
                var i = Math.abs(t.x - e.x - e.halfWidth);
                if (e.halfWidth + t.radius < i) return !1;
                var o = Math.abs(t.y - e.y - e.halfHeight);
                if (e.halfHeight + t.radius < o) return !1;
                if (i <= e.halfWidth || o <= e.halfHeight) return !0;
                var s = i - e.halfWidth,
                    n = o - e.halfHeight;
                return s * s + n * n <= t.radius * t.radius
            }, PIXI.Circle = U.Circle, U.Ellipse = function(t, e, i, o) {
                t = t || 0, e = e || 0, i = i || 0, o = o || 0, this.x = t, this.y = e, this.width = i, this.height = o, this.type = U.ELLIPSE
            }, U.Ellipse.prototype = {
                setTo: function(t, e, i, o) {
                    return this.x = t, this.y = e, this.width = i, this.height = o, this
                },
                getBounds: function() {
                    return new U.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                clone: function(t) {
                    return null == t ? t = new U.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                },
                contains: function(t, e) {
                    return U.Ellipse.contains(this, t, e)
                },
                random: function(t) {
                    void 0 === t && (t = new U.Point);
                    var e = Math.random() * Math.PI * 2,
                        i = Math.random();
                    return t.x = Math.sqrt(i) * Math.cos(e), t.y = Math.sqrt(i) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                },
                toString: function() {
                    return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                }
            }, U.Ellipse.prototype.constructor = U.Ellipse, Object.defineProperty(U.Ellipse.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            }), Object.defineProperty(U.Ellipse.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t < this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(U.Ellipse.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }), Object.defineProperty(U.Ellipse.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t < this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(U.Ellipse.prototype, "empty", {
                get: function() {
                    return 0 === this.width || 0 === this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), U.Ellipse.contains = function(t, e, i) {
                if (t.width <= 0 || t.height <= 0) return !1;
                var o = (e - t.x) / t.width - .5,
                    s = (i - t.y) / t.height - .5;
                return (o *= o) + (s *= s) < .25
            }, PIXI.Ellipse = U.Ellipse, U.Line = function(t, e, i, o) {
                t = t || 0, e = e || 0, i = i || 0, o = o || 0, this.start = new U.Point(t, e), this.end = new U.Point(i, o), this.type = U.LINE
            }, U.Line.prototype = {
                setTo: function(t, e, i, o) {
                    return this.start.setTo(t, e), this.end.setTo(i, o), this
                },
                fromSprite: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
                },
                fromAngle: function(t, e, i, o) {
                    return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * o, e + Math.sin(i) * o), this
                },
                rotate: function(t, e) {
                    var i = (this.start.x + this.end.x) / 2,
                        o = (this.start.y + this.end.y) / 2;
                    return this.start.rotate(i, o, t, e), this.end.rotate(i, o, t, e), this
                },
                rotateAround: function(t, e, i, o) {
                    return this.start.rotate(t, e, i, o), this.end.rotate(t, e, i, o), this
                },
                intersects: function(t, e, i) {
                    return U.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
                },
                reflect: function(t) {
                    return U.Line.reflect(this, t)
                },
                midPoint: function(t) {
                    return void 0 === t && (t = new U.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                },
                centerOn: function(t, e) {
                    var i = t - (this.start.x + this.end.x) / 2,
                        o = e - (this.start.y + this.end.y) / 2;
                    this.start.add(i, o), this.end.add(i, o)
                },
                pointOnLine: function(t, e) {
                    return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
                },
                pointOnSegment: function(t, e) {
                    var i = Math.min(this.start.x, this.end.x),
                        o = Math.max(this.start.x, this.end.x),
                        s = Math.min(this.start.y, this.end.y),
                        n = Math.max(this.start.y, this.end.y);
                    return this.pointOnLine(t, e) && i <= t && t <= o && s <= e && e <= n
                },
                random: function(t) {
                    void 0 === t && (t = new U.Point);
                    var e = Math.random();
                    return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                },
                coordinatesOnLine: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = []);
                    var i = Math.round(this.start.x),
                        o = Math.round(this.start.y),
                        s = Math.round(this.end.x),
                        n = Math.round(this.end.y),
                        r = Math.abs(s - i),
                        a = Math.abs(n - o),
                        h = i < s ? 1 : -1,
                        l = o < n ? 1 : -1,
                        d = r - a;
                    e.push([i, o]);
                    for (var c = 1; i !== s || o !== n;) {
                        var u = d << 1; - a < u && (d -= a, i += h), u < r && (d += r, o += l), c % t == 0 && e.push([i, o]), c++
                    }
                    return e
                },
                clone: function(t) {
                    return null == t ? t = new U.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                }
            }, Object.defineProperty(U.Line.prototype, "length", {
                get: function() {
                    return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                }
            }), Object.defineProperty(U.Line.prototype, "angle", {
                get: function() {
                    return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                }
            }), Object.defineProperty(U.Line.prototype, "slope", {
                get: function() {
                    return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                }
            }), Object.defineProperty(U.Line.prototype, "perpSlope", {
                get: function() {
                    return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                }
            }), Object.defineProperty(U.Line.prototype, "x", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(U.Line.prototype, "y", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(U.Line.prototype, "left", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(U.Line.prototype, "right", {
                get: function() {
                    return Math.max(this.start.x, this.end.x)
                }
            }), Object.defineProperty(U.Line.prototype, "top", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(U.Line.prototype, "bottom", {
                get: function() {
                    return Math.max(this.start.y, this.end.y)
                }
            }), Object.defineProperty(U.Line.prototype, "width", {
                get: function() {
                    return Math.abs(this.start.x - this.end.x)
                }
            }), Object.defineProperty(U.Line.prototype, "height", {
                get: function() {
                    return Math.abs(this.start.y - this.end.y)
                }
            }), Object.defineProperty(U.Line.prototype, "normalX", {
                get: function() {
                    return Math.cos(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(U.Line.prototype, "normalY", {
                get: function() {
                    return Math.sin(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(U.Line.prototype, "normalAngle", {
                get: function() {
                    return U.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                }
            }), U.Line.intersectsPoints = function(t, e, i, o, s, n) {
                void 0 === s && (s = !0), void 0 === n && (n = new U.Point);
                var r = e.y - t.y,
                    a = o.y - i.y,
                    h = t.x - e.x,
                    l = i.x - o.x,
                    d = e.x * t.y - t.x * e.y,
                    c = o.x * i.y - i.x * o.y,
                    u = r * l - a * h;
                if (0 === u) return null;
                if (n.x = (h * c - l * d) / u, n.y = (a * d - r * c) / u, s) {
                    var p = (o.y - i.y) * (e.x - t.x) - (o.x - i.x) * (e.y - t.y),
                        b = ((o.x - i.x) * (t.y - i.y) - (o.y - i.y) * (t.x - i.x)) / p,
                        m = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / p;
                    return 0 <= b && b <= 1 && 0 <= m && m <= 1 ? n : null
                }
                return n
            }, U.Line.intersects = function(t, e, i, o) {
                return U.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, o)
            }, U.Line.intersectsRectangle = function(t, e) {
                if (!U.Rectangle.intersects(t, e)) return !1;
                var i = t.start.x,
                    o = t.start.y,
                    s = t.end.x,
                    n = t.end.y,
                    r = e.x,
                    a = e.y,
                    h = e.right,
                    l = e.bottom,
                    d = 0;
                if (r <= i && i <= h && a <= o && o <= l || r <= s && s <= h && a <= n && n <= l) return !0;
                if (i < r && r <= s) {
                    if (a < (d = o + (n - o) * (r - i) / (s - i)) && d <= l) return !0
                } else if (h < i && s <= h && a <= (d = o + (n - o) * (h - i) / (s - i)) && d <= l) return !0;
                if (o < a && a <= n) {
                    if (r <= (d = i + (s - i) * (a - o) / (n - o)) && d <= h) return !0
                } else if (l < o && n <= l && r <= (d = i + (s - i) * (l - o) / (n - o)) && d <= h) return !0;
                return !1
            }, U.Line.reflect = function(t, e) {
                return 2 * e.normalAngle - 3.141592653589793 - t.angle
            }, U.Matrix = function(t, e, i, o, s, n) {
                null == t && (t = 1), null == e && (e = 0), null == i && (i = 0), null == o && (o = 1), null == s && (s = 0), null == n && (n = 0), this.a = t, this.b = e, this.c = i, this.d = o, this.tx = s, this.ty = n, this.type = U.MATRIX
            }, U.Matrix.prototype = {
                fromArray: function(t) {
                    return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                },
                setTo: function(t, e, i, o, s, n) {
                    return this.a = t, this.b = e, this.c = i, this.d = o, this.tx = s, this.ty = n, this
                },
                clone: function(t) {
                    return null == t ? t = new U.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                },
                copyTo: function(t) {
                    return t.copyFrom(this), t
                },
                copyFrom: function(t) {
                    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                },
                toArray: function(t, e) {
                    return void 0 === e && (e = new PIXI.Float32Array(9)), e[8] = (e[7] = t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, this.ty) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0), 1), e
                },
                apply: function(t, e) {
                    return void 0 === e && (e = new U.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                },
                applyInverse: function(t, e) {
                    void 0 === e && (e = new U.Point);
                    var i = 1 / (this.a * this.d + this.c * -this.b),
                        o = t.x,
                        s = t.y;
                    return e.x = this.d * i * o + -this.c * i * s + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * s + -this.b * i * o + (-this.ty * this.a + this.tx * this.b) * i, e
                },
                translate: function(t, e) {
                    return this.tx += t, this.ty += e, this
                },
                scale: function(t, e) {
                    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        o = this.a,
                        s = this.c,
                        n = this.tx;
                    return this.a = o * e - this.b * i, this.b = o * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = n * e - this.ty * i, this.ty = n * i + this.ty * e, this
                },
                append: function(t) {
                    var e = this.a,
                        i = this.b,
                        o = this.c,
                        s = this.d;
                    return this.a = t.a * e + t.b * o, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * o, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * o + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this
                },
                identity: function() {
                    return this.setTo(1, 0, 0, 1, 0, 0)
                }
            }, U.identityMatrix = new U.Matrix, PIXI.Matrix = U.Matrix, PIXI.identityMatrix = U.identityMatrix, U.Point = function(t, e) {
                t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = U.POINT
            }, U.Point.prototype = {
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y)
                },
                invert: function() {
                    return this.setTo(this.y, this.x)
                },
                setTo: function(t, e) {
                    return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                },
                set: function(t, e) {
                    return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                },
                add: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                subtract: function(t, e) {
                    return this.x -= t, this.y -= e, this
                },
                multiply: function(t, e) {
                    return this.x *= t, this.y *= e, this
                },
                divide: function(t, e) {
                    return this.x /= t, this.y /= e, this
                },
                clampX: function(t, e) {
                    return this.x = U.Math.clamp(this.x, t, e), this
                },
                clampY: function(t, e) {
                    return this.y = U.Math.clamp(this.y, t, e), this
                },
                clamp: function(t, e) {
                    return this.x = U.Math.clamp(this.x, t, e), this.y = U.Math.clamp(this.y, t, e), this
                },
                clone: function(t) {
                    return null == t ? t = new U.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t
                },
                distance: function(t, e) {
                    return U.Point.distance(this, t, e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                angle: function(t, e) {
                    return void 0 === e && (e = !1), e ? U.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
                },
                rotate: function(t, e, i, o, s) {
                    return U.Point.rotate(this, t, e, i, o, s)
                },
                getMagnitude: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                getMagnitudeSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                setMagnitude: function(t) {
                    return this.normalize().multiply(t, t)
                },
                normalize: function() {
                    if (!this.isZero()) {
                        var t = this.getMagnitude();
                        this.x /= t, this.y /= t
                    }
                    return this
                },
                isZero: function() {
                    return 0 === this.x && 0 === this.y
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                perp: function() {
                    return this.setTo(-this.y, this.x)
                },
                rperp: function() {
                    return this.setTo(this.y, -this.x)
                },
                normalRightHand: function() {
                    return this.setTo(-1 * this.y, this.x)
                },
                floor: function() {
                    return this.setTo(Math.floor(this.x), Math.floor(this.y))
                },
                ceil: function() {
                    return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                },
                toString: function() {
                    return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                }
            }, U.Point.prototype.constructor = U.Point, U.Point.add = function(t, e, i) {
                return void 0 === i && (i = new U.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
            }, U.Point.subtract = function(t, e, i) {
                return void 0 === i && (i = new U.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
            }, U.Point.multiply = function(t, e, i) {
                return void 0 === i && (i = new U.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
            }, U.Point.divide = function(t, e, i) {
                return void 0 === i && (i = new U.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
            }, U.Point.equals = function(t, e) {
                return t.x === e.x && t.y === e.y
            }, U.Point.angle = function(t, e) {
                return Math.atan2(t.y - e.y, t.x - e.x)
            }, U.Point.negative = function(t, e) {
                return void 0 === e && (e = new U.Point), e.setTo(-t.x, -t.y)
            }, U.Point.multiplyAdd = function(t, e, i, o) {
                return void 0 === o && (o = new U.Point), o.setTo(t.x + e.x * i, t.y + e.y * i)
            }, U.Point.interpolate = function(t, e, i, o) {
                return void 0 === o && (o = new U.Point), o.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
            }, U.Point.perp = function(t, e) {
                return void 0 === e && (e = new U.Point), e.setTo(-t.y, t.x)
            }, U.Point.rperp = function(t, e) {
                return void 0 === e && (e = new U.Point), e.setTo(t.y, -t.x)
            }, U.Point.distance = function(t, e, i) {
                var o = U.Math.distance(t.x, t.y, e.x, e.y);
                return i ? Math.round(o) : o
            }, U.Point.project = function(t, e, i) {
                void 0 === i && (i = new U.Point);
                var o = t.dot(e) / e.getMagnitudeSq();
                return 0 !== o && i.setTo(o * e.x, o * e.y), i
            }, U.Point.projectUnit = function(t, e, i) {
                void 0 === i && (i = new U.Point);
                var o = t.dot(e);
                return 0 !== o && i.setTo(o * e.x, o * e.y), i
            }, U.Point.normalRightHand = function(t, e) {
                return void 0 === e && (e = new U.Point), e.setTo(-1 * t.y, t.x)
            }, U.Point.normalize = function(t, e) {
                void 0 === e && (e = new U.Point);
                var i = t.getMagnitude();
                return 0 !== i && e.setTo(t.x / i, t.y / i), e
            }, U.Point.rotate = function(t, e, i, o, s, n) {
                if (s && (o = U.Math.degToRad(o)), void 0 === n) {
                    t.subtract(e, i);
                    var r = Math.sin(o),
                        a = Math.cos(o),
                        h = a * t.x - r * t.y,
                        l = r * t.x + a * t.y;
                    t.x = h + e, t.y = l + i
                } else {
                    var d = o + Math.atan2(t.y - i, t.x - e);
                    t.x = e + n * Math.cos(d), t.y = i + n * Math.sin(d)
                }
                return t
            }, U.Point.centroid = function(t, e) {
                if (void 0 === e && (e = new U.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                var i = t.length;
                if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                if (1 === i) return e.copyFrom(t[0]), e;
                for (var o = 0; o < i; o++) U.Point.add(e, t[o], e);
                return e.divide(i, i), e
            }, U.Point.parse = function(t, e, i) {
                e = e || "x", i = i || "y";
                var o = new U.Point;
                return t[e] && (o.x = parseInt(t[e], 10)), t[i] && (o.y = parseInt(t[i], 10)), o
            }, PIXI.Point = U.Point, U.Polygon = function() {
                this.area = 0, this._points = [], 0 < arguments.length && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = U.POLYGON
            }, U.Polygon.prototype = {
                toNumberArray: function(t) {
                    void 0 === t && (t = []);
                    for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                    return t
                },
                flatten: function() {
                    return this._points = this.toNumberArray(), this.flattened = !0, this
                },
                clone: function(t) {
                    var e = this._points.slice();
                    return null == t ? t = new U.Polygon(e) : t.setTo(e), t
                },
                contains: function(t, e) {
                    var i = !1;
                    if (this.flattened)
                        for (var o = -2, s = this._points.length - 2;
                            (o += 2) < this._points.length; s = o) {
                            var n = this._points[o],
                                r = this._points[o + 1],
                                a = this._points[s],
                                h = this._points[s + 1];
                            (r <= e && e < h || h <= e && e < r) && t < (a - n) * (e - r) / (h - r) + n && (i = !i)
                        } else
                            for (o = -1, s = this._points.length - 1; ++o < this._points.length; s = o) {
                                n = this._points[o].x, r = this._points[o].y, a = this._points[s].x, h = this._points[s].y;
                                (r <= e && e < h || h <= e && e < r) && t < (a - n) * (e - r) / (h - r) + n && (i = !i)
                            }
                    return i
                },
                setTo: function(t) {
                    if (this.area = 0, this._points = [], 0 < arguments.length) {
                        Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                        for (var e = Number.MAX_VALUE, i = 0, o = t.length; i < o; i++) {
                            if ("number" == typeof t[i]) {
                                var s = new PIXI.Point(t[i], t[i + 1]);
                                i++
                            } else if (Array.isArray(t[i])) s = new PIXI.Point(t[i][0], t[i][1]);
                            else s = new PIXI.Point(t[i].x, t[i].y);
                            this._points.push(s), s.y < e && (e = s.y)
                        }
                        this.calculateArea(e)
                    }
                    return this
                },
                calculateArea: function(t) {
                    for (var e, i, o, s, n = 0, r = this._points.length; n < r; n++) e = this._points[n], i = n === r - 1 ? this._points[0] : this._points[n + 1], o = (e.y - t + (i.y - t)) / 2, s = e.x - i.x, this.area += o * s;
                    return this.area
                }
            }, U.Polygon.prototype.constructor = U.Polygon, Object.defineProperty(U.Polygon.prototype, "points", {
                get: function() {
                    return this._points
                },
                set: function(t) {
                    null != t ? this.setTo(t) : this.setTo()
                }
            }), PIXI.Polygon = U.Polygon, U.Rectangle = function(t, e, i, o) {
                t = t || 0, e = e || 0, i = i || 0, o = o || 0, this.x = t, this.y = e, this.width = i, this.height = o, this.type = U.RECTANGLE
            }, U.Rectangle.prototype = {
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                setTo: function(t, e, i, o) {
                    return this.x = t, this.y = e, this.width = i, this.height = o, this
                },
                scale: function(t, e) {
                    return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                },
                centerOn: function(t, e) {
                    return this.centerX = t, this.centerY = e, this
                },
                floor: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                },
                floorAll: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                },
                ceil: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                },
                ceilAll: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                inflate: function(t, e) {
                    return U.Rectangle.inflate(this, t, e)
                },
                size: function(t) {
                    return U.Rectangle.size(this, t)
                },
                resize: function(t, e) {
                    return this.width = t, this.height = e, this
                },
                clone: function(t) {
                    return U.Rectangle.clone(this, t)
                },
                contains: function(t, e) {
                    return U.Rectangle.contains(this, t, e)
                },
                containsRect: function(t) {
                    return U.Rectangle.containsRect(t, this)
                },
                equals: function(t) {
                    return U.Rectangle.equals(this, t)
                },
                intersection: function(t, e) {
                    return U.Rectangle.intersection(this, t, e)
                },
                intersects: function(t) {
                    return U.Rectangle.intersects(this, t)
                },
                intersectsRaw: function(t, e, i, o, s) {
                    return U.Rectangle.intersectsRaw(this, t, e, i, o, s)
                },
                union: function(t, e) {
                    return U.Rectangle.union(this, t, e)
                },
                random: function(t) {
                    return void 0 === t && (t = new U.Point), t.x = this.randomX, t.y = this.randomY, t
                },
                getPoint: function(t, e) {
                    switch (void 0 === e && (e = new U.Point), t) {
                        default:
                            case U.TOP_LEFT:
                            return e.set(this.x, this.y);
                        case U.TOP_CENTER:
                                return e.set(this.centerX, this.y);
                        case U.TOP_RIGHT:
                                return e.set(this.right, this.y);
                        case U.LEFT_CENTER:
                                return e.set(this.x, this.centerY);
                        case U.CENTER:
                                return e.set(this.centerX, this.centerY);
                        case U.RIGHT_CENTER:
                                return e.set(this.right, this.centerY);
                        case U.BOTTOM_LEFT:
                                return e.set(this.x, this.bottom);
                        case U.BOTTOM_CENTER:
                                return e.set(this.centerX, this.bottom);
                        case U.BOTTOM_RIGHT:
                                return e.set(this.right, this.bottom)
                    }
                },
                toString: function() {
                    return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                }
            }, Object.defineProperty(U.Rectangle.prototype, "halfWidth", {
                get: function() {
                    return Math.round(this.width / 2)
                }
            }), Object.defineProperty(U.Rectangle.prototype, "halfHeight", {
                get: function() {
                    return Math.round(this.height / 2)
                }
            }), Object.defineProperty(U.Rectangle.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t <= this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(U.Rectangle.prototype, "bottomLeft", {
                get: function() {
                    return new U.Point(this.x, this.bottom)
                },
                set: function(t) {
                    this.x = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(U.Rectangle.prototype, "bottomRight", {
                get: function() {
                    return new U.Point(this.right, this.bottom)
                },
                set: function(t) {
                    this.right = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(U.Rectangle.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                }
            }), Object.defineProperty(U.Rectangle.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t <= this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(U.Rectangle.prototype, "volume", {
                get: function() {
                    return this.width * this.height
                }
            }), Object.defineProperty(U.Rectangle.prototype, "perimeter", {
                get: function() {
                    return 2 * this.width + 2 * this.height
                }
            }), Object.defineProperty(U.Rectangle.prototype, "centerX", {
                get: function() {
                    return this.x + this.halfWidth
                },
                set: function(t) {
                    this.x = t - this.halfWidth
                }
            }), Object.defineProperty(U.Rectangle.prototype, "centerY", {
                get: function() {
                    return this.y + this.halfHeight
                },
                set: function(t) {
                    this.y = t - this.halfHeight
                }
            }), Object.defineProperty(U.Rectangle.prototype, "randomX", {
                get: function() {
                    return this.x + Math.random() * this.width
                }
            }), Object.defineProperty(U.Rectangle.prototype, "randomY", {
                get: function() {
                    return this.y + Math.random() * this.height
                }
            }), Object.defineProperty(U.Rectangle.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                }
            }), Object.defineProperty(U.Rectangle.prototype, "topLeft", {
                get: function() {
                    return new U.Point(this.x, this.y)
                },
                set: function(t) {
                    this.x = t.x, this.y = t.y
                }
            }), Object.defineProperty(U.Rectangle.prototype, "topRight", {
                get: function() {
                    return new U.Point(this.x + this.width, this.y)
                },
                set: function(t) {
                    this.right = t.x, this.y = t.y
                }
            }), Object.defineProperty(U.Rectangle.prototype, "empty", {
                get: function() {
                    return !this.width || !this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), U.Rectangle.prototype.constructor = U.Rectangle, U.Rectangle.inflate = function(t, e, i) {
                return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
            }, U.Rectangle.inflatePoint = function(t, e) {
                return U.Rectangle.inflate(t, e.x, e.y)
            }, U.Rectangle.size = function(t, e) {
                return null == e ? e = new U.Point(t.width, t.height) : e.setTo(t.width, t.height), e
            }, U.Rectangle.clone = function(t, e) {
                return null == e ? e = new U.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
            }, U.Rectangle.contains = function(t, e, i) {
                return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
            }, U.Rectangle.containsRaw = function(t, e, i, o, s, n) {
                return t <= s && s < t + i && e <= n && n < e + o
            }, U.Rectangle.containsPoint = function(t, e) {
                return U.Rectangle.contains(t, e.x, e.y)
            }, U.Rectangle.containsRect = function(t, e) {
                return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
            }, U.Rectangle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
            }, U.Rectangle.sameDimensions = function(t, e) {
                return t.width === e.width && t.height === e.height
            }, U.Rectangle.intersection = function(t, e, i) {
                return void 0 === i && (i = new U.Rectangle), U.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
            }, U.Rectangle.intersects = function(t, e) {
                return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
            }, U.Rectangle.intersectsRaw = function(t, e, i, o, s, n) {
                return void 0 === n && (n = 0), !(e > t.right + n || i < t.left - n || o > t.bottom + n || s < t.top - n)
            }, U.Rectangle.union = function(t, e, i) {
                return void 0 === i && (i = new U.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
            }, U.Rectangle.aabb = function(t, e) {
                void 0 === e && (e = new U.Rectangle);
                var i = Number.NEGATIVE_INFINITY,
                    o = Number.POSITIVE_INFINITY,
                    s = Number.NEGATIVE_INFINITY,
                    n = Number.POSITIVE_INFINITY;
                return t.forEach(function(t) {
                    t.x > i && (i = t.x), t.x < o && (o = t.x), t.y > s && (s = t.y), t.y < n && (n = t.y)
                }), e.setTo(o, n, i - o, s - n), e
            }, PIXI.Rectangle = U.Rectangle, PIXI.EmptyRectangle = new U.Rectangle(0, 0, 0, 0), U.RoundedRectangle = function(t, e, i, o, s) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 20), this.x = t, this.y = e, this.width = i, this.height = o, this.radius = s || 20, this.type = U.ROUNDEDRECTANGLE
            }, U.RoundedRectangle.prototype = {
                clone: function() {
                    return new U.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                },
                contains: function(t, e) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    var i = this.x;
                    if (i <= t && t <= i + this.width) {
                        var o = this.y;
                        if (o <= e && e <= o + this.height) return !0
                    }
                    return !1
                }
            }, U.RoundedRectangle.prototype.constructor = U.RoundedRectangle, PIXI.RoundedRectangle = U.RoundedRectangle, U.Camera = function(t, e, i, o, s, n) {
                this.game = t, this.world = t.world, this.id = 0, this.view = new U.Rectangle(i, o, s, n), this.bounds = new U.Rectangle(i, o, s, n), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                    x: !1,
                    y: !1
                }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new U.Point(1, 1), this.onShakeComplete = new U.Signal, this.onFlashComplete = new U.Signal, this.onFadeComplete = new U.Signal, this.fx = null, this._targetPosition = new U.Point, this._edge = 0, this._position = new U.Point, this._shake = {
                    intensity: 0,
                    duration: 0,
                    horizontal: !1,
                    vertical: !1,
                    shakeBounds: !0,
                    x: 0,
                    y: 0
                }, this._fxDuration = 0, this._fxType = 0
            }, U.Camera.FOLLOW_LOCKON = 0, U.Camera.FOLLOW_PLATFORMER = 1, U.Camera.FOLLOW_TOPDOWN = 2, U.Camera.FOLLOW_TOPDOWN_TIGHT = 3, U.Camera.SHAKE_BOTH = 4, U.Camera.SHAKE_HORIZONTAL = 5, U.Camera.SHAKE_VERTICAL = 6, U.Camera.ENABLE_FX = !0, U.Camera.prototype = {
                boot: function() {
                    this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, U.Graphics && U.Camera.ENABLE_FX && (this.fx = new U.Graphics(this.game), this.game.stage.addChild(this.fx))
                },
                preUpdate: function() {
                    this.totalInView = 0
                },
                follow: function(t, e, i, o) {
                    var s;
                    switch (void 0 === e && (e = U.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === o && (o = 1), this.target = t, this.lerp.set(i, o), e) {
                        case U.Camera.FOLLOW_PLATFORMER:
                            var n = this.width / 8,
                                r = this.height / 3;
                            this.deadzone = new U.Rectangle((this.width - n) / 2, (this.height - r) / 2 - .25 * r, n, r);
                            break;
                        case U.Camera.FOLLOW_TOPDOWN:
                            s = Math.max(this.width, this.height) / 4, this.deadzone = new U.Rectangle((this.width - s) / 2, (this.height - s) / 2, s, s);
                            break;
                        case U.Camera.FOLLOW_TOPDOWN_TIGHT:
                            s = Math.max(this.width, this.height) / 8, this.deadzone = new U.Rectangle((this.width - s) / 2, (this.height - s) / 2, s, s);
                            break;
                        case U.Camera.FOLLOW_LOCKON:
                        default:
                            this.deadzone = null
                    }
                },
                unfollow: function() {
                    this.target = null
                },
                focusOn: function(t) {
                    this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                },
                focusOnXY: function(t, e) {
                    this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                },
                shake: function(t, e, i, o, s) {
                    return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === o && (o = U.Camera.SHAKE_BOTH), void 0 === s && (s = !0), !(!i && 0 < this._shake.duration) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = s, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = o === U.Camera.SHAKE_BOTH || o === U.Camera.SHAKE_HORIZONTAL, this._shake.vertical = o === U.Camera.SHAKE_BOTH || o === U.Camera.SHAKE_VERTICAL, !0)
                },
                flash: function(t, e, i) {
                    return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, !(this._fxType = 0))
                },
                fade: function(t, e, i) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
                },
                update: function() {
                    0 < this._fxDuration && this.updateFX(), 0 < this._shake.duration && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                updateFX: function() {
                    0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, 1 <= this.fx.alpha && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                },
                updateShake: function() {
                    this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                },
                updateTarget: function() {
                    this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                setBoundsToWorld: function() {
                    this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                },
                checkBounds: function() {
                    this.atLimit.x = !1, this.atLimit.y = !1;
                    var t = this.view.x + this._shake.x,
                        e = this.view.right + this._shake.x,
                        i = this.view.y + this._shake.y,
                        o = this.view.bottom + this._shake.y;
                    t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), o >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                },
                setPosition: function(t, e) {
                    this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                },
                setSize: function(t, e) {
                    this.view.width = t, this.view.height = e
                },
                reset: function() {
                    this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
                },
                resetFX: function() {
                    this.fx && (this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0)
                }
            }, U.Camera.prototype.constructor = U.Camera, Object.defineProperty(U.Camera.prototype, "x", {
                get: function() {
                    return this.view.x
                },
                set: function(t) {
                    this.view.x = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(U.Camera.prototype, "y", {
                get: function() {
                    return this.view.y
                },
                set: function(t) {
                    this.view.y = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(U.Camera.prototype, "position", {
                get: function() {
                    return this._position.set(this.view.x, this.view.y), this._position
                },
                set: function(t) {
                    void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(U.Camera.prototype, "width", {
                get: function() {
                    return this.view.width
                },
                set: function(t) {
                    this.view.width = t
                }
            }), Object.defineProperty(U.Camera.prototype, "height", {
                get: function() {
                    return this.view.height
                },
                set: function(t) {
                    this.view.height = t
                }
            }), Object.defineProperty(U.Camera.prototype, "shakeIntensity", {
                get: function() {
                    return this._shake.intensity
                },
                set: function(t) {
                    this._shake.intensity = t
                }
            }), U.State = function() {
                this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
            }, U.State.prototype = {
                init: function() {},
                preload: function() {},
                loadUpdate: function() {},
                loadRender: function() {},
                create: function() {},
                update: function() {},
                preRender: function() {},
                render: function() {},
                resize: function() {},
                paused: function() {},
                resumed: function() {},
                pauseUpdate: function() {},
                shutdown: function() {}
            }, U.State.prototype.constructor = U.State, U.StateManager = function(t, e) {
                this.game = t, this.states = {}, (this._pendingState = null) != e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new U.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
            }, U.StateManager.prototype = {
                boot: function() {
                    this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                },
                add: function(t, e, i) {
                    var o;
                    return void 0 === i && (i = !1), e instanceof U.State ? o = e : "object" == typeof e ? (o = e).game = this.game : "function" == typeof e && (o = new e(this.game)), this.states[t] = o, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), o
                },
                remove: function(t) {
                    this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                },
                start: function(t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, 3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3)))
                },
                restart: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, 2 < arguments.length && (this._args = Array.prototype.slice.call(arguments, 2))
                },
                dummy: function() {},
                preUpdate: function() {
                    if (this._pendingState && this.game.isBooted) {
                        var t = this.current;
                        if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                        this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                    }
                },
                clearCurrentState: function() {
                    this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                },
                checkState: function(t) {
                    return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render)
                },
                link: function(t) {
                    this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, (this.states[t].state = this).states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
                },
                unlink: function(t) {
                    this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
                },
                setCurrentState: function(t) {
                    this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                },
                getCurrentState: function() {
                    return this.states[this.current]
                },
                loadComplete: function() {
                    !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                },
                pause: function() {
                    this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                },
                resume: function() {
                    this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                },
                update: function() {
                    this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                pauseUpdate: function() {
                    this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                preRender: function(t) {
                    this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                },
                resize: function(t, e) {
                    this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                },
                render: function() {
                    this._created ? this.onRenderCallback && (this.game.renderType === U.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                },
                destroy: function() {
                    this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                }
            }, U.StateManager.prototype.constructor = U.StateManager, Object.defineProperty(U.StateManager.prototype, "created", {
                get: function() {
                    return this._created
                }
            }), U.Signal = function() {}, U.Signal.prototype = {
                _bindings: null,
                _prevParams: null,
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _boundDispatch: !1,
                validateListener: function(t, e) {
                    if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                },
                _registerListener: function(t, e, i, o, s) {
                    var n, r = this._indexOfListener(t, i);
                    if (-1 !== r) {
                        if ((n = this._bindings[r]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                    } else n = new U.SignalBinding(this, t, e, i, o, s), this._addBinding(n);
                    return this.memorize && this._prevParams && n.execute(this._prevParams), n
                },
                _addBinding: function(t) {
                    this._bindings || (this._bindings = []);
                    for (var e = this._bindings.length; e--, this._bindings[e] && t._priority <= this._bindings[e]._priority;);
                    this._bindings.splice(e + 1, 0, t)
                },
                _indexOfListener: function(t, e) {
                    if (!this._bindings) return -1;
                    void 0 === e && (e = null);
                    for (var i, o = this._bindings.length; o--;)
                        if ((i = this._bindings[o])._listener === t && i.context === e) return o;
                    return -1
                },
                has: function(t, e) {
                    return -1 !== this._indexOfListener(t, e)
                },
                add: function(t, e, i) {
                    this.validateListener(t, "add");
                    var o = [];
                    if (3 < arguments.length)
                        for (var s = 3; s < arguments.length; s++) o.push(arguments[s]);
                    return this._registerListener(t, !1, e, i, o)
                },
                addOnce: function(t, e, i) {
                    this.validateListener(t, "addOnce");
                    var o = [];
                    if (3 < arguments.length)
                        for (var s = 3; s < arguments.length; s++) o.push(arguments[s]);
                    return this._registerListener(t, !0, e, i, o)
                },
                remove: function(t, e) {
                    this.validateListener(t, "remove");
                    var i = this._indexOfListener(t, e);
                    return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                },
                removeAll: function(t) {
                    if (void 0 === t && (t = null), this._bindings) {
                        for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                        t || (this._bindings.length = 0)
                    }
                },
                getNumListeners: function() {
                    return this._bindings ? this._bindings.length : 0
                },
                halt: function() {
                    this._shouldPropagate = !1
                },
                dispatch: function() {
                    if (this.active && this._bindings) {
                        var t, e = Array.prototype.slice.call(arguments),
                            i = this._bindings.length;
                        if (this.memorize && (this._prevParams = e), i)
                            for (t = this._bindings.slice(), this._shouldPropagate = !0; t[--i] && this._shouldPropagate && !1 !== t[i].execute(e););
                    }
                },
                forget: function() {
                    this._prevParams && (this._prevParams = null)
                },
                dispose: function() {
                    this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                },
                toString: function() {
                    return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                }
            }, Object.defineProperty(U.Signal.prototype, "boundDispatch", {
                get: function() {
                    var t = this;
                    return this._boundDispatch || (this._boundDispatch = function() {
                        return t.dispatch.apply(t, arguments)
                    })
                }
            }), U.Signal.prototype.constructor = U.Signal, U.SignalBinding = function(t, e, i, o, s, n) {
                this._listener = e, i && (this._isOnce = !0), null != o && (this.context = o), this._signal = t, s && (this._priority = s), n && n.length && (this._args = n)
            }, U.SignalBinding.prototype = {
                context: null,
                _isOnce: !1,
                _priority: 0,
                _args: null,
                callCount: 0,
                active: !0,
                params: null,
                execute: function(t) {
                    var e, i;
                    return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                },
                detach: function() {
                    return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                },
                isBound: function() {
                    return !!this._signal && !!this._listener
                },
                isOnce: function() {
                    return this._isOnce
                },
                getListener: function() {
                    return this._listener
                },
                getSignal: function() {
                    return this._signal
                },
                _destroy: function() {
                    delete this._signal, delete this._listener, delete this.context
                },
                toString: function() {
                    return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                }
            }, U.SignalBinding.prototype.constructor = U.SignalBinding, U.Filter = function(t, e, i) {
                this.game = t, this.type = U.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new U.Point;
                var o = new Date;
                if (this.uniforms = {
                        resolution: {
                            type: "2f",
                            value: {
                                x: 256,
                                y: 256
                            }
                        },
                        time: {
                            type: "1f",
                            value: 0
                        },
                        mouse: {
                            type: "2f",
                            value: {
                                x: 0,
                                y: 0
                            }
                        },
                        date: {
                            type: "4fv",
                            value: [o.getFullYear(), o.getMonth(), o.getDate(), 60 * o.getHours() * 60 + 60 * o.getMinutes() + o.getSeconds()]
                        },
                        sampleRate: {
                            type: "1f",
                            value: 44100
                        },
                        iChannel0: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel1: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel2: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel3: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        }
                    }, e)
                    for (var s in e) this.uniforms[s] = e[s];
                this.fragmentSrc = i || ""
            }, U.Filter.prototype = {
                init: function() {},
                setResolution: function(t, e) {
                    this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                },
                update: function(t) {
                    if (void 0 !== t) {
                        var e = t.x / this.game.width,
                            i = 1 - t.y / this.game.height;
                        e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                    }
                    this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                },
                addToWorld: function(t, e, i, o, s, n) {
                    void 0 === s && (s = 0), void 0 === n && (n = 0), null != i ? this.width = i : i = this.width, null != o ? this.height = o : o = this.height;
                    var r = this.game.add.image(t, e, "__default");
                    return r.width = i, r.height = o, r.anchor.set(s, n), r.filters = [this], r
                },
                destroy: function() {
                    this.game = null
                }
            }, U.Filter.prototype.constructor = U.Filter, Object.defineProperty(U.Filter.prototype, "width", {
                get: function() {
                    return this.uniforms.resolution.value.x
                },
                set: function(t) {
                    this.uniforms.resolution.value.x = t
                }
            }), Object.defineProperty(U.Filter.prototype, "height", {
                get: function() {
                    return this.uniforms.resolution.value.y
                },
                set: function(t) {
                    this.uniforms.resolution.value.y = t
                }
            }), U.Plugin = function(t, e) {
                void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
            }, U.Plugin.prototype = {
                preUpdate: function() {},
                update: function() {},
                render: function() {},
                postRender: function() {},
                destroy: function() {
                    this.game = null, this.parent = null, this.active = !1, this.visible = !1
                }
            }, U.Plugin.prototype.constructor = U.Plugin, U.PluginManager = function(t) {
                this.game = t, this.plugins = [], this._len = 0, this._i = 0
            }, U.PluginManager.prototype = {
                add: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1),
                        i = !1;
                    return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (i = t.hasPreUpdate = !0), "function" == typeof t.update && (i = t.hasUpdate = !0), "function" == typeof t.postUpdate && (i = t.hasPostUpdate = !0), "function" == typeof t.render && (i = t.hasRender = !0), "function" == typeof t.postRender && (i = t.hasPostRender = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                },
                remove: function(t, e) {
                    for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                        if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                },
                removeAll: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                    this.plugins.length = 0, this._len = 0
                },
                preUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                },
                update: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                },
                postUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                },
                render: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                },
                postRender: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                },
                destroy: function() {
                    this.removeAll(), this.game = null
                }
            }, U.PluginManager.prototype.constructor = U.PluginManager, U.Stage = function(t) {
                this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, (this.stage = this).currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    color: 0,
                    rgba: "#000000"
                }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
            }, U.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), U.Stage.prototype.constructor = U.Stage, U.Stage.prototype.parseConfig = function(t) {
                t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
            }, U.Stage.prototype.boot = function() {
                U.DOM.getOffset(this.game.canvas, this.offset), U.Canvas.setUserSelect(this.game.canvas, "none"), U.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
            }, U.Stage.prototype.preUpdate = function() {
                for (var t = this.currentRenderOrderID = 0; t < this.children.length;) {
                    var e = this.children[t];
                    e.preUpdate(), this === e.parent && t++
                }
            }, U.Stage.prototype.update = function() {
                for (var t = this.children.length; t--;) this.children[t].update()
            }, U.Stage.prototype.postUpdate = function() {
                this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                this.updateTransform()
            }, U.Stage.prototype.updateTransform = function() {
                this.worldAlpha = 1;
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
            }, U.Stage.prototype.checkVisibility = function() {
                void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                var e = this;
                this._onChange = function(t) {
                    return e.visibilityChange(t)
                }, this._onClick = function(t) {
                    document.hasFocus() || e.visibilityChange(t)
                }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.addEventListener("click", this._onClick), this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                    U.Stage.prototype.visibilityChange.call(e, {
                        type: "pause"
                    })
                }), CocoonJS.App.onActivated.addEventListener(function() {
                    U.Stage.prototype.visibilityChange.call(e, {
                        type: "resume"
                    })
                }))
            }, U.Stage.prototype.visibilityChange = function(t) {
                switch (t.type) {
                    case "blur":
                    case "pagehide":
                        return void this.game.focusLoss(t);
                    case "click":
                    case "focus":
                    case "pageshow":
                        return void this.game.focusGain(t)
                }
                this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
            }, U.Stage.prototype.setBackgroundColor = function(t) {
                this.game.transparent || (U.Color.valueToColor(t, this._bgColor), U.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
            }, U.Stage.prototype.destroy = function() {
                this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null, window.removeEventListener("click", this._onClick)
            }, Object.defineProperty(U.Stage.prototype, "backgroundColor", {
                get: function() {
                    return this._bgColor.color
                },
                set: function(t) {
                    this.setBackgroundColor(t)
                }
            }), Object.defineProperty(U.Stage.prototype, "smoothed", {
                get: function() {
                    return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                },
                set: function(t) {
                    PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                }
            }), U.Group = function(t, e, i, o, s, n) {
                void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === n && (n = U.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), o ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = U.GROUP, this.physicsType = U.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = U.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new U.Signal, this.onChildInputUp = new U.Signal, this.onChildInputOver = new U.Signal, this.onChildInputOut = new U.Signal, this.enableBody = s, this.enableBodyDebug = !1, this.physicsBodyType = n, this.physicsSortDirection = null, this.onDestroy = new U.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new U.Point, this.hash = [], this._sortProperty = "z"
            }, U.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), U.Group.prototype.constructor = U.Group, U.Group.RETURN_NONE = 0, U.Group.RETURN_TOTAL = 1, U.Group.RETURN_CHILD = 2, U.Group.RETURN_ALL = 3, U.Group.SORT_ASCENDING = -1, U.Group.SORT_DESCENDING = 1, U.Group.prototype.add = function(t, e, i) {
                return void 0 === e && (e = !1), t.parent === this || (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t)), t
            }, U.Group.prototype.addAt = function(t, e, i) {
                this.add(t, i, e)
            }, U.Group.prototype.addToHash = function(t) {
                if (t.parent === this && -1 === this.hash.indexOf(t)) return this.hash.push(t), !0;
                return !1
            }, U.Group.prototype.removeFromHash = function(t) {
                if (t) {
                    var e = this.hash.indexOf(t);
                    if (-1 !== e) return this.hash.splice(e, 1), !0
                }
                return !1
            }, U.Group.prototype.addMultiple = function(t, e) {
                if (t instanceof U.Group) t.moveAll(this, e);
                else if (Array.isArray(t))
                    for (var i = 0; i < t.length; i++) this.add(t[i], e);
                return t
            }, U.Group.prototype.getAt = function(t) {
                return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
            }, U.Group.prototype.create = function(t, e, i, o, s, n) {
                void 0 === s && (s = !0);
                var r = new this.classType(this.game, t, e, i, o);
                return r.exists = s, r.visible = s, r.alive = s, this.add(r, !1, n)
            }, U.Group.prototype.createMultiple = function(o, t, e, s) {
                void 0 === e && (e = 0), void 0 === s && (s = !1), Array.isArray(t) || (t = [t]), Array.isArray(e) || (e = [e]);
                var n = this,
                    r = [];
                return t.forEach(function(i) {
                    e.forEach(function(t) {
                        for (var e = 0; e < o; e++) r.push(n.create(0, 0, i, t, s))
                    })
                }), r
            }, U.Group.prototype.updateZ = function() {
                for (var t = this.children.length; t--;) this.children[t].z = t
            }, U.Group.prototype.align = function(t, e, i, o, s, n) {
                if (void 0 === s && (s = U.TOP_LEFT), void 0 === n && (n = 0), 0 === this.children.length || n > this.children.length || -1 === t && -1 === e) return !1;
                for (var r = new U.Rectangle(0, 0, i, o), a = t * i, h = e * o, l = n; l < this.children.length; l++) {
                    var d = this.children[l];
                    if (d.alignIn)
                        if (d.alignIn(r, s), -1 === t) r.y += o, r.y === h && (r.x += i, r.y = 0);
                        else if (-1 === e) r.x += i, r.x === a && (r.x = 0, r.y += o);
                    else if (r.x += i, r.x === a && (r.x = 0, r.y += o, r.y === h)) return !0
                }
                return !0
            }, U.Group.prototype.resetCursor = function(t) {
                if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
            }, U.Group.prototype.next = function() {
                if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
            }, U.Group.prototype.previous = function() {
                if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
            }, U.Group.prototype.swap = function(t, e) {
                this.swapChildren(t, e), this.updateZ()
            }, U.Group.prototype.bringToTop = function(t) {
                return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
            }, U.Group.prototype.sendToBack = function(t) {
                return t.parent === this && 0 < this.getIndex(t) && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
            }, U.Group.prototype.moveUp = function(t) {
                if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                    var e = this.getIndex(t),
                        i = this.getAt(e + 1);
                    i && this.swap(t, i)
                }
                return t
            }, U.Group.prototype.moveDown = function(t) {
                if (t.parent === this && 0 < this.getIndex(t)) {
                    var e = this.getIndex(t),
                        i = this.getAt(e - 1);
                    i && this.swap(t, i)
                }
                return t
            }, U.Group.prototype.xy = function(t, e, i) {
                if (t < 0 || t > this.children.length) return -1;
                this.getChildAt(t).x = e, this.getChildAt(t).y = i
            }, U.Group.prototype.reverse = function() {
                this.children.reverse(), this.updateZ()
            }, U.Group.prototype.getIndex = function(t) {
                return this.children.indexOf(t)
            }, U.Group.prototype.getByName = function(t) {
                for (var e = 0; e < this.children.length; e++)
                    if (this.children[e].name === t) return this.children[e];
                return null
            }, U.Group.prototype.replace = function(t, e) {
                var i = this.getIndex(t);
                if (-1 !== i) return e.parent && (e.parent instanceof U.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t
            }, U.Group.prototype.hasProperty = function(t, e) {
                var i = e.length;
                return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
            }, U.Group.prototype.setProperty = function(t, e, i, o, s) {
                if (void 0 === s && (s = !1), o = o || 0, !this.hasProperty(t, e) && (!s || 0 < o)) return !1;
                var n = e.length;
                return 1 === n ? 0 === o ? t[e[0]] = i : 1 === o ? t[e[0]] += i : 2 === o ? t[e[0]] -= i : 3 === o ? t[e[0]] *= i : 4 === o && (t[e[0]] /= i) : 2 === n ? 0 === o ? t[e[0]][e[1]] = i : 1 === o ? t[e[0]][e[1]] += i : 2 === o ? t[e[0]][e[1]] -= i : 3 === o ? t[e[0]][e[1]] *= i : 4 === o && (t[e[0]][e[1]] /= i) : 3 === n ? 0 === o ? t[e[0]][e[1]][e[2]] = i : 1 === o ? t[e[0]][e[1]][e[2]] += i : 2 === o ? t[e[0]][e[1]][e[2]] -= i : 3 === o ? t[e[0]][e[1]][e[2]] *= i : 4 === o && (t[e[0]][e[1]][e[2]] /= i) : 4 === n && (0 === o ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === o ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === o ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === o ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === o && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
            }, U.Group.prototype.checkProperty = function(t, e, i, o) {
                return void 0 === o && (o = !1), !(!U.Utils.getProperty(t, e) && o) && U.Utils.getProperty(t, e) === i
            }, U.Group.prototype.set = function(t, e, i, o, s, n, r) {
                if (void 0 === r && (r = !1), e = e.split("."), void 0 === o && (o = !1), void 0 === s && (s = !1), (!1 === o || o && t.alive) && (!1 === s || s && t.visible)) return this.setProperty(t, e, i, n, r)
            }, U.Group.prototype.setAll = function(t, e, i, o, s, n) {
                void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === n && (n = !1), t = t.split("."), s = s || 0;
                for (var r = 0; r < this.children.length; r++)(!i || i && this.children[r].alive) && (!o || o && this.children[r].visible) && this.setProperty(this.children[r], t, e, s, n)
            }, U.Group.prototype.setAllChildren = function(t, e, i, o, s, n) {
                void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === n && (n = !1), s = s || 0;
                for (var r = 0; r < this.children.length; r++)(!i || i && this.children[r].alive) && (!o || o && this.children[r].visible) && (this.children[r] instanceof U.Group ? this.children[r].setAllChildren(t, e, i, o, s, n) : this.setProperty(this.children[r], t.split("."), e, s, n))
            }, U.Group.prototype.checkAll = function(t, e, i, o, s) {
                void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === s && (s = !1);
                for (var n = 0; n < this.children.length; n++)
                    if ((!i || i && this.children[n].alive) && (!o || o && this.children[n].visible) && !this.checkProperty(this.children[n], t, e, s)) return !1;
                return !0
            }, U.Group.prototype.addAll = function(t, e, i, o) {
                this.setAll(t, e, i, o, 1)
            }, U.Group.prototype.subAll = function(t, e, i, o) {
                this.setAll(t, e, i, o, 2)
            }, U.Group.prototype.multiplyAll = function(t, e, i, o) {
                this.setAll(t, e, i, o, 3)
            }, U.Group.prototype.divideAll = function(t, e, i, o) {
                this.setAll(t, e, i, o, 4)
            }, U.Group.prototype.callAllExists = function(t, e) {
                var i;
                if (2 < arguments.length) {
                    i = [];
                    for (var o = 2; o < arguments.length; o++) i.push(arguments[o])
                }
                for (o = 0; o < this.children.length; o++) this.children[o].exists === e && this.children[o][t] && this.children[o][t].apply(this.children[o], i)
            }, U.Group.prototype.callbackFromArray = function(t, e, i) {
                if (1 === i) {
                    if (t[e[0]]) return t[e[0]]
                } else if (2 === i) {
                    if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                } else if (3 === i) {
                    if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                } else if (4 === i) {
                    if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                } else if (t[e]) return t[e];
                return !1
            }, U.Group.prototype.callAll = function(t, e) {
                if (void 0 !== t) {
                    var i, o = (t = t.split(".")).length;
                    if (null == e || "" === e) e = null;
                    else if ("string" == typeof e) var s = (e = e.split(".")).length;
                    if (2 < arguments.length) {
                        i = [];
                        for (var n = 2; n < arguments.length; n++) i.push(arguments[n])
                    }
                    var r = null,
                        a = null;
                    for (n = 0; n < this.children.length; n++) r = this.callbackFromArray(this.children[n], t, o), e && r ? (a = this.callbackFromArray(this.children[n], e, s), r && r.apply(a, i)) : r && r.apply(this.children[n], i)
                }
            }, U.Group.prototype.preUpdate = function() {
                if (this.pendingDestroy) return this.destroy(), !1;
                if (!this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
                for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                return !0
            }, U.Group.prototype.update = function() {
                for (var t = this.children.length; t--;) this.children[t].update()
            }, U.Group.prototype.postUpdate = function() {
                this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }, U.Group.prototype.filter = function(t, e) {
                for (var i = -1, o = this.children.length, s = []; ++i < o;) {
                    var n = this.children[i];
                    (!e || e && n.exists) && t(n, i, this.children) && s.push(n)
                }
                return new U.ArraySet(s)
            }, U.Group.prototype.forEach = function(t, e, i) {
                if (void 0 === i && (i = !1), arguments.length <= 3)
                    for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && t.call(e, this.children[o]);
                else {
                    var s = [null];
                    for (o = 3; o < arguments.length; o++) s.push(arguments[o]);
                    for (o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && (s[0] = this.children[o], t.apply(e, s))
                }
            }, U.Group.prototype.forEachExists = function(t, e) {
                var i;
                if (2 < arguments.length) {
                    i = [null];
                    for (var o = 2; o < arguments.length; o++) i.push(arguments[o])
                }
                this.iterate("exists", !0, U.Group.RETURN_TOTAL, t, e, i)
            }, U.Group.prototype.forEachAlive = function(t, e) {
                var i;
                if (2 < arguments.length) {
                    i = [null];
                    for (var o = 2; o < arguments.length; o++) i.push(arguments[o])
                }
                this.iterate("alive", !0, U.Group.RETURN_TOTAL, t, e, i)
            }, U.Group.prototype.forEachDead = function(t, e) {
                var i;
                if (2 < arguments.length) {
                    i = [null];
                    for (var o = 2; o < arguments.length; o++) i.push(arguments[o])
                }
                this.iterate("alive", !1, U.Group.RETURN_TOTAL, t, e, i)
            }, U.Group.prototype.sort = function(t, e) {
                this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = U.Group.SORT_ASCENDING), this._sortProperty = t, e === U.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
            }, U.Group.prototype.customSort = function(t, e) {
                this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
            }, U.Group.prototype.ascendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
            }, U.Group.prototype.descendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
            }, U.Group.prototype.iterate = function(t, e, i, o, s, n) {
                if (0 === this.children.length) {
                    if (i === U.Group.RETURN_TOTAL) return 0;
                    if (i === U.Group.RETURN_ALL) return []
                }
                var r = 0;
                if (i === U.Group.RETURN_ALL) var a = [];
                for (var h = 0; h < this.children.length; h++)
                    if (this.children[h][t] === e) {
                        if (r++, o && (n ? (n[0] = this.children[h], o.apply(s, n)) : o.call(s, this.children[h])), i === U.Group.RETURN_CHILD) return this.children[h];
                        i === U.Group.RETURN_ALL && a.push(this.children[h])
                    }
                return i === U.Group.RETURN_TOTAL ? r : i === U.Group.RETURN_ALL ? a : null
            }, U.Group.prototype.getFirstExists = function(t, e, i, o, s, n) {
                void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                var r = this.iterate("exists", t, U.Group.RETURN_CHILD);
                return null === r && e ? this.create(i, o, s, n) : this.resetChild(r, i, o, s, n)
            }, U.Group.prototype.getFirstAlive = function(t, e, i, o, s) {
                void 0 === t && (t = !1);
                var n = this.iterate("alive", !0, U.Group.RETURN_CHILD);
                return null === n && t ? this.create(e, i, o, s) : this.resetChild(n, e, i, o, s)
            }, U.Group.prototype.getFirstDead = function(t, e, i, o, s) {
                void 0 === t && (t = !1);
                var n = this.iterate("alive", !1, U.Group.RETURN_CHILD);
                return null === n && t ? this.create(e, i, o, s) : this.resetChild(n, e, i, o, s)
            }, U.Group.prototype.resetChild = function(t, e, i, o, s) {
                return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== o && t.loadTexture(o, s), t)
            }, U.Group.prototype.getTop = function() {
                if (0 < this.children.length) return this.children[this.children.length - 1]
            }, U.Group.prototype.getBottom = function() {
                if (0 < this.children.length) return this.children[0]
            }, U.Group.prototype.getClosestTo = function(t, e, i) {
                for (var o = Number.MAX_VALUE, s = 0, n = null, r = 0; r < this.children.length; r++) {
                    var a = this.children[r];
                    a.exists && (s = Math.abs(U.Point.distance(t, a))) < o && (!e || e.call(i, a, s)) && (o = s, n = a)
                }
                return n
            }, U.Group.prototype.getFurthestFrom = function(t, e, i) {
                for (var o = 0, s = 0, n = null, r = 0; r < this.children.length; r++) {
                    var a = this.children[r];
                    a.exists && o < (s = Math.abs(U.Point.distance(t, a))) && (!e || e.call(i, a, s)) && (o = s, n = a)
                }
                return n
            }, U.Group.prototype.countLiving = function() {
                return this.iterate("alive", !0, U.Group.RETURN_TOTAL)
            }, U.Group.prototype.countDead = function() {
                return this.iterate("alive", !1, U.Group.RETURN_TOTAL)
            }, U.Group.prototype.getRandom = function(t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : U.ArrayUtils.getRandomItem(this.children, t, e)
            }, U.Group.prototype.getRandomExists = function(t, e) {
                var i = this.getAll("exists", !0, t, e);
                return this.game.rnd.pick(i)
            }, U.Group.prototype.getAll = function(t, e, i, o) {
                void 0 === i && (i = 0), void 0 === o && (o = this.children.length);
                for (var s = [], n = i; n < o; n++) {
                    var r = this.children[n];
                    t && r[t] === e && s.push(r)
                }
                return s
            }, U.Group.prototype.remove = function(t, e, i) {
                if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                var o = this.removeChild(t);
                return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && o && o.destroy(!0), !0
            }, U.Group.prototype.moveAll = function(t, e) {
                if (void 0 === e && (e = !1), 0 < this.children.length && t instanceof U.Group) {
                    for (; t.add(this.children[0], e), 0 < this.children.length;);
                    this.hash = [], this.cursor = null
                }
                return t
            }, U.Group.prototype.removeAll = function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                    do {
                        !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        var o = this.removeChild(this.children[0]);
                        this.removeFromHash(o), t && o && o.destroy(!0, i)
                    } while (0 < this.children.length);
                    this.hash = [], this.cursor = null
                }
            }, U.Group.prototype.removeBetween = function(t, e, i, o) {
                if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === o && (o = !1), 0 !== this.children.length) {
                    if (e < t || t < 0 || e > this.children.length) return !1;
                    for (var s = e; t <= s;) {
                        !o && this.children[s].events && this.children[s].events.onRemovedFromGroup$dispatch(this.children[s], this);
                        var n = this.removeChild(this.children[s]);
                        this.removeFromHash(n), i && n && n.destroy(!0), this.cursor === this.children[s] && (this.cursor = null), s--
                    }
                    this.updateZ()
                }
            }, U.Group.prototype.destroy = function(t, e) {
                null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
            }, Object.defineProperty(U.Group.prototype, "total", {
                get: function() {
                    return this.iterate("exists", !0, U.Group.RETURN_TOTAL)
                }
            }), Object.defineProperty(U.Group.prototype, "length", {
                get: function() {
                    return this.children.length
                }
            }), Object.defineProperty(U.Group.prototype, "angle", {
                get: function() {
                    return U.Math.radToDeg(this.rotation)
                },
                set: function(t) {
                    this.rotation = U.Math.degToRad(t)
                }
            }), Object.defineProperty(U.Group.prototype, "centerX", {
                get: function() {
                    return this.getBounds(this.parent).centerX
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.halfWidth
                }
            }), Object.defineProperty(U.Group.prototype, "centerY", {
                get: function() {
                    return this.getBounds(this.parent).centerY
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.halfHeight
                }
            }), Object.defineProperty(U.Group.prototype, "left", {
                get: function() {
                    return this.getBounds(this.parent).left
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i
                }
            }), Object.defineProperty(U.Group.prototype, "right", {
                get: function() {
                    return this.getBounds(this.parent).right
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.width
                }
            }), Object.defineProperty(U.Group.prototype, "top", {
                get: function() {
                    return this.getBounds(this.parent).top
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i
                }
            }), Object.defineProperty(U.Group.prototype, "bottom", {
                get: function() {
                    return this.getBounds(this.parent).bottom
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.height
                }
            }), U.World = function(t) {
                U.Group.call(this, t, null, "__world", !1), this.bounds = new U.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
            }, U.World.prototype = Object.create(U.Group.prototype), U.World.prototype.constructor = U.World, U.World.prototype.boot = function() {
                this.camera = new U.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
            }, U.World.prototype.stateChange = function() {
                this.x = 0, this.y = 0, this.camera.reset()
            }, U.World.prototype.setBounds = function(t, e, i, o) {
                this._definedSize = !0, this._width = i, this._height = o, this.bounds.setTo(t, e, i, o), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(o, this.game.height)), this.game.physics.setBoundsToWorld()
            }, U.World.prototype.resize = function(t, e) {
                this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
            }, U.World.prototype.shutdown = function() {
                this.destroy(!0, !0)
            }, U.World.prototype.wrap = function(t, e, i, o, s) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === o && (o = !0), void 0 === s && (s = !0), i ? (t.getBounds(), o && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), s && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (o && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : o && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), s && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : s && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
            }, Object.defineProperty(U.World.prototype, "width", {
                get: function() {
                    return this.bounds.width
                },
                set: function(t) {
                    t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                }
            }), Object.defineProperty(U.World.prototype, "height", {
                get: function() {
                    return this.bounds.height
                },
                set: function(t) {
                    t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                }
            }), Object.defineProperty(U.World.prototype, "centerX", {
                get: function() {
                    return this.bounds.halfWidth + this.bounds.x
                }
            }), Object.defineProperty(U.World.prototype, "centerY", {
                get: function() {
                    return this.bounds.halfHeight + this.bounds.y
                }
            }), Object.defineProperty(U.World.prototype, "randomX", {
                get: function() {
                    return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                }
            }), Object.defineProperty(U.World.prototype, "randomY", {
                get: function() {
                    return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                }
            }), U.Game = function(t, e, i, o, s, n, r, a) {
                return this.id = U.GAMES.push(this) - 1, this.config = null, this.physicsConfig = a, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = U.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = U.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new U.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof t ? this.parseConfig(t) : (this.config = {
                    enableDebug: !0
                }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== o && (this.parent = o), void 0 !== n && (this.transparent = n), void 0 !== r && (this.antialias = r), this.rnd = new U.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new U.StateManager(this, s)), this.device.whenReady(this.boot, this), this
            }, U.Game.prototype = {
                parseConfig: function(t) {
                    void 0 === (this.config = t).enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                    var e = [(Date.now() * Math.random()).toString()];
                    t.seed && (e = t.seed), this.rnd = new U.RandomDataGenerator(e);
                    var i = null;
                    t.state && (i = t.state), this.state = new U.StateManager(this, i)
                },
                boot: function() {
                    this.isBooted || (this.onPause = new U.Signal, this.onResume = new U.Signal, this.onBlur = new U.Signal, this.onFocus = new U.Signal, this.isBooted = !0, (PIXI.game = this).math = U.Math, this.scale = new U.ScaleManager(this, this._width, this._height), this.stage = new U.Stage(this), this.setUpRenderer(), this.world = new U.World(this), this.add = new U.GameObjectFactory(this), this.make = new U.GameObjectCreator(this), this.cache = new U.Cache(this), this.load = new U.Loader(this), this.time = new U.Time(this), this.tweens = new U.TweenManager(this), this.input = new U.Input(this), this.sound = new U.SoundManager(this), this.physics = new U.Physics(this, this.physicsConfig), this.particles = new U.Particles(this), this.create = new U.Create(this), this.plugins = new U.PluginManager(this), this.net = new U.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new U.Utils.Debug(this), this.debug.boot()) : this.debug = {
                        preUpdate: function() {},
                        update: function() {},
                        reset: function() {}
                    }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new U.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new U.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
                },
                showDebugHeader: function() {
                    if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                        var t = U.VERSION,
                            e = "Canvas",
                            i = "HTML Audio",
                            o = 1;
                        if (this.renderType === U.WEBGL ? (e = "WebGL", o++) : this.renderType === U.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", o++), this.device.chrome)
                            for (var s = ["%c %c %c @orange-games/phaser v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c https://github.com/orange-games / https://www.orangegames.com %c%c%c", "background: #F47820", "background: #ED873F", "color: #ffffff; background: #DD6612;", "background: #ED873F", "background: #F47820", "background: #ffffff"], n = 0; n < 3; n++) n < o ? s.push("color: #ff2424; background: #fff") : s.push("color: #959595; background: #fff");
                        else window.console
                    }
                },
                setUpRenderer: function() {
                    if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = U.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === U.HEADLESS || this.renderType === U.CANVAS || this.renderType === U.AUTO && !this.device.webGL) {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                        this.renderType = U.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                    } else this.renderType = U.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                    this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === U.CANVAS), this.renderType !== U.HEADLESS && (this.stage.smoothed = this.antialias, U.Canvas.addToDOM(this.canvas, this.parent, !1), U.Canvas.setTouchAction(this.canvas))
                },
                contextLost: function(t) {
                    t.preventDefault(), this.renderer.contextLost = !0
                },
                contextRestored: function() {
                    this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                },
                update: function(t) {
                    if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                    if (1 < this._spiraling && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                    else {
                        var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                        this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                        var i = 0;
                        for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                        i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                    }
                },
                updateLogic: function(t) {
                    this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                },
                updateRender: function(t) {
                    this.lockRender || (this.state.preRender(t), this.renderType !== U.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
                },
                enableStep: function() {
                    this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                },
                disableStep: function() {
                    this.stepping = !1, this.pendingStep = !1
                },
                step: function() {
                    this.pendingStep = !1, this.stepCount++
                },
                destroy: function() {
                    this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), U.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, U.GAMES[this.id] = null
                },
                gamePaused: function(t) {
                    this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                },
                gameResumed: function(t) {
                    this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                },
                focusLoss: function(t) {
                    this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                },
                focusGain: function(t) {
                    this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                }
            }, U.Game.prototype.constructor = U.Game, Object.defineProperty(U.Game.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    this._codePaused = !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), !1)
                }
            }), U.Input = function(t) {
                this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = U.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new U.ArraySet, this._localPoint = new U.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
            }, U.Input.MOUSE_OVERRIDES_TOUCH = 0, U.Input.TOUCH_OVERRIDES_MOUSE = 1, U.Input.MOUSE_TOUCH_COMBINE = 2, U.Input.MAX_POINTERS = 10, U.Input.prototype = {
                boot: function() {
                    this.mousePointer = new U.Pointer(this.game, 0, U.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new U.Mouse(this.game), this.touch = new U.Touch(this.game), this.mspointer = new U.MSPointer(this.game), U.Keyboard && (this.keyboard = new U.Keyboard(this.game)), U.Gamepad && (this.gamepad = new U.Gamepad(this.game)), this.onDown = new U.Signal, this.onUp = new U.Signal, this.onTap = new U.Signal, this.onHold = new U.Signal, this.scale = new U.Point(1, 1), this.speed = new U.Point, this.position = new U.Point, this._oldPosition = new U.Point, this.circle = new U.Circle(0, 0, 45), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.mspointer ? this.mspointer.start() : this.game.device.touch && this.touch.start(), this.mspointer.active || this.mouse.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                    var e = this;
                    this._onClickTrampoline = function(t) {
                        e.onClickTrampoline(t)
                    }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                },
                destroy: function() {
                    this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                },
                setInteractiveCandidateHandler: function(t, e) {
                    this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                },
                addMoveCallback: function(t, e) {
                    this.moveCallbacks.push({
                        callback: t,
                        context: e
                    })
                },
                deleteMoveCallback: function(t, e) {
                    for (var i = this.moveCallbacks.length; i--;)
                        if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                },
                addPointer: function() {
                    if (this.pointers.length >= U.Input.MAX_POINTERS) return null;
                    var t = this.pointers.length + 1,
                        e = new U.Pointer(this.game, t, U.PointerMode.TOUCH);
                    return this.pointers.push(e), this["pointer" + t] = e
                },
                update: function() {
                    if (this.keyboard && this.keyboard.update(), 0 < this.pollRate && this._pollCounter < this.pollRate) this._pollCounter++;
                    else {
                        this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                        for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                        this._pollCounter = 0
                    }
                },
                reset: function(t) {
                    if (this.game.isBooted && !this.resetLocked) {
                        void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                        for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                        "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new U.Signal, this.onUp = new U.Signal, this.onTap = new U.Signal, this.onHold = new U.Signal, this.moveCallbacks = []), this._pollCounter = 0
                    }
                },
                resetSpeed: function(t, e) {
                    this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                },
                startPointer: function(t) {
                    if (0 <= this.maxPointers && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                    if (!this.pointer1.active) return this.pointer1.start(t);
                    if (!this.pointer2.active) return this.pointer2.start(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (!i.active) return i.start(t)
                    }
                    return null
                },
                updatePointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.move(t)
                    }
                    return null
                },
                stopPointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.stop(t)
                    }
                    return null
                },
                countActivePointers: function(t) {
                    void 0 === t && (t = this.pointers.length);
                    for (var e = t, i = 0; i < this.pointers.length && 0 < e; i++) {
                        this.pointers[i].active && e--
                    }
                    return t - e
                },
                getPointer: function(t) {
                    void 0 === t && (t = !1);
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active === t) return i
                    }
                    return null
                },
                getPointerFromIdentifier: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.identifier === t) return i
                    }
                    return null
                },
                getPointerFromId: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.pointerId === t) return i
                    }
                    return null
                },
                getLocalPosition: function(t, e, i) {
                    void 0 === i && (i = new U.Point);
                    var o = t.worldTransform,
                        s = 1 / (o.a * o.d + o.c * -o.b);
                    return i.setTo(o.d * s * e.x + -o.c * s * e.y + (o.ty * o.c - o.tx * o.d) * s, o.a * s * e.y + -o.b * s * e.x + (-o.ty * o.a + o.tx * o.b) * s)
                },
                hitTest: function(t, e, i) {
                    if (!t.worldVisible) return !1;
                    if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                    if (t instanceof U.TileSprite) {
                        var o = t.width,
                            s = t.height,
                            n = -o * t.anchor.x;
                        if (this._localPoint.x >= n && this._localPoint.x < n + o) {
                            var r = -s * t.anchor.y;
                            if (this._localPoint.y >= r && this._localPoint.y < r + s) return !0
                        }
                    } else if (t instanceof PIXI.Sprite) {
                        o = t.texture.frame.width, s = t.texture.frame.height, n = -o * t.anchor.x;
                        if (this._localPoint.x >= n && this._localPoint.x < n + o) {
                            r = -s * t.anchor.y;
                            if (this._localPoint.y >= r && this._localPoint.y < r + s) return !0
                        }
                    } else if (U.Graphics && t instanceof U.Graphics)
                        for (var a = 0; a < t.graphicsData.length; a++) {
                            var h = t.graphicsData[a];
                            if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                        }
                    for (a = 0; a < t.children.length; a++)
                        if (this.hitTest(t.children[a], e, i)) return !0;
                    return !1
                },
                onClickTrampoline: function() {
                    this.activePointer.processClickTrampolines()
                }
            }, U.Input.prototype.constructor = U.Input, Object.defineProperty(U.Input.prototype, "x", {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = Math.floor(t)
                }
            }), Object.defineProperty(U.Input.prototype, "y", {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = Math.floor(t)
                }
            }), Object.defineProperty(U.Input.prototype, "pollLocked", {
                get: function() {
                    return 0 < this.pollRate && this._pollCounter < this.pollRate
                }
            }), Object.defineProperty(U.Input.prototype, "totalInactivePointers", {
                get: function() {
                    return this.pointers.length - this.countActivePointers()
                }
            }), Object.defineProperty(U.Input.prototype, "totalActivePointers", {
                get: function() {
                    return this.countActivePointers()
                }
            }), Object.defineProperty(U.Input.prototype, "worldX", {
                get: function() {
                    return this.game.camera.view.x + this.x
                }
            }), Object.defineProperty(U.Input.prototype, "worldY", {
                get: function() {
                    return this.game.camera.view.y + this.y
                }
            }), U.Mouse = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new U.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
            }, U.Mouse.NO_BUTTON = -1, U.Mouse.LEFT_BUTTON = 0, U.Mouse.MIDDLE_BUTTON = 1, U.Mouse.RIGHT_BUTTON = 2, U.Mouse.BACK_BUTTON = 3, U.Mouse.FORWARD_BUTTON = 4, U.Mouse.WHEEL_UP = 1, U.Mouse.WHEEL_DOWN = -1, U.Mouse.prototype = {
                start: function() {
                    if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                        var e = this;
                        this._onMouseDown = function(t) {
                            return e.onMouseDown(t)
                        }, this._onMouseMove = function(t) {
                            return e.onMouseMove(t)
                        }, this._onMouseUp = function(t) {
                            return e.onMouseUp(t)
                        }, this._onMouseUpGlobal = function(t) {
                            return e.onMouseUpGlobal(t)
                        }, this._onMouseOutGlobal = function(t) {
                            return e.onMouseOutGlobal(t)
                        }, this._onMouseOut = function(t) {
                            return e.onMouseOut(t)
                        }, this._onMouseOver = function(t) {
                            return e.onMouseOver(t)
                        }, this._onMouseWheel = function(t) {
                            return e.onMouseWheel(t)
                        };
                        var t = this.game.canvas;
                        t.addEventListener("mousedown", this._onMouseDown, !0), t.addEventListener("mousemove", this._onMouseMove, !0), t.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), t.addEventListener("mouseover", this._onMouseOver, !0), t.addEventListener("mouseout", this._onMouseOut, !0));
                        var i = this.game.device.wheelEvent;
                        i && (t.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new o(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new o(1, 1)))
                    }
                },
                onMouseDown: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                },
                onMouseMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                },
                onMouseUp: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseUpGlobal: function(t) {
                    this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseOutGlobal: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
                },
                onMouseOut: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseOver: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
                },
                onMouseWheel: function(t) {
                    this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = U.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                },
                requestPointerLock: function() {
                    if (this.game.device.pointerLock) {
                        var t = this.game.canvas;
                        t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                        var e = this;
                        this._pointerLockChange = function(t) {
                            return e.pointerLockChange(t)
                        }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                },
                pointerLockChange: function(t) {
                    var e = this.game.canvas;
                    document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                },
                releasePointerLock: function() {
                    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                    var e = this.game.device.wheelEvent;
                    e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            }, U.Mouse.prototype.constructor = U.Mouse, ((o.prototype = {}).constructor = o).prototype.bindEvent = function(t) {
                if (!o._stubsGenerated && t) {
                    var e = function(e) {
                        return function() {
                            var t = this.originalEvent[e];
                            return "function" != typeof t ? t : t.bind(this.originalEvent)
                        }
                    };
                    for (var i in t) i in o.prototype || Object.defineProperty(o.prototype, i, {
                        get: e(i)
                    });
                    o._stubsGenerated = !0
                }
                return this.originalEvent = t, this
            }, Object.defineProperties(o.prototype, {
                type: {
                    value: "wheel"
                },
                deltaMode: {
                    get: function() {
                        return this._deltaMode
                    }
                },
                deltaY: {
                    get: function() {
                        return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                    }
                },
                deltaX: {
                    get: function() {
                        return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                    }
                },
                deltaZ: {
                    value: 0
                }
            }), U.MSPointer = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !1, this.event = null, this.active = !1, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
            }, U.MSPointer.prototype = {
                start: function() {
                    if (!this.game.device.mspointer) return !1;
                    if (null !== this._onMSPointerDown) return !1;
                    var e = this;
                    this._onMSPointerDown = function(t) {
                        return e.onPointerDown(t)
                    }, this._onMSPointerMove = function(t) {
                        return e.onPointerMove(t)
                    }, this._onMSPointerUp = function(t) {
                        return e.onPointerUp(t)
                    }, this._onMSPointerUpGlobal = function(t) {
                        return e.onPointerUpGlobal(t)
                    }, this._onMSPointerOut = function(t) {
                        return e.onPointerOut(t)
                    }, this._onMSPointerOver = function(t) {
                        return e.onPointerOver(t)
                    };
                    var t = this.game.canvas;
                    return t.addEventListener("MSPointerDown", this._onMSPointerDown, !1), t.addEventListener("MSPointerMove", this._onMSPointerMove, !1), t.addEventListener("MSPointerUp", this._onMSPointerUp, !1), t.addEventListener("pointerdown", this._onMSPointerDown, !1), t.addEventListener("pointermove", this._onMSPointerMove, !1), t.addEventListener("pointerup", this._onMSPointerUp, !1), t.style["-ms-content-zooming"] = "none", t.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.addEventListener("MSPointerOver", this._onMSPointerOver, !0), t.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.addEventListener("pointerover", this._onMSPointerOver, !0), t.addEventListener("pointerout", this._onMSPointerOut, !0)), this.active = !0
                },
                onPointerDown: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                },
                onPointerMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                },
                onPointerUp: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                },
                onPointerUpGlobal: function(t) {
                    if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && e.withinGame && this.onPointerUp(t)
                    } else this.onPointerUp(t)
                },
                onPointerOut: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !1)
                    }
                    this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
                },
                onPointerOver: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !0)
                    }
                    this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0), this.active = !1
                }
            }, U.MSPointer.prototype.constructor = U.MSPointer, U.DeviceButton = function(t, e) {
                this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new U.Signal, this.onUp = new U.Signal, this.onFloat = new U.Signal
            }, U.DeviceButton.prototype = {
                start: function(t, e) {
                    this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                },
                stop: function(t, e) {
                    this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                },
                padFloat: function(t) {
                    this.value = t, this.onFloat.dispatch(this, t)
                },
                justPressed: function(t) {
                    return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                },
                reset: function() {
                    this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                },
                destroy: function() {
                    this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                }
            }, U.DeviceButton.prototype.constructor = U.DeviceButton, Object.defineProperty(U.DeviceButton.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), U.Pointer = function(t, e, i) {
                this.game = t, this.id = e, this.type = U.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || U.PointerMode.CURSOR | U.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new U.DeviceButton(this, U.Pointer.LEFT_BUTTON), this.middleButton = new U.DeviceButton(this, U.Pointer.MIDDLE_BUTTON), this.rightButton = new U.DeviceButton(this, U.Pointer.RIGHT_BUTTON), this.backButton = new U.DeviceButton(this, U.Pointer.BACK_BUTTON), this.forwardButton = new U.DeviceButton(this, U.Pointer.FORWARD_BUTTON), this.eraserButton = new U.DeviceButton(this, U.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new U.Point, this.positionDown = new U.Point, this.positionUp = new U.Point, this.circle = new U.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
            }, U.Pointer.NO_BUTTON = 0, U.Pointer.LEFT_BUTTON = 1, U.Pointer.RIGHT_BUTTON = 2, U.Pointer.MIDDLE_BUTTON = 4, U.Pointer.BACK_BUTTON = 8, U.Pointer.FORWARD_BUTTON = 16, U.Pointer.ERASER_BUTTON = 32, U.Pointer.prototype = {
                resetButtons: function() {
                    this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                },
                processButtonsDown: function(t, e) {
                    U.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), U.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), U.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), U.Pointer.BACK_BUTTON & t && this.backButton.start(e), U.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), U.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
                },
                processButtonsUp: function(t, e) {
                    t === U.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === U.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === U.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === U.Mouse.BACK_BUTTON && this.backButton.stop(e), t === U.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
                },
                updateButtons: function(t) {
                    this.button = t.button;
                    var e = "down" === t.type.toLowerCase().substr(-4);
                    void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                },
                start: function(t) {
                    var e = this.game.input;
                    return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === U.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === U.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === U.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                },
                update: function() {
                    var t = this.game.input;
                    this.active && (this.dirty && (0 < t.interactiveItems.total && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === U.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === U.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === U.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    }), this._history.length > t.recordLimit && this._history.shift()))
                },
                move: function(t, e) {
                    var i = this.game.input;
                    if (!i.pollLocked) {
                        void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === U.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === U.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === U.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                        for (var o = i.moveCallbacks.length; o--;) i.moveCallbacks[o].callback.call(i.moveCallbacks[o].context, this, this.x, this.y, e);
                        return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : 0 < i.interactiveItems.total && this.processInteractiveObjects(e), this
                    }
                },
                processInteractiveObjects: function(t) {
                    var e = 0,
                        i = -1,
                        o = null,
                        s = this.game.input.interactiveItems.first;
                    for (this.interactiveCandidates = []; s;) s.checked = !1, s.validForInput(i, e, !1) && (s.checked = !0, (t && s.checkPointerDown(this, !0) || !t && s.checkPointerOver(this, !0)) && (e = s.sprite.renderOrderID, i = s.priorityID, o = s, this.interactiveCandidates.push(s))), s = this.game.input.interactiveItems.next;
                    for (s = this.game.input.interactiveItems.first; s;) !s.checked && s.validForInput(i, e, !0) && (t && s.checkPointerDown(this, !1) || !t && s.checkPointerOver(this, !1)) && (e = s.sprite.renderOrderID, i = s.priorityID, o = s, this.interactiveCandidates.push(s)), s = this.game.input.interactiveItems.next;
                    return this.game.input.customCandidateHandler && (o = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, o)), this.swapTarget(o, !1), null !== this.targetObject
                },
                swapTarget: function(t, e) {
                    void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t)._pointerOverHandler(this, e) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                },
                leave: function(t) {
                    this.withinGame = !1, this.move(t, !1)
                },
                stop: function(t) {
                    var e = this.game.input;
                    if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === U.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === U.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === U.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), 0 <= this.duration && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), 0 < this.id && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                    t.preventDefault()
                },
                justPressed: function(t) {
                    return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                },
                addClickTrampoline: function(t, e, i, o) {
                    if (this.isDown) {
                        for (var s = this._clickTrampolines = this._clickTrampolines || [], n = 0; n < s.length; n++)
                            if (s[n].name === t) {
                                s.splice(n, 1);
                                break
                            }
                        s.push({
                            name: t,
                            targetObject: this.targetObject,
                            callback: e,
                            callbackContext: i,
                            callbackArgs: o
                        })
                    }
                },
                processClickTrampolines: function() {
                    var t = this._clickTrampolines;
                    if (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                        }
                        this._clickTrampolines = null, this._trampolineTargetObject = null
                    }
                },
                reset: function() {
                    !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                },
                resetMovement: function() {
                    this.movementX = 0, this.movementY = 0
                }
            }, U.Pointer.prototype.constructor = U.Pointer, Object.defineProperty(U.Pointer.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), Object.defineProperty(U.Pointer.prototype, "worldX", {
                get: function() {
                    return this.game.world.camera.x + this.x
                }
            }), Object.defineProperty(U.Pointer.prototype, "worldY", {
                get: function() {
                    return this.game.world.camera.y + this.y
                }
            }), U.PointerMode = {
                CURSOR: 1,
                CONTACT: 2
            }, U.Touch = function(t) {
                this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
            }, U.Touch.prototype = {
                start: function() {
                    if (null === this._onTouchStart) {
                        var e = this;
                        this.game.device.touch && (this._onTouchStart = function(t) {
                            return e.onTouchStart(t)
                        }, this._onTouchMove = function(t) {
                            return e.onTouchMove(t)
                        }, this._onTouchEnd = function(t) {
                            return e.onTouchEnd(t)
                        }, this._onTouchEnter = function(t) {
                            return e.onTouchEnter(t)
                        }, this._onTouchLeave = function(t) {
                            return e.onTouchLeave(t)
                        }, this._onTouchCancel = function(t) {
                            return e.onTouchCancel(t)
                        }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                    }
                },
                consumeDocumentTouches: function() {
                    this._documentTouchMove = function(t) {
                        t.preventDefault()
                    }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                },
                addTouchLockCallback: function(t, e, i) {
                    void 0 === i && (i = !1), this.touchLockCallbacks.push({
                        callback: t,
                        context: e,
                        onEnd: i
                    })
                },
                removeTouchLockCallback: function(t, e) {
                    for (var i = this.touchLockCallbacks.length; i--;)
                        if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                    return !1
                },
                onTouchStart: function(t) {
                    for (var e = this.touchLockCallbacks.length; e--;) {
                        var i = this.touchLockCallbacks[e];
                        !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                    }
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                    }
                },
                onTouchCancel: function(t) {
                    if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                        this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    }
                },
                onTouchEnter: function(t) {
                    this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                },
                onTouchLeave: function(t) {
                    this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                },
                onTouchMove: function(t) {
                    this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                },
                onTouchEnd: function(t) {
                    for (var e = this.touchLockCallbacks.length; e--;) {
                        var i = this.touchLockCallbacks[e];
                        i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                    }
                    this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                },
                stop: function() {
                    this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                }
            }, U.Touch.prototype.constructor = U.Touch, U.InputHandler = function(t) {
                this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new U.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new U.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new U.Point, this.snapPoint = new U.Point, this._dragPoint = new U.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new U.Point, this._pointerData = [], this._pointerData.push({
                    id: 0,
                    x: 0,
                    y: 0,
                    camX: 0,
                    camY: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                })
            }, U.InputHandler.prototype = {
                start: function(t, e) {
                    if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                        this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                        for (var i = 0; i < 10; i++) this._pointerData[i] = {
                            id: i,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        };
                        this.snapOffset = new U.Point, this.enabled = !0, this._wasEnabled = !0
                    }
                    return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                },
                addedToGroup: function() {
                    this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                },
                removedFromGroup: function() {
                    this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                },
                reset: function() {
                    this.enabled = !1;
                    for (var t = 0; t < 10; t++) this._pointerData[t] = {
                        id: t,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    }
                },
                stop: function() {
                    !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                },
                destroy: function() {
                    this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                },
                validForInput: function(t, e, i) {
                    return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                },
                isPixelPerfect: function() {
                    return this.pixelPerfectClick || this.pixelPerfectOver
                },
                pointerX: function(t) {
                    return t = t || 0, this._pointerData[t].x
                },
                pointerY: function(t) {
                    return t = t || 0, this._pointerData[t].y
                },
                pointerDown: function(t) {
                    return t = t || 0, this._pointerData[t].isDown
                },
                pointerUp: function(t) {
                    return t = t || 0, this._pointerData[t].isUp
                },
                pointerTimeDown: function(t) {
                    return t = t || 0, this._pointerData[t].timeDown
                },
                pointerTimeUp: function(t) {
                    return t = t || 0, this._pointerData[t].timeUp
                },
                pointerOver: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOver;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0;
                    return !1
                },
                pointerOut: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOut;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOut) return !0
                },
                pointerTimeOver: function(t) {
                    return t = t || 0, this._pointerData[t].timeOver
                },
                pointerTimeOut: function(t) {
                    return t = t || 0, this._pointerData[t].timeOut
                },
                pointerDragged: function(t) {
                    return t = t || 0, this._pointerData[t].isDragged
                },
                checkPointerDown: function(t, e) {
                    return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                },
                checkPointerOver: function(t, e) {
                    return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                },
                checkPixel: function(t, e, i) {
                    if (this.sprite.texture.baseTexture.source) {
                        if (null === t && null === e) {
                            this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                            t = this._tempPoint.x, e = this._tempPoint.y
                        }
                        if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                        if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                    }
                    return !1
                },
                update: function(t) {
                    if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = U.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                },
                _pointerOverHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        if (!1 === i.isOver || t.dirty) {
                            var o = !1 === i.isOver;
                            i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && o && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === U.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                        }
                    }
                },
                _pointerOutHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === U.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                    }
                },
                _touchedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (!e.isDown && e.isOver) {
                            if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                            if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === U.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                            this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, 0 < this.dragTimeThreshold ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                        }
                    }
                },
                dragTimeElapsed: function(t) {
                    this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                },
                _releasedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (e.isDown && t.isUp) {
                            e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                            var i = this.checkPointerOver(t);
                            this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.type === U.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), !(e.isOver = i) && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                        }
                    }
                },
                updateDrag: function(t, e) {
                    if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                    var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                        o = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                    if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = o), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                    else {
                        var s = this.game.camera.x - this._pointerData[t.id].camX,
                            n = this.game.camera.y - this._pointerData[t.id].camY;
                        this.allowHorizontalDrag && (this.sprite.x = i + s), this.allowVerticalDrag && (this.sprite.y = o + n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                    }
                    return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, o, this.snapPoint, e), !0
                },
                justOver: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                },
                justOut: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                },
                justPressed: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                },
                justReleased: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                },
                overDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                },
                downDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                },
                enableDrag: function(t, e, i, o, s, n) {
                    void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === o && (o = 255), void 0 === s && (s = null), void 0 === n && (n = null), this._dragPoint = new U.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new U.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = o, s && (this.boundsRect = s), n && (this.boundsSprite = n)
                },
                disableDrag: function() {
                    if (this._pointerData)
                        for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                    this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                },
                startDrag: function(t) {
                    var e = this.sprite.x,
                        i = this.sprite.y;
                    if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                        if (this.dragFromCenter) {
                            var o = this.sprite.getBounds();
                            this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - o.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - o.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                    } else {
                        if (this.dragFromCenter) {
                            o = this.sprite.getBounds();
                            this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - o.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - o.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                    }
                    this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
                },
                globalToLocalX: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                },
                globalToLocalY: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                },
                stopDrag: function(t) {
                    this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                },
                setDragLock: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                },
                enableSnap: function(t, e, i, o, s, n) {
                    void 0 === i && (i = !0), void 0 === o && (o = !1), void 0 === s && (s = 0), void 0 === n && (n = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = s, this.snapOffsetY = n, this.snapOnDrag = i, this.snapOnRelease = o
                },
                disableSnap: function() {
                    this.snapOnDrag = !1, this.snapOnRelease = !1
                },
                checkBoundsRect: function() {
                    this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                },
                checkBoundsSprite: function() {
                    this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                }
            }, U.InputHandler.prototype.constructor = U.InputHandler, U.Gamepad = function(t) {
                this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new U.SinglePad(t, this), new U.SinglePad(t, this), new U.SinglePad(t, this), new U.SinglePad(t, this)]
            }, U.Gamepad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                start: function() {
                    if (!this._active) {
                        this._active = !0;
                        var e = this;
                        this._onGamepadConnected = function(t) {
                            return e.onGamepadConnected(t)
                        }, this._onGamepadDisconnected = function(t) {
                            return e.onGamepadDisconnected(t)
                        }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                    }
                },
                onGamepadConnected: function(t) {
                    var e = t.gamepad;
                    this._rawPads.push(e), this._gamepads[e.index].connect(e)
                },
                onGamepadDisconnected: function(t) {
                    var e = t.gamepad;
                    for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                    this._gamepads[e.index].disconnect()
                },
                update: function() {
                    this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                },
                _pollGamepads: function() {
                    if (this._active) {
                        if (navigator.getGamepads) var t = navigator.getGamepads();
                        else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                        else if (navigator.webkitGamepads) t = navigator.webkitGamepads();
                        if (t) {
                            for (var e = !(this._rawPads = []), i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                            for (var o = 0; o < this._gamepads.length; o++) this._gamepads[o]._rawPad = this._rawPads[o];
                            if (e) {
                                for (var s, n = {
                                        rawIndices: {},
                                        padIndices: {}
                                    }, r = 0; r < this._gamepads.length; r++)
                                    if ((s = this._gamepads[r]).connected)
                                        for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === s.index && (n.rawIndices[s.index] = !0, n.padIndices[r] = !0);
                                for (var h = 0; h < this._gamepads.length; h++)
                                    if (s = this._gamepads[h], !n.padIndices[h]) {
                                        this._rawPads.length < 1 && s.disconnect();
                                        for (var l = 0; l < this._rawPads.length && !n.padIndices[h]; l++) {
                                            var d = this._rawPads[l];
                                            if (d) {
                                                if (n.rawIndices[d.index]) {
                                                    s.disconnect();
                                                    continue
                                                }
                                                s.connect(d), n.rawIndices[d.index] = !0, n.padIndices[h] = !0
                                            } else s.disconnect()
                                        }
                                    }
                            }
                        }
                    }
                },
                setDeadZones: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                },
                stop: function() {
                    this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                },
                reset: function() {
                    this.update();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                },
                justPressed: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                    return !1
                },
                justReleased: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                    return !1
                },
                isDown: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++)
                        if (!0 === this._gamepads[e].isDown(t)) return !0;
                    return !1
                },
                destroy: function() {
                    this.stop();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                }
            }, U.Gamepad.prototype.constructor = U.Gamepad, Object.defineProperty(U.Gamepad.prototype, "active", {
                get: function() {
                    return this._active
                }
            }), Object.defineProperty(U.Gamepad.prototype, "supported", {
                get: function() {
                    return this._gamepadSupportAvailable
                }
            }), Object.defineProperty(U.Gamepad.prototype, "padsConnected", {
                get: function() {
                    return this._rawPads.length
                }
            }), Object.defineProperty(U.Gamepad.prototype, "pad1", {
                get: function() {
                    return this._gamepads[0]
                }
            }), Object.defineProperty(U.Gamepad.prototype, "pad2", {
                get: function() {
                    return this._gamepads[1]
                }
            }), Object.defineProperty(U.Gamepad.prototype, "pad3", {
                get: function() {
                    return this._gamepads[2]
                }
            }), Object.defineProperty(U.Gamepad.prototype, "pad4", {
                get: function() {
                    return this._gamepads[3]
                }
            }), U.Gamepad.BUTTON_0 = 0, U.Gamepad.BUTTON_1 = 1, U.Gamepad.BUTTON_2 = 2, U.Gamepad.BUTTON_3 = 3, U.Gamepad.BUTTON_4 = 4, U.Gamepad.BUTTON_5 = 5, U.Gamepad.BUTTON_6 = 6, U.Gamepad.BUTTON_7 = 7, U.Gamepad.BUTTON_8 = 8, U.Gamepad.BUTTON_9 = 9, U.Gamepad.BUTTON_10 = 10, U.Gamepad.BUTTON_11 = 11, U.Gamepad.BUTTON_12 = 12, U.Gamepad.BUTTON_13 = 13, U.Gamepad.BUTTON_14 = 14, U.Gamepad.BUTTON_15 = 15, U.Gamepad.AXIS_0 = 0, U.Gamepad.AXIS_1 = 1, U.Gamepad.AXIS_2 = 2, U.Gamepad.AXIS_3 = 3, U.Gamepad.AXIS_4 = 4, U.Gamepad.AXIS_5 = 5, U.Gamepad.AXIS_6 = 6, U.Gamepad.AXIS_7 = 7, U.Gamepad.AXIS_8 = 8, U.Gamepad.AXIS_9 = 9, U.Gamepad.XBOX360_A = 0, U.Gamepad.XBOX360_B = 1, U.Gamepad.XBOX360_X = 2, U.Gamepad.XBOX360_Y = 3, U.Gamepad.XBOX360_LEFT_BUMPER = 4, U.Gamepad.XBOX360_RIGHT_BUMPER = 5, U.Gamepad.XBOX360_LEFT_TRIGGER = 6, U.Gamepad.XBOX360_RIGHT_TRIGGER = 7, U.Gamepad.XBOX360_BACK = 8, U.Gamepad.XBOX360_START = 9, U.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, U.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, U.Gamepad.XBOX360_DPAD_LEFT = 14, U.Gamepad.XBOX360_DPAD_RIGHT = 15, U.Gamepad.XBOX360_DPAD_UP = 12, U.Gamepad.XBOX360_DPAD_DOWN = 13, U.Gamepad.XBOX360_STICK_LEFT_X = 0, U.Gamepad.XBOX360_STICK_LEFT_Y = 1, U.Gamepad.XBOX360_STICK_RIGHT_X = 2, U.Gamepad.XBOX360_STICK_RIGHT_Y = 3, U.Gamepad.PS3XC_X = 0, U.Gamepad.PS3XC_CIRCLE = 1, U.Gamepad.PS3XC_SQUARE = 2, U.Gamepad.PS3XC_TRIANGLE = 3, U.Gamepad.PS3XC_L1 = 4, U.Gamepad.PS3XC_R1 = 5, U.Gamepad.PS3XC_L2 = 6, U.Gamepad.PS3XC_R2 = 7, U.Gamepad.PS3XC_SELECT = 8, U.Gamepad.PS3XC_START = 9, U.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, U.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, U.Gamepad.PS3XC_DPAD_UP = 12, U.Gamepad.PS3XC_DPAD_DOWN = 13, U.Gamepad.PS3XC_DPAD_LEFT = 14, U.Gamepad.PS3XC_DPAD_RIGHT = 15, U.Gamepad.PS3XC_STICK_LEFT_X = 0, U.Gamepad.PS3XC_STICK_LEFT_Y = 1, U.Gamepad.PS3XC_STICK_RIGHT_X = 2, U.Gamepad.PS3XC_STICK_RIGHT_Y = 3, U.SinglePad = function(t, e) {
                this.game = t, this.index = null, this.connected = !1, (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
            }, U.SinglePad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                getButton: function(t) {
                    return this._buttons[t] ? this._buttons[t] : null
                },
                pollStatus: function() {
                    if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                        for (var t = 0; t < this._buttonsLen; t++) {
                            var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                            e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                        }
                        for (var i = 0; i < this._axesLen; i++) {
                            var o = this._rawPad.axes[i];
                            0 < o && o > this.deadZone || o < 0 && o < -this.deadZone ? this.processAxisChange(i, o) : this.processAxisChange(i, 0)
                        }
                        this._prevTimestamp = this._rawPad.timestamp
                    }
                },
                connect: function(t) {
                    var e = !this.connected;
                    this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                    for (var i = 0; i < this._axesLen; i++) this._axes[i] = t.axes[i];
                    for (var o in t.buttons) o = parseInt(o, 10), this._buttons[o] = new U.DeviceButton(this, o);
                    e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                },
                disconnect: function() {
                    var t = this.connected,
                        e = this.index;
                    this.connected = !1, this.index = null, this._rawPad = void 0;
                    for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                },
                destroy: function() {
                    this._rawPad = void 0;
                    for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                },
                processAxisChange: function(t, e) {
                    this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                },
                processButtonDown: function(t, e) {
                    this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                },
                processButtonUp: function(t, e) {
                    this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                },
                processButtonFloat: function(t, e) {
                    this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                },
                axis: function(t) {
                    return !!this._axes[t] && this._axes[t]
                },
                isDown: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isDown
                },
                isUp: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isUp
                },
                justReleased: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justReleased(e)
                },
                justPressed: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justPressed(e)
                },
                buttonValue: function(t) {
                    return this._buttons[t] ? this._buttons[t].value : null
                },
                reset: function() {
                    for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                }
            }, U.SinglePad.prototype.constructor = U.SinglePad, U.Key = function(t, e) {
                this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new U.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new U.Signal, this._justDown = !1, this._justUp = !1
            }, U.Key.prototype = {
                update: function() {
                    this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                },
                processKeyDown: function(t) {
                    this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                },
                processKeyUp: function(t) {
                    this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                },
                downDuration: function(t) {
                    return void 0 === t && (t = 50), this.isDown && this.duration < t
                },
                upDuration: function(t) {
                    return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                }
            }, Object.defineProperty(U.Key.prototype, "justDown", {
                get: function() {
                    var t = this._justDown;
                    return this._justDown = !1, t
                }
            }), Object.defineProperty(U.Key.prototype, "justUp", {
                get: function() {
                    var t = this._justUp;
                    return this._justUp = !1, t
                }
            }), Object.defineProperty(U.Key.prototype, "enabled", {
                get: function() {
                    return this._enabled
                },
                set: function(t) {
                    (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                }
            }), U.Key.prototype.constructor = U.Key, U.Keyboard = function(t) {
                this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, (this.callbackContext = this).onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
            }, U.Keyboard.prototype = {
                addCallbacks: function(t, e, i, o) {
                    this.callbackContext = t, null != e && (this.onDownCallback = e), null != i && (this.onUpCallback = i), null != o && (this.onPressCallback = o)
                },
                addKey: function(t) {
                    return this._keys[t] || (this._keys[t] = new U.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                },
                addKeys: function(t) {
                    var e = {};
                    for (var i in t) e[i] = this.addKey(t[i]);
                    return e
                },
                removeKey: function(t) {
                    this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                },
                createCursorKeys: function() {
                    return this.addKeys({
                        up: U.KeyCode.UP,
                        down: U.KeyCode.DOWN,
                        left: U.KeyCode.LEFT,
                        right: U.KeyCode.RIGHT
                    })
                },
                start: function() {
                    if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                        var e = this;
                        this._onKeyDown = function(t) {
                            return e.processKeyDown(t)
                        }, this._onKeyUp = function(t) {
                            return e.processKeyUp(t)
                        }, this._onKeyPress = function(t) {
                            return e.processKeyPress(t)
                        }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                    }
                },
                stop: function() {
                    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                },
                destroy: function() {
                    this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                },
                addKeyCapture: function(t) {
                    if ("object" == typeof t)
                        for (var e in t) this._capture[t[e]] = !0;
                    else this._capture[t] = !0
                },
                removeKeyCapture: function(t) {
                    delete this._capture[t]
                },
                clearCaptures: function() {
                    this._capture = {}
                },
                update: function() {
                    for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                },
                processKeyDown: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new U.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                    }
                },
                processKeyPress: function(t) {
                    this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                },
                processKeyUp: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new U.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                    }
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.event = null;
                    for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                },
                downDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].downDuration(e) : null
                },
                upDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].upDuration(e) : null
                },
                isDown: function(t) {
                    return this._keys[t] ? this._keys[t].isDown : null
                }
            }, Object.defineProperty(U.Keyboard.prototype, "lastChar", {
                get: function() {
                    return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                }
            }), Object.defineProperty(U.Keyboard.prototype, "lastKey", {
                get: function() {
                    return this._keys[this._k]
                }
            }), U.Keyboard.prototype.constructor = U.Keyboard, U.KeyCode = {
                A: "A".charCodeAt(0),
                B: "B".charCodeAt(0),
                C: "C".charCodeAt(0),
                D: "D".charCodeAt(0),
                E: "E".charCodeAt(0),
                F: "F".charCodeAt(0),
                G: "G".charCodeAt(0),
                H: "H".charCodeAt(0),
                I: "I".charCodeAt(0),
                J: "J".charCodeAt(0),
                K: "K".charCodeAt(0),
                L: "L".charCodeAt(0),
                M: "M".charCodeAt(0),
                N: "N".charCodeAt(0),
                O: "O".charCodeAt(0),
                P: "P".charCodeAt(0),
                Q: "Q".charCodeAt(0),
                R: "R".charCodeAt(0),
                S: "S".charCodeAt(0),
                T: "T".charCodeAt(0),
                U: "U".charCodeAt(0),
                V: "V".charCodeAt(0),
                W: "W".charCodeAt(0),
                X: "X".charCodeAt(0),
                Y: "Y".charCodeAt(0),
                Z: "Z".charCodeAt(0),
                ZERO: "0".charCodeAt(0),
                ONE: "1".charCodeAt(0),
                TWO: "2".charCodeAt(0),
                THREE: "3".charCodeAt(0),
                FOUR: "4".charCodeAt(0),
                FIVE: "5".charCodeAt(0),
                SIX: "6".charCodeAt(0),
                SEVEN: "7".charCodeAt(0),
                EIGHT: "8".charCodeAt(0),
                NINE: "9".charCodeAt(0),
                NUMPAD_0: 96,
                NUMPAD_1: 97,
                NUMPAD_2: 98,
                NUMPAD_3: 99,
                NUMPAD_4: 100,
                NUMPAD_5: 101,
                NUMPAD_6: 102,
                NUMPAD_7: 103,
                NUMPAD_8: 104,
                NUMPAD_9: 105,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_ADD: 107,
                NUMPAD_ENTER: 108,
                NUMPAD_SUBTRACT: 109,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                F13: 124,
                F14: 125,
                F15: 126,
                COLON: 186,
                EQUALS: 187,
                COMMA: 188,
                UNDERSCORE: 189,
                PERIOD: 190,
                QUESTION_MARK: 191,
                TILDE: 192,
                OPEN_BRACKET: 219,
                BACKWARD_SLASH: 220,
                CLOSED_BRACKET: 221,
                QUOTES: 222,
                BACKSPACE: 8,
                TAB: 9,
                CLEAR: 12,
                ENTER: 13,
                SHIFT: 16,
                CONTROL: 17,
                ALT: 18,
                CAPS_LOCK: 20,
                ESC: 27,
                SPACEBAR: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                PLUS: 43,
                MINUS: 44,
                INSERT: 45,
                DELETE: 46,
                HELP: 47,
                NUM_LOCK: 144
            }, U.KeyCode) U.KeyCode.hasOwnProperty(i) && !i.match(/[a-z]/) && (U.Keyboard[i] = U.KeyCode[i]);
        for (var s in U.Component = function() {}, U.Component.Angle = function() {}, U.Component.Angle.prototype = {
                angle: {
                    get: function() {
                        return U.Math.wrapAngle(U.Math.radToDeg(this.rotation))
                    },
                    set: function(t) {
                        this.rotation = U.Math.degToRad(U.Math.wrapAngle(t))
                    }
                }
            }, U.Component.Animation = function() {}, U.Component.Animation.prototype = {
                play: function(t, e, i, o) {
                    if (this.animations) return this.animations.play(t, e, i, o)
                }
            }, U.Component.AutoCull = function() {}, U.Component.AutoCull.prototype = {
                autoCull: !1,
                inCamera: {
                    get: function() {
                        return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                    }
                }
            }, U.Component.Bounds = function() {}, U.Component.Bounds.prototype = {
                offsetX: {
                    get: function() {
                        return this.anchor.x * this.width
                    }
                },
                offsetY: {
                    get: function() {
                        return this.anchor.y * this.height
                    }
                },
                centerX: {
                    get: function() {
                        return this.x - this.offsetX + .5 * this.width
                    },
                    set: function(t) {
                        this.x = t + this.offsetX - .5 * this.width
                    }
                },
                centerY: {
                    get: function() {
                        return this.y - this.offsetY + .5 * this.height
                    },
                    set: function(t) {
                        this.y = t + this.offsetY - .5 * this.height
                    }
                },
                left: {
                    get: function() {
                        return this.x - this.offsetX
                    },
                    set: function(t) {
                        this.x = t + this.offsetX
                    }
                },
                right: {
                    get: function() {
                        return this.x + this.width - this.offsetX
                    },
                    set: function(t) {
                        this.x = t - this.width + this.offsetX
                    }
                },
                top: {
                    get: function() {
                        return this.y - this.offsetY
                    },
                    set: function(t) {
                        this.y = t + this.offsetY
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this.height - this.offsetY
                    },
                    set: function(t) {
                        this.y = t - this.height + this.offsetY
                    }
                },
                alignIn: function(t, e, i, o) {
                    switch (void 0 === i && (i = 0), void 0 === o && (o = 0), e) {
                        default:
                            case U.TOP_LEFT:
                            this.left = t.left - i,
                        this.top = t.top - o;
                        break;
                        case U.TOP_CENTER:
                                this.centerX = t.centerX + i,
                            this.top = t.top - o;
                            break;
                        case U.TOP_RIGHT:
                                this.right = t.right + i,
                            this.top = t.top - o;
                            break;
                        case U.LEFT_CENTER:
                                this.left = t.left - i,
                            this.centerY = t.centerY + o;
                            break;
                        case U.CENTER:
                                this.centerX = t.centerX + i,
                            this.centerY = t.centerY + o;
                            break;
                        case U.RIGHT_CENTER:
                                this.right = t.right + i,
                            this.centerY = t.centerY + o;
                            break;
                        case U.BOTTOM_LEFT:
                                this.left = t.left - i,
                            this.bottom = t.bottom + o;
                            break;
                        case U.BOTTOM_CENTER:
                                this.centerX = t.centerX + i,
                            this.bottom = t.bottom + o;
                            break;
                        case U.BOTTOM_RIGHT:
                                this.right = t.right + i,
                            this.bottom = t.bottom + o
                    }
                    return this
                },
                alignTo: function(t, e, i, o) {
                    switch (void 0 === i && (i = 0), void 0 === o && (o = 0), e) {
                        default:
                            case U.TOP_LEFT:
                            this.left = t.left - i,
                        this.bottom = t.top - o;
                        break;
                        case U.TOP_CENTER:
                                this.centerX = t.centerX + i,
                            this.bottom = t.top - o;
                            break;
                        case U.TOP_RIGHT:
                                this.right = t.right + i,
                            this.bottom = t.top - o;
                            break;
                        case U.LEFT_TOP:
                                this.right = t.left - i,
                            this.top = t.top - o;
                            break;
                        case U.LEFT_CENTER:
                                this.right = t.left - i,
                            this.centerY = t.centerY + o;
                            break;
                        case U.LEFT_BOTTOM:
                                this.right = t.left - i,
                            this.bottom = t.bottom + o;
                            break;
                        case U.RIGHT_TOP:
                                this.left = t.right + i,
                            this.top = t.top - o;
                            break;
                        case U.RIGHT_CENTER:
                                this.left = t.right + i,
                            this.centerY = t.centerY + o;
                            break;
                        case U.RIGHT_BOTTOM:
                                this.left = t.right + i,
                            this.bottom = t.bottom + o;
                            break;
                        case U.BOTTOM_LEFT:
                                this.left = t.left - i,
                            this.top = t.bottom + o;
                            break;
                        case U.BOTTOM_CENTER:
                                this.centerX = t.centerX + i,
                            this.top = t.bottom + o;
                            break;
                        case U.BOTTOM_RIGHT:
                                this.right = t.right + i,
                            this.top = t.bottom + o
                    }
                    return this
                }
            }, U.Group.prototype.alignIn = U.Component.Bounds.prototype.alignIn, U.Group.prototype.alignTo = U.Component.Bounds.prototype.alignTo, U.Component.BringToTop = function() {}, U.Component.BringToTop.prototype.bringToTop = function() {
                return this.parent && this.parent.bringToTop(this), this
            }, U.Component.BringToTop.prototype.sendToBack = function() {
                return this.parent && this.parent.sendToBack(this), this
            }, U.Component.BringToTop.prototype.moveUp = function() {
                return this.parent && this.parent.moveUp(this), this
            }, U.Component.BringToTop.prototype.moveDown = function() {
                return this.parent && this.parent.moveDown(this), this
            }, U.Component.Core = function() {}, U.Component.Core.install = function(t) {
                U.Utils.mixinPrototype(this, U.Component.Core.prototype), this.components = {};
                for (var e = 0; e < t.length; e++) {
                    var i = t[e],
                        o = !1;
                    "Destroy" === i && (o = !0), U.Utils.mixinPrototype(this, U.Component[i].prototype, o), this.components[i] = !0
                }
            }, U.Component.Core.init = function(t, e, i, o, s) {
                this.game = t, this.key = o, this.data = {}, this.position.set(e, i), this.world = new U.Point(e, i), this.previousPosition = new U.Point(e, i), this.events = new U.Events(this), this._bounds = new U.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new U.AnimationManager(this)), this.components.LoadTexture && null !== o && this.loadTexture(o, s), this.components.FixedToCamera && (this.cameraOffset = new U.Point(e, i))
            }, U.Component.Core.preUpdate = function() {
                if (!this.pendingDestroy) {
                    if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
                    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }
                this.destroy()
            }, U.Component.Core.prototype = {
                game: null,
                name: "",
                data: {},
                components: {},
                z: 0,
                events: void 0,
                animations: void 0,
                key: "",
                world: null,
                debug: !1,
                previousPosition: null,
                previousRotation: 0,
                renderOrderID: 0,
                fresh: !0,
                pendingDestroy: !1,
                _bounds: null,
                _exists: !0,
                exists: {
                    get: function() {
                        return this._exists
                    },
                    set: function(t) {
                        this.visible = t ? (this._exists = !0, this.body && this.body.type === U.Physics.P2JS && this.body.addToWorld(), !0) : (this._exists = !1, this.body && this.body.type === U.Physics.P2JS && this.body.removeFromWorld(), !1)
                    }
                },
                update: function() {},
                postUpdate: function() {
                    this.customRender && this.key.render(), this.components.PhysicsBody && U.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && U.Component.FixedToCamera.postUpdate.call(this);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }
            }, U.Component.Crop = function() {}, U.Component.Crop.prototype = {
                cropRect: null,
                _crop: null,
                crop: function(t, e) {
                    void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new U.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                },
                updateCrop: function() {
                    if (this.cropRect) {
                        var t = this.texture.crop.x,
                            e = this.texture.crop.y,
                            i = this.texture.crop.width,
                            o = this.texture.crop.height;
                        this._crop = U.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                        var s = Math.max(this._frame.x, this._crop.x),
                            n = Math.max(this._frame.y, this._crop.y),
                            r = Math.min(this._frame.right, this._crop.right) - s,
                            a = Math.min(this._frame.bottom, this._crop.bottom) - n;
                        this.texture.crop.x = s, this.texture.crop.y = n, this.texture.crop.width = r, this.texture.crop.height = a, this.texture.frame.width = Math.min(r, this.cropRect.width), this.texture.frame.height = Math.min(a, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === s && e === n && i === r && o === a || (this.texture.requiresReTint = !0)
                    }
                }
            }, U.Component.Delta = function() {}, U.Component.Delta.prototype = {
                deltaX: {
                    get: function() {
                        return this.world.x - this.previousPosition.x
                    }
                },
                deltaY: {
                    get: function() {
                        return this.world.y - this.previousPosition.y
                    }
                },
                deltaZ: {
                    get: function() {
                        return this.rotation - this.previousRotation
                    }
                }
            }, U.Component.Destroy = function() {}, U.Component.Destroy.prototype = {
                destroyPhase: !1,
                destroy: function(t, e) {
                    if (null !== this.game && !this.destroyPhase) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof U.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                        var i = this.children.length;
                        if (t)
                            for (; i--;) this.children[i].destroy(t);
                        else
                            for (; i--;) this.removeChild(this.children[i]);
                        this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), U.Video && this.key instanceof U.Video && this.key.onChangeSource.remove(this.resizeFrame, this), U.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                    }
                }
            }, U.Events = function(t) {
                this.parent = t
            }, U.Events.prototype = {
                destroy: function() {
                    this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                },
                onAddedToGroup: null,
                onRemovedFromGroup: null,
                onRemovedFromWorld: null,
                onDestroy: null,
                onKilled: null,
                onRevived: null,
                onOutOfBounds: null,
                onEnterBounds: null,
                onInputOver: null,
                onInputOut: null,
                onInputDown: null,
                onInputUp: null,
                onDragStart: null,
                onDragUpdate: null,
                onDragStop: null,
                onAnimationStart: null,
                onAnimationComplete: null,
                onAnimationLoop: null
            }, U.Events.prototype.constructor = U.Events, U.Events.prototype) U.Events.prototype.hasOwnProperty(s) && 0 === s.indexOf("on") && null === U.Events.prototype[s] && function(t, e) {
            "use strict";
            Object.defineProperty(U.Events.prototype, t, {
                get: function() {
                    return this[e] || (this[e] = new U.Signal)
                }
            }), U.Events.prototype[t + "$dispatch"] = function() {
                return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
            }
        }(s, "_" + s);
        U.Component.FixedToCamera = function() {}, U.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, U.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new U.Point
        }, U.Component.Health = function() {}, U.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, U.Component.InCamera = function() {}, U.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, U.Component.InputEnabled = function() {}, U.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new U.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, U.Component.InWorld = function() {}, U.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, U.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, U.Component.LifeSpan = function() {}, U.Component.LifeSpan.preUpdate = function() {
            return !(0 < this.lifespan && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
        }, U.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, U.Component.LoadTexture = function() {}, U.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, i) {
                e = t === U.PENDING_ATLAS ? (t = e, 0) : e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var o = this.game.cache,
                    s = !0,
                    n = !this.texture.baseTexture.scaleMode;
                if (U.RenderTexture && t instanceof U.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (U.BitmapData && t instanceof U.BitmapData) this.customRender = !0, this.setTexture(t.texture), s = o.hasFrameData(t.key, U.Cache.BITMAPDATA) ? !this.animations.loadFrameData(o.getFrameData(t.key, U.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (U.Video && t instanceof U.Video) {
                    this.customRender = !0;
                    var r = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = r
                } else if (U.Tilemap && t instanceof U.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else {
                    var a = o.getImage(t, !0);
                    this.key = a.key, this.setTexture(new PIXI.Texture(a.base)), this.texture.baseTexture.skipRender = "__default" === t, s = !this.animations.loadFrameData(a.frameData, e)
                }
                s && (this._frame = U.Rectangle.clone(this.texture.frame)), n || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, U.Component.Overlap = function() {}, U.Component.Overlap.prototype = {
            overlap: function(t) {
                return U.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, U.Component.PhysicsBody = function() {}, U.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || !(this.renderOrderID = -1))
        }, U.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, U.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, U.Component.Reset = function() {}, U.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, U.Component.ScaleMinMax = function() {}, U.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, i, o) {
                void 0 === e ? e = i = o = t : void 0 === i && (i = o = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new U.Point(t, e), null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, o) : this.scaleMax = new U.Point(i, o), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, U.Component.Smoothed = function() {}, U.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, U.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, U.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, e, i, o) {
                var s = this.game.plugins.add(U.Weapon);
                return s.createBullets(t, e, i, o), s
            },
            image: function(t, e, i, o, s) {
                return void 0 === s && (s = this.world), s.add(new U.Image(this.game, t, e, i, o))
            },
            sprite: function(t, e, i, o, s) {
                return void 0 === s && (s = this.world), s.create(t, e, i, o)
            },
            creature: function(t, e, i, o, s) {
                void 0 === s && (s = this.world);
                var n = new U.Creature(this.game, t, e, i, o);
                return s.add(n), n
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, e, i, o, s) {
                return new U.Group(this.game, t, e, i, o, s)
            },
            physicsGroup: function(t, e, i, o) {
                return new U.Group(this.game, e, i, o, !0, t)
            },
            spriteBatch: function(t, e, i) {
                return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === i && (i = !1), new U.SpriteBatch(this.game, t, e, i)
            },
            audio: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            sound: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, e, i, o, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new U.TileSprite(this.game, t, e, i, o, s, n))
            },
            rope: function(t, e, i, o, s, n) {
                return void 0 === n && (n = this.world), n.add(new U.Rope(this.game, t, e, i, o, s))
            },
            text: function(t, e, i, o, s) {
                return void 0 === s && (s = this.world), s.add(new U.Text(this.game, t, e, i, o))
            },
            button: function(t, e, i, o, s, n, r, a, h, l) {
                return void 0 === l && (l = this.world), l.add(new U.Button(this.game, t, e, i, o, s, n, r, a, h))
            },
            graphics: function(t, e, i) {
                return void 0 === i && (i = this.world), i.add(new U.Graphics(this.game, t, e))
            },
            emitter: function(t, e, i) {
                return this.game.particles.add(new U.Particles.Arcade.Emitter(this.game, t, e, i))
            },
            retroFont: function(t, e, i, o, s, n, r, a, h) {
                return new U.RetroFont(this.game, t, e, i, o, s, n, r, a, h)
            },
            bitmapText: function(t, e, i, o, s, n) {
                return void 0 === n && (n = this.world), n.add(new U.BitmapText(this.game, t, e, i, o, s))
            },
            tilemap: function(t, e, i, o, s) {
                return new U.Tilemap(this.game, t, e, i, o, s)
            },
            renderTexture: function(t, e, i, o) {
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === o && (o = !1);
                var s = new U.RenderTexture(this.game, t, e, i);
                return o && this.game.cache.addRenderTexture(i, s), s
            },
            video: function(t, e) {
                return new U.Video(this.game, t, e)
            },
            bitmapData: function(t, e, i, o) {
                void 0 === o && (o = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                var s = new U.BitmapData(this.game, i, t, e);
                return o && this.game.cache.addBitmapData(i, s), s
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new U.Filter[t](this.game)).init.apply(t, e), t
            },
            plugin: function(t) {
                return this.game.plugins.add(t)
            }
        }, U.GameObjectFactory.prototype.constructor = U.GameObjectFactory, U.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, U.GameObjectCreator.prototype = {
            image: function(t, e, i, o) {
                return new U.Image(this.game, t, e, i, o)
            },
            sprite: function(t, e, i, o) {
                return new U.Sprite(this.game, t, e, i, o)
            },
            tween: function(t) {
                return new U.Tween(t, this.game, this.game.tweens)
            },
            group: function(t, e, i, o, s) {
                return new U.Group(this.game, t, e, i, o, s)
            },
            spriteBatch: function(t, e, i) {
                return void 0 === e && (e = "group"), void 0 === i && (i = !1), new U.SpriteBatch(this.game, t, e, i)
            },
            audio: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            tileSprite: function(t, e, i, o, s, n) {
                return new U.TileSprite(this.game, t, e, i, o, s, n)
            },
            rope: function(t, e, i, o, s) {
                return new U.Rope(this.game, t, e, i, o, s)
            },
            text: function(t, e, i, o) {
                return new U.Text(this.game, t, e, i, o)
            },
            button: function(t, e, i, o, s, n, r, a, h) {
                return new U.Button(this.game, t, e, i, o, s, n, r, a, h)
            },
            graphics: function(t, e) {
                return new U.Graphics(this.game, t, e)
            },
            emitter: function(t, e, i) {
                return new U.Particles.Arcade.Emitter(this.game, t, e, i)
            },
            retroFont: function(t, e, i, o, s, n, r, a, h) {
                return new U.RetroFont(this.game, t, e, i, o, s, n, r, a, h)
            },
            bitmapText: function(t, e, i, o, s, n) {
                return new U.BitmapText(this.game, t, e, i, o, s, n)
            },
            tilemap: function(t, e, i, o, s) {
                return new U.Tilemap(this.game, t, e, i, o, s)
            },
            renderTexture: function(t, e, i, o) {
                void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === o && (o = !1);
                var s = new U.RenderTexture(this.game, t, e, i);
                return o && this.game.cache.addRenderTexture(i, s), s
            },
            bitmapData: function(t, e, i, o) {
                void 0 === o && (o = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                var s = new U.BitmapData(this.game, i, t, e);
                return o && this.game.cache.addBitmapData(i, s), s
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new U.Filter[t](this.game)).init.apply(t, e), t
            }
        }, U.GameObjectCreator.prototype.constructor = U.GameObjectCreator, U.Sprite = function(t, e, i, o, s) {
            e = e || 0, i = i || 0, o = o || null, s = s || null, this.type = U.SPRITE, this.physicsType = U.SPRITE, PIXI.Sprite.call(this, U.Cache.DEFAULT), U.Component.Core.init.call(this, t, e, i, o, s)
        }, U.Sprite.prototype = Object.create(PIXI.Sprite.prototype), U.Sprite.prototype.constructor = U.Sprite, U.Component.Core.install.call(U.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), U.Sprite.prototype.preUpdatePhysics = U.Component.PhysicsBody.preUpdate, U.Sprite.prototype.preUpdateLifeSpan = U.Component.LifeSpan.preUpdate, U.Sprite.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.Sprite.prototype.preUpdateCore = U.Component.Core.preUpdate, U.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.Image = function(t, e, i, o, s) {
            e = e || 0, i = i || 0, o = o || null, s = s || null, this.type = U.IMAGE, PIXI.Sprite.call(this, U.Cache.DEFAULT), U.Component.Core.init.call(this, t, e, i, o, s)
        }, U.Image.prototype = Object.create(PIXI.Sprite.prototype), U.Image.prototype.constructor = U.Image, U.Component.Core.install.call(U.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), U.Image.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.Image.prototype.preUpdateCore = U.Component.Core.preUpdate, U.Image.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && this.preUpdateCore()
        }, U.Button = function(t, e, i, o, s, n, r, a, h, l) {
            e = e || 0, i = i || 0, o = o || null, s = s || null, n = n || this, U.Image.call(this, t, e, i, o, a), this.type = U.BUTTON, this.physicsType = U.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new U.Signal, this.onInputOut = new U.Signal, this.onInputDown = new U.Signal, this.onInputUp = new U.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = U.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(r, a, h, l), null !== s && this.onInputUp.add(s, n), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, U.Button.prototype = Object.create(U.Image.prototype), U.Button.prototype.constructor = U.Button;
        var h = "Over",
            l = "Out",
            d = "Down",
            c = "Up";
        U.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, U.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, U.Button.prototype.setStateFrame = function(t, e, i) {
            var o = "_on" + t + "Frame";
            null !== e ? (this[o] = e, i && this.changeStateFrame(t)) : this[o] = null
        }, U.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
        }, U.Button.prototype.setFrames = function(t, e, i, o) {
            this.setStateFrame(h, t, this.input.pointerOver()), this.setStateFrame(l, e, !this.input.pointerOver()), this.setStateFrame(d, i, this.input.pointerDown()), this.setStateFrame(c, o, this.input.pointerUp())
        }, U.Button.prototype.setStateSound = function(t, e, i) {
            var o = "on" + t + "Sound",
                s = "on" + t + "SoundMarker";
            e instanceof U.Sound || e instanceof U.AudioSprite ? (this[o] = e, this[s] = "string" == typeof i ? i : "") : (this[o] = null, this[s] = "")
        }, U.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i), !0
            }
            return !1
        }, U.Button.prototype.setSounds = function(t, e, i, o, s, n, r, a) {
            this.setStateSound(h, t, e), this.setStateSound(l, s, n), this.setStateSound(d, i, o), this.setStateSound(c, r, a)
        }, U.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound(h, t, e)
        }, U.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound(l, t, e)
        }, U.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound(d, t, e)
        }, U.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound(c, t, e)
        }, U.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(h), this.onOverMouseOnly && !e.isMouse || (this.playStateSound(h), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, U.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame(l), this.playStateSound(l), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, U.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame(d), this.playStateSound(d), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, U.Button.prototype.onInputUpHandler = function(t, e, i) {
            (this.playStateSound(c), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames) || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame(l) : this.changeStateFrame(c) || (i ? this.changeStateFrame(h) : this.changeStateFrame(l)))
        }, U.SpriteBatch = function(t, e, i, o) {
            null == e && (e = t.world), PIXI.SpriteBatch.call(this), U.Group.call(this, t, e, i, o), this.type = U.SPRITEBATCH
        }, U.SpriteBatch.prototype = U.Utils.extend(!0, U.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, U.Group.prototype), U.SpriteBatch.prototype.constructor = U.SpriteBatch, U.BitmapData = function(t, e, i, o, s) {
            void 0 !== i && 0 !== i || (i = 256), void 0 !== o && 0 !== o || (o = 256), void 0 === s && (s = !1), this.game = t, this.key = e, this.width = i, this.height = o, this.canvas = U.Canvas.create(this, i, o, null, s), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = t.renderType === U.CANVAS ? t.renderer.renderSession.smoothProperty : U.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, i, o), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new U.FrameData, this.textureFrame = this.frameData.addFrame(new U.Frame(0, 0, 0, i, o, "bitmapData")), this.texture.frame = this.textureFrame, this.type = U.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new U.Point, this._size = new U.Point, this._scale = new U.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new U.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new U.Circle, this._swapCanvas = void 0
        }, U.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    o = this.height,
                    s = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var n = this.width - t;
                    e && i.drawImage(s, 0, 0, t, o, n, 0, t, o), i.drawImage(s, t, 0, n, o, 0, 0, n, o)
                } else {
                    n = this.width - t;
                    e && i.drawImage(s, n, 0, t, o, 0, 0, t, o), i.drawImage(s, 0, 0, n, o, t, 0, n, o)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    o = this.width,
                    s = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var n = this.height - t;
                    e && i.drawImage(s, 0, 0, o, t, 0, n, o, t), i.drawImage(s, 0, t, o, n, 0, 0, o, n)
                } else {
                    n = this.height - t;
                    e && i.drawImage(s, 0, n, o, t, 0, 0, o, t), i.drawImage(s, 0, 0, o, n, 0, t, o, n)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, o) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === o && (o = this.height), this.context.clearRect(t, e, i, o), this.dirty = !0, this
            },
            fill: function(t, e, i, o) {
                return void 0 === o && (o = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + o + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(t) {
                var e = new Image;
                e.src = this.canvas.toDataURL("image/png");
                var i = this.game.cache.addImage(t, "", e);
                return new PIXI.Texture(i.base)
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, o) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === o && (o = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, o), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(t, e, i, o, s, n) {
                void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = this.width), void 0 === n && (n = this.height);
                for (var r = i + s, a = o + n, h = U.Color.createColor(), l = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, d = !1, c = o; c < a; c++)
                    for (var u = i; u < r; u++) U.Color.unpackPixel(this.getPixel32(u, c), h), !1 !== (l = t.call(e, h, u, c)) && null != l && (this.setPixel32(u, c, l.r, l.g, l.b, l.a, !1), d = !0);
                return d && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, o, s, n) {
                void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = this.width), void 0 === n && (n = this.height);
                for (var r = i + s, a = o + n, h = 0, l = 0, d = !1, c = o; c < a; c++)
                    for (var u = i; u < r; u++) h = this.getPixel32(u, c), (l = t.call(e, h, u, c)) !== h && (this.pixels[c * this.width + u] = l, d = !0);
                return d && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(t, e, i, o, s, n, r, a, h) {
                var l = 0,
                    d = 0,
                    c = this.width,
                    u = this.height,
                    p = U.Color.packPixel(t, e, i, o);
                void 0 !== h && h instanceof U.Rectangle && (l = h.x, d = h.y, c = h.width, u = h.height);
                for (var b = 0; b < u; b++)
                    for (var m = 0; m < c; m++) this.getPixel32(l + m, d + b) === p && this.setPixel32(l + m, d + b, s, n, r, a, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(t, e, i, o) {
                var s = t || 0 === t,
                    n = e || 0 === e,
                    r = i || 0 === i;
                if (s || n || r) {
                    void 0 === o && (o = new U.Rectangle(0, 0, this.width, this.height));
                    for (var a = U.Color.createColor(), h = o.y; h < o.bottom; h++)
                        for (var l = o.x; l < o.right; l++) U.Color.unpackPixel(this.getPixel32(l, h), a, !0), s && (a.h = t), n && (a.s = e), r && (a.l = i), U.Color.HSLtoRGB(a.h, a.s, a.l, a), this.setPixel32(l, h, a.r, a.g, a.b, a.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(t, e, i, o) {
                if (null == t && (t = !1), null == e && (e = !1), null == i && (i = !1), t || e || i) {
                    void 0 === o && (o = new U.Rectangle(0, 0, this.width, this.height));
                    for (var s = U.Color.createColor(), n = o.y; n < o.bottom; n++)
                        for (var r = o.x; r < o.right; r++) U.Color.unpackPixel(this.getPixel32(r, n), s, !0), t && (s.h = this.game.math.wrap(s.h + t, 0, 1)), e && (s.s = this.game.math.clamp(s.s + e, 0, 1)), i && (s.l = this.game.math.clamp(s.l + i, 0, 1)), U.Color.HSLtoRGB(s.h, s.s, s.l, s), this.setPixel32(r, n, s.r, s.g, s.b, s.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(t, e, i, o, s, n, r) {
                return void 0 === r && (r = !0), 0 <= t && t <= this.width && 0 <= e && e <= this.height && (U.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = n << 24 | s << 16 | o << 8 | i : this.pixels[e * this.width + t] = i << 24 | o << 16 | s << 8 | n, r && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, o, s, n) {
                return this.setPixel32(t, e, i, o, s, 255, n)
            },
            getPixel: function(t, e, i) {
                i || (i = U.Color.createColor());
                var o = ~~(t + e * this.width);
                return o *= 4, i.r = this.data[o], i.g = this.data[++o], i.b = this.data[++o], i.a = this.data[++o], i
            },
            getPixel32: function(t, e) {
                if (0 <= t && t <= this.width && 0 <= e && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, e, i, o, s) {
                return U.Color.unpackPixel(this.getPixel32(t, e), i, o, s)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = U.Color.createColor(),
                    i = 0,
                    o = 0,
                    s = 1,
                    n = !1;
                for (1 === t ? (s = -1, o = this.height) : 3 === t && (s = -1, i = this.width); U.Color.unpackPixel(this.getPixel32(i, o), e), 0 === t || 1 === t ? ++i === this.width && (i = 0, ((o += s) >= this.height || o <= 0) && (n = !0)) : 2 !== t && 3 !== t || ++o === this.height && (o = 0, ((i += s) >= this.width || i <= 0) && (n = !0)), 0 === e.a && !n;);
                return e.x = i, e.y = o, e
            },
            getBounds: function(t) {
                return void 0 === t && (t = new U.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            },
            addToWorld: function(t, e, i, o, s, n) {
                s = s || 1, n = n || 1;
                var r = this.game.add.image(t, e, this);
                return r.anchor.set(i, o), r.scale.set(s, n), r
            },
            copy: function(t, e, i, o, s, n, r, a, h, l, d, c, u, p, b, m, y) {
                if (null == t && (t = this), (t instanceof U.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), (this._image = t) instanceof U.Sprite || t instanceof U.Image || t instanceof U.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof U.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, null == n && (n = t.x), null == r && (r = t.y), t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width, r += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof U.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t))) return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (null == e && (e = 0), null == i && (i = 0), o && (this._size.x = o), s && (this._size.y = s), null == n && (n = e), null == r && (r = i), null == a && (a = this._size.x), null == h && (h = this._size.y), "number" == typeof l && (this._rotate = l), "number" == typeof d && (this._anchor.x = d), "number" == typeof c && (this._anchor.y = c), "number" == typeof u && (this._scale.x = u), "number" == typeof p && (this._scale.y = p), "number" == typeof b && (this._alpha.current = b), void 0 === m && (m = null), void 0 === y && (y = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var f = this.context;
                    return this._alpha.prev = f.globalAlpha, f.save(), f.globalAlpha = this._alpha.current, m && (this.op = m), y && (n |= 0, r |= 0), f.translate(n, r), f.scale(this._scale.x, this._scale.y), f.rotate(this._rotate), f.drawImage(this._image, this._pos.x + e, this._pos.y + i, this._size.x, this._size.y, -a * this._anchor.x, -h * this._anchor.y, a, h), f.restore(), f.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            },
            copyTransform: function(t, e, i) {
                if (void 0 === e && (e = null), void 0 === i && (i = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                var o = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === o.a || 0 === o.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof U.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var s = o.tx,
                    n = o.ty;
                t.texture.trim && (s += t.texture.trim.x - t.anchor.x * t.texture.trim.width, n += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), i && (s |= 0, n |= 0);
                var r = this.context;
                return this._alpha.prev = r.globalAlpha, r.save(), r.globalAlpha = this._alpha.current, e && (this.op = e), r[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, r.setTransform(o.a, o.b, o.c, o.d, s, n), r.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), r.restore(), r.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, o, s, n, r) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, o, e.width, e.height, 0, 0, 0, 1, 1, s, n, r)
            },
            draw: function(t, e, i, o, s, n, r) {
                return this.copy(t, null, null, null, null, e, i, o, s, null, null, null, null, null, null, n, r)
            },
            drawGroup: function(t, e, i) {
                return 0 < t.total && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(t, e, i) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, e, i), t.type === U.GROUP && t.exists) this.drawGroup(t, e, i);
                else if (t.hasOwnProperty("children") && 0 < t.children.length)
                    for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.copyTransform(t.children[o], e, i)
            },
            drawFull: function(t, e, i) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                if (t.type !== U.GROUP && t.type !== U.EMITTER && t.type !== U.BITMAPTEXT)
                    if (t.type === U.GRAPHICS) {
                        var o = t.getBounds();
                        this.ctx.save(), this.ctx.translate(o.x, o.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                    } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, i);
                if (t.children)
                    for (var s = 0; s < t.children.length; s++) this.drawFull(t.children[s], e, i);
                return this
            },
            shadow: function(t, e, i, o) {
                var s = this.context;
                return null == t ? s.shadowColor = "rgba(0,0,0,0)" : (s.shadowColor = t, s.shadowBlur = e || 5, s.shadowOffsetX = i || 10, s.shadowOffsetY = o || 10), this
            },
            alphaMask: function(t, e, i, o) {
                return null == o ? this.draw(e).blendSourceAtop() : this.draw(e, o.x, o.y, o.width, o.height).blendSourceAtop(), null == i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(o, s, n, r, a, t, h, l, d) {
                return void 0 === a && (a = 255), void 0 === t && (t = !1), void 0 === h && (h = s), void 0 === l && (l = n), void 0 === d && (d = r), t && o.resize(this.width, this.height), this.processPixelRGB(function(t, e, i) {
                    return t.r === s && t.g === n && t.b === r && o.setPixel32(e, i, h, l, d, a, !1), !1
                }, this), o.context.putImageData(o.imageData, 0, 0), o.dirty = !0, o
            },
            rect: function(t, e, i, o, s) {
                return void 0 !== s && (this.context.fillStyle = s), this.context.fillRect(t, e, i, o), this
            },
            text: function(t, e, i, o, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = "14px Courier"), void 0 === s && (s = "rgb(255,255,255)"), void 0 === n && (n = !0);
                var r = this.context,
                    a = r.font;
                return r.font = o, n && (r.fillStyle = "rgb(0,0,0)", r.fillText(t, e + 1, i + 1)), r.fillStyle = s, r.fillText(t, e, i), r.font = a, this
            },
            circle: function(t, e, i, o) {
                var s = this.context;
                return void 0 !== o && (s.fillStyle = o), s.beginPath(), s.arc(t, e, i, 0, 2 * Math.PI, !1), s.closePath(), s.fill(), this
            },
            line: function(t, e, i, o, s, n) {
                void 0 === s && (s = "#fff"), void 0 === n && (n = 1);
                var r = this.context;
                return r.beginPath(), r.moveTo(t, e), r.lineTo(i, o), r.lineWidth = n, r.strokeStyle = s, r.stroke(), r.closePath(), this
            },
            textureLine: function(t, e, i) {
                if (void 0 === i && (i = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var o = t.length;
                    "no-repeat" === i && o > e.width && (o = e.width);
                    var s = this.context;
                    return s.fillStyle = s.createPattern(e, i), this._circle = new U.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), s.save(), s.translate(this._pos.x, this._pos.y), s.rotate(t.angle), s.fillRect(0, 0, o, e.height), s.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(U.BitmapData.prototype, "smoothed", {
            get: function() {
                U.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                U.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(U.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), U.BitmapData.getTransform = function(t, e, i, o, s, n) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof o && (o = 1), "number" != typeof s && (s = 0), "number" != typeof n && (n = 0), {
                sx: i,
                sy: o,
                scaleX: i,
                scaleY: o,
                skewX: s,
                skewY: n,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, U.BitmapData.prototype.constructor = U.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new PIXI.Polygon([t, e])), this
        }, PIXI.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, o) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var s, n, r = this.currentPath.shape.points;
            0 === r.length && this.moveTo(0, 0);
            for (var a = r[r.length - 2], h = r[r.length - 1], l = 0, d = 1; d <= 20; ++d) s = a + (t - a) * (l = d / 20), n = h + (e - h) * l, r.push(s + (t + (i - t) * l - s) * l, n + (e + (o - e) * l - n) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, o, s, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var r, a, h, l, d, c = this.currentPath.shape.points, u = c[c.length - 2], p = c[c.length - 1], b = 0, m = 1; m <= 20; ++m) h = (a = (r = 1 - (b = m / 20)) * r) * r, d = (l = b * b) * b, c.push(h * u + 3 * a * b * t + 3 * r * l * i + d * s, h * p + 3 * a * b * e + 3 * r * l * o + d * n);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(t, e, i, o, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var n = this.currentPath.shape.points,
                r = n[n.length - 2],
                a = n[n.length - 1] - e,
                h = r - t,
                l = o - e,
                d = i - t,
                c = Math.abs(a * d - h * l);
            if (c < 1e-8 || 0 === s) n[n.length - 2] === t && n[n.length - 1] === e || n.push(t, e);
            else {
                var u = a * a + h * h,
                    p = l * l + d * d,
                    b = a * l + h * d,
                    m = s * Math.sqrt(u) / c,
                    y = s * Math.sqrt(p) / c,
                    f = m * b / u,
                    x = y * b / p,
                    g = m * d + y * h,
                    _ = m * l + y * a,
                    v = h * (y + f),
                    S = a * (y + f),
                    C = d * (m + x),
                    w = l * (m + x),
                    A = Math.atan2(S - _, v - g),
                    P = Math.atan2(w - _, C - g);
                this.arc(g + t, _ + e, s, A, P, d * a < h * l)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(t, e, i, o, s, n, r) {
            if (o === s) return this;
            void 0 === n && (n = !1), void 0 === r && (r = 40), !n && s <= o ? s += 2 * Math.PI : n && o <= s && (o += 2 * Math.PI);
            var a = n ? -1 * (o - s) : s - o,
                h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * r;
            if (0 === a) return this;
            var l = t + Math.cos(o) * i,
                d = e + Math.sin(o) * i;
            n && this.filling ? this.moveTo(t, e) : this.moveTo(l, d);
            for (var c = this.currentPath.shape.points, u = a / (2 * h), p = 2 * u, b = Math.cos(u), m = Math.sin(u), y = h - 1, f = y % 1 / y, x = 0; x <= y; x++) {
                var g = u + o + p * (x + f * x),
                    _ = Math.cos(g),
                    v = -Math.sin(g);
                c.push((b * _ + m * v) * i + t, (b * -v + m * _) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(t, e, i, o) {
            return this.drawShape(new PIXI.Rectangle(t, e, i, o)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, o, s) {
            return this.drawShape(new PIXI.RoundedRectangle(t, e, i, o, s)), this
        }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new PIXI.Circle(t, e, i)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, o) {
            return this.drawShape(new PIXI.Ellipse(t, e, i, o)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof U.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
            var e = t;
            if (!Array.isArray(e)) {
                e = new Array(arguments.length);
                for (var i = 0; i < e.length; ++i) e[i] = arguments[i]
            }
            return this.drawShape(new U.Polygon(e)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var o = this.getBounds();
            o.width += i, o.height += i;
            var s = new PIXI.CanvasBuffer(o.width * t, o.height * t),
                n = PIXI.Texture.fromCanvas(s.canvas, e);
            return n.baseTexture.resolution = t, s.context.scale(t, t), s.context.translate(-o.x, -o.y), PIXI.CanvasGraphics.renderGraphics(this, s.context), n
        }, PIXI.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, PIXI.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var o = t.resolution,
                    s = i.tx * t.resolution + t.shakeX,
                    n = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * o, i.b * o, i.c * o, i.d * o, s, n), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var r = 0; r < this.children.length; r++) this.children[r]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, PIXI.Graphics.prototype.getBounds = function(t) {
            if (!this._currentBounds) {
                if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var e = this._localBounds,
                    i = e.x,
                    o = e.width + e.x,
                    s = e.y,
                    n = e.height + e.y,
                    r = t || this.worldTransform,
                    a = r.a,
                    h = r.b,
                    l = r.c,
                    d = r.d,
                    c = r.tx,
                    u = r.ty,
                    p = a * o + l * n + c,
                    b = d * n + h * o + u,
                    m = a * i + l * n + c,
                    y = d * n + h * i + u,
                    f = a * i + l * s + c,
                    x = d * s + h * i + u,
                    g = a * o + l * s + c,
                    _ = d * s + h * o + u,
                    v = p,
                    S = b,
                    C = p,
                    w = b;
                C = g < (C = f < (C = m < C ? m : C) ? f : C) ? g : C, w = _ < (w = x < (w = y < w ? y : w) ? x : w) ? _ : w, v = (v = (v = v < m ? m : v) < f ? f : v) < g ? g : v, S = (S = (S = S < y ? y : S) < x ? x : S) < _ ? _ : S, this._bounds.x = C, this._bounds.width = v - C, this._bounds.y = w, this._bounds.height = S - w, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, PIXI.Graphics.prototype.containsPoint = function(t) {
            this.worldTransform.applyInverse(t, tempPoint);
            for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                var o = e[i];
                if (o.fill && (o.shape && o.shape.contains(tempPoint.x, tempPoint.y))) return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0,
                e = -1 / 0,
                i = 1 / 0,
                o = -1 / 0;
            if (this.graphicsData.length)
                for (var s, n, r, a, h, l, d = 0; d < this.graphicsData.length; d++) {
                    var c = this.graphicsData[d],
                        u = c.type,
                        p = c.lineWidth;
                    if (s = c.shape, u === PIXI.Graphics.RECT || u === PIXI.Graphics.RREC) r = s.x - p / 2, a = s.y - p / 2, t = r < t ? r : t, e = e < r + (h = s.width + p) ? r + h : e, i = a < i ? a : i, o = o < a + (l = s.height + p) ? a + l : o;
                    else if (u === PIXI.Graphics.CIRC) r = s.x, a = s.y, t = r - (h = s.radius + p / 2) < t ? r - h : t, e = e < r + h ? r + h : e, i = a - (l = s.radius + p / 2) < i ? a - l : i, o = o < a + l ? a + l : o;
                    else if (u === PIXI.Graphics.ELIP) r = s.x, a = s.y, t = r - (h = s.width + p / 2) < t ? r - h : t, e = e < r + h ? r + h : e, i = a - (l = s.height + p / 2) < i ? a - l : i, o = o < a + l ? a + l : o;
                    else {
                        n = s.points;
                        for (var b = 0; b < n.length; b++) n[b] instanceof U.Point ? (r = n[b].x, a = n[b].y) : (r = n[b], a = n[b + 1], b < n.length - 1 && b++), t = r - p < t ? r - p : t, e = e < r + p ? r + p : e, i = a - p < i ? a - p : i, o = o < a + p ? a + p : o
                    }
                } else o = i = e = t = 0;
            var m = this.boundsPadding;
            this._localBounds.x = t - m, this._localBounds.width = e - t + 2 * m, this._localBounds.y = i - m, this._localBounds.height = o - i + 2 * m
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof U.Polygon && (t = t.clone()).flatten();
            var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(t, e, i, o, s, n, r) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = o, this.fillAlpha = s, this._fillTint = o, this.fill = n, this.shape = r, this.type = r.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var o, s, n, r, a, h, l, d = e && e.length,
                c = d ? e[0] * i : t.length,
                u = PIXI.EarCut.linkedList(t, 0, c, i, !0),
                p = [];
            if (!u) return p;
            if (d && (u = PIXI.EarCut.eliminateHoles(t, e, u, i)), t.length > 80 * i) {
                o = n = t[0], s = r = t[1];
                for (var b = i; b < c; b += i)(a = t[b]) < o && (o = a), (h = t[b + 1]) < s && (s = h), n < a && (n = a), r < h && (r = h);
                l = Math.max(n - o, r - s)
            }
            return PIXI.EarCut.earcutLinked(u, p, i, o, s, l), p
        }, PIXI.EarCut.linkedList = function(t, e, i, o, s) {
            var n, r, a, h = 0;
            for (n = e, r = i - o; n < i; n += o) h += (t[r] - t[n]) * (t[n + 1] + t[r + 1]), r = n;
            if (s === 0 < h)
                for (n = e; n < i; n += o) a = PIXI.EarCut.insertNode(n, t[n], t[n + 1], a);
            else
                for (n = i - o; e <= n; n -= o) a = PIXI.EarCut.insertNode(n, t[n], t[n + 1], a);
            return a
        }, PIXI.EarCut.filterPoints = function(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, o = t;
            do {
                if (i = !1, o.steiner || !PIXI.EarCut.equals(o, o.next) && 0 !== PIXI.EarCut.area(o.prev, o, o.next)) o = o.next;
                else {
                    if (PIXI.EarCut.removeNode(o), (o = e = o.prev) === o.next) return null;
                    i = !0
                }
            } while (i || o !== e);
            return e
        }, PIXI.EarCut.earcutLinked = function(t, e, i, o, s, n, r) {
            if (t) {
                !r && n && PIXI.EarCut.indexCurve(t, o, s, n);
                for (var a, h, l = t; t.prev !== t.next;)
                    if (a = t.prev, h = t.next, n ? PIXI.EarCut.isEarHashed(t, o, s, n) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                    else if ((t = h) === l) {
                    r ? 1 === r ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, o, s, n, 2)) : 2 === r && PIXI.EarCut.splitEarcut(t, e, i, o, s, n) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, o, s, n, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(t) {
            var e = t.prev,
                i = t,
                o = t.next;
            if (0 <= PIXI.EarCut.area(e, i, o)) return !1;
            for (var s = t.next.next; s !== t.prev;) {
                if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, o.x, o.y, s.x, s.y) && 0 <= PIXI.EarCut.area(s.prev, s, s.next)) return !1;
                s = s.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(t, e, i, o) {
            var s = t.prev,
                n = t,
                r = t.next;
            if (0 <= PIXI.EarCut.area(s, n, r)) return !1;
            for (var a = s.x < n.x ? s.x < r.x ? s.x : r.x : n.x < r.x ? n.x : r.x, h = s.y < n.y ? s.y < r.y ? s.y : r.y : n.y < r.y ? n.y : r.y, l = s.x > n.x ? s.x > r.x ? s.x : r.x : n.x > r.x ? n.x : r.x, d = s.y > n.y ? s.y > r.y ? s.y : r.y : n.y > r.y ? n.y : r.y, c = PIXI.EarCut.zOrder(a, h, e, i, o), u = PIXI.EarCut.zOrder(l, d, e, i, o), p = t.nextZ; p && p.z <= u;) {
                if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, n.x, n.y, r.x, r.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
                p = p.nextZ
            }
            for (p = t.prevZ; p && p.z >= c;) {
                if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, n.x, n.y, r.x, r.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
                p = p.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
            var o = t;
            do {
                var s = o.prev,
                    n = o.next.next;
                PIXI.EarCut.intersects(s, o, o.next, n) && PIXI.EarCut.locallyInside(s, n) && PIXI.EarCut.locallyInside(n, s) && (e.push(s.i / i), e.push(o.i / i), e.push(n.i / i), PIXI.EarCut.removeNode(o), PIXI.EarCut.removeNode(o.next), o = t = n), o = o.next
            } while (o !== t);
            return o
        }, PIXI.EarCut.splitEarcut = function(t, e, i, o, s, n) {
            var r = t;
            do {
                for (var a = r.next.next; a !== r.prev;) {
                    if (r.i !== a.i && PIXI.EarCut.isValidDiagonal(r, a)) {
                        var h = PIXI.EarCut.splitPolygon(r, a);
                        return r = PIXI.EarCut.filterPoints(r, r.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(r, e, i, o, s, n), void PIXI.EarCut.earcutLinked(h, e, i, o, s, n)
                    }
                    a = a.next
                }
                r = r.next
            } while (r !== t)
        }, PIXI.EarCut.eliminateHoles = function(t, e, i, o) {
            var s, n, r, a, h, l = [];
            for (s = 0, n = e.length; s < n; s++) r = e[s] * o, a = s < n - 1 ? e[s + 1] * o : t.length, (h = PIXI.EarCut.linkedList(t, r, a, o, !1)) === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
            for (l.sort(compareX), s = 0; s < l.length; s++) PIXI.EarCut.eliminateHole(l[s], i), i = PIXI.EarCut.filterPoints(i, i.next);
            return i
        }, PIXI.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, PIXI.EarCut.eliminateHole = function(t, e) {
            if (e = PIXI.EarCut.findHoleBridge(t, e)) {
                var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(t, e) {
            var i, o = e,
                s = t.x,
                n = t.y,
                r = -1 / 0;
            do {
                if (n <= o.y && n >= o.next.y) {
                    var a = o.x + (n - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
                    a <= s && r < a && (r = a, i = o.x < o.next.x ? o : o.next)
                }
                o = o.next
            } while (o !== e);
            if (!i) return null;
            if (t.x === i.x) return i.prev;
            var h, l = i,
                d = 1 / 0;
            for (o = i.next; o !== l;) s >= o.x && o.x >= i.x && PIXI.EarCut.pointInTriangle(n < i.y ? s : r, n, i.x, i.y, n < i.y ? r : s, n, o.x, o.y) && ((h = Math.abs(n - o.y) / (s - o.x)) < d || h === d && o.x > i.x) && PIXI.EarCut.locallyInside(o, t) && (i = o, d = h), o = o.next;
            return i
        }, PIXI.EarCut.indexCurve = function(t, e, i, o) {
            for (var s = t; null === s.z && (s.z = PIXI.EarCut.zOrder(s.x, s.y, e, i, o)), s.prevZ = s.prev, s.nextZ = s.next, (s = s.next) !== t;);
            s.prevZ.nextZ = null, s.prevZ = null, PIXI.EarCut.sortLinked(s)
        }, PIXI.EarCut.sortLinked = function(t) {
            var e, i, o, s, n, r, a, h, l = 1;
            do {
                for (i = t, n = t = null, r = 0; i;) {
                    for (r++, o = i, e = a = 0; e < l && (a++, o = o.nextZ); e++);
                    for (h = l; 0 < a || 0 < h && o;) 0 === a ? (o = (s = o).nextZ, h--) : 0 !== h && o ? i.z <= o.z ? (i = (s = i).nextZ, a--) : (o = (s = o).nextZ, h--) : (i = (s = i).nextZ, a--), n ? n.nextZ = s : t = s, s.prevZ = n, n = s;
                    i = o
                }
                n.nextZ = null, l *= 2
            } while (1 < r);
            return t
        }, PIXI.EarCut.zOrder = function(t, e, i, o, s) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - o) / s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }, PIXI.EarCut.getLeftmost = function(t) {
            for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;);
            return i
        }, PIXI.EarCut.pointInTriangle = function(t, e, i, o, s, n, r, a) {
            return 0 <= (s - r) * (e - a) - (t - r) * (n - a) && 0 <= (t - r) * (o - a) - (i - r) * (e - a) && 0 <= (i - r) * (n - a) - (s - r) * (o - a)
        }, PIXI.EarCut.isValidDiagonal = function(t, e) {
            return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
        }, PIXI.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, PIXI.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, PIXI.EarCut.intersects = function(t, e, i, o) {
            return 0 < PIXI.EarCut.area(t, e, i) != 0 < PIXI.EarCut.area(t, e, o) && 0 < PIXI.EarCut.area(i, o, t) != 0 < PIXI.EarCut.area(i, o, e)
        }, PIXI.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }, PIXI.EarCut.locallyInside = function(t, e) {
            return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? 0 <= PIXI.EarCut.area(t, e, t.next) && 0 <= PIXI.EarCut.area(t, t.prev, e) : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
        }, PIXI.EarCut.middleInside = function(t, e) {
            for (var i = t, o = !1, s = (t.x + e.x) / 2, n = (t.y + e.y) / 2; i.y > n != i.next.y > n && s < (i.next.x - i.x) * (n - i.y) / (i.next.y - i.y) + i.x && (o = !o), (i = i.next) !== t;);
            return o
        }, PIXI.EarCut.splitPolygon = function(t, e) {
            var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                o = new PIXI.EarCut.Node(e.i, e.x, e.y),
                s = t.next,
                n = e.prev;
            return (t.next = e).prev = t, (i.next = s).prev = i, (o.next = i).prev = o, (n.next = o).prev = n, o
        }, PIXI.EarCut.insertNode = function(t, e, i, o) {
            var s = new PIXI.EarCut.Node(t, e, i);
            return o ? (s.next = o.next, (s.prev = o).next.prev = s, o.next = s) : (s.prev = s).next = s, s
        }, PIXI.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, PIXI.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
            var i, o = e.gl,
                s = e.projection,
                n = e.offset,
                r = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, o);
            for (var a = t._webGL[o.id], h = 0; h < a.data.length; h++) 1 === a.data[h].mode ? (i = a.data[h], e.stencilManager.pushStencil(t, i, e), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = a.data[h], e.shaderManager.setShader(r), r = e.shaderManager.primitiveShader, o.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)), o.uniform1f(r.flipY, 1), o.uniform2f(r.projectionVector, s.x, -s.y), o.uniform2f(r.offsetVector, -n.x, -n.y), o.uniform3fv(r.tintColor, PIXI.hex2rgb(t.tint)), o.uniform1f(r.alpha, t.worldAlpha), o.bindBuffer(o.ARRAY_BUFFER, i.buffer), o.vertexAttribPointer(r.aVertexPosition, 2, o.FLOAT, !1, 24, 0), o.vertexAttribPointer(r.colorAttribute, 4, o.FLOAT, !1, 24, 8), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, i.indexBuffer), o.drawElements(o.TRIANGLE_STRIP, i.indices.length, o.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
            var i, o, s = t._webGL[e.id];
            if (s || (s = t._webGL[e.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: e
                }), t.dirty = !1, t.clearDirty) {
                for (t.clearDirty = !1, i = 0; i < s.data.length; i++) {
                    var n = s.data[i];
                    n.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(n)
                }
                s.data = [], s.lastIndex = 0
            }
            for (i = s.lastIndex; i < t.graphicsData.length; i++) {
                var r = t.graphicsData[i];
                if (r.type === PIXI.Graphics.POLY) {
                    if (r.points = r.shape.points.slice(), r.shape.closed && (r.points[0] === r.points[r.points.length - 2] && r.points[1] === r.points[r.points.length - 1] || r.points.push(r.points[0], r.points[1])), r.fill)
                        if (r.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                            if (r.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) o = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildPoly(r, o) || (o = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(r, o));
                            else o = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(r, o);
                    0 < r.lineWidth && (o = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildLine(r, o))
                } else o = PIXI.WebGLGraphics.switchMode(s, 0), r.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(r, o) : r.type === PIXI.Graphics.CIRC || r.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(r, o) : r.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(r, o);
                s.lastIndex++
            }
            for (i = 0; i < s.data.length; i++)(o = s.data[i]).dirty && o.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
            var i = t.shape,
                o = i.x,
                s = i.y,
                n = i.width,
                r = i.height;
            if (t.fill) {
                var a = PIXI.hex2rgb(t.fillColor),
                    h = t.fillAlpha,
                    l = a[0] * h,
                    d = a[1] * h,
                    c = a[2] * h,
                    u = e.points,
                    p = e.indices,
                    b = u.length / 6;
                u.push(o, s), u.push(l, d, c, h), u.push(o + n, s), u.push(l, d, c, h), u.push(o, s + r), u.push(l, d, c, h), u.push(o + n, s + r), u.push(l, d, c, h), p.push(b, b, b + 1, b + 2, b + 3, b + 3)
            }
            if (t.lineWidth) {
                var m = t.points;
                t.points = [o, s, o + n, s, o + n, s + r, o, s + r, o, s], PIXI.WebGLGraphics.buildLine(t, e), t.points = m
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
            var i = t.shape,
                o = i.x,
                s = i.y,
                n = i.width,
                r = i.height,
                a = i.radius,
                h = [];
            if (h.push(o, s + a), h = (h = (h = (h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o, s + r - a, o, s + r, o + a, s + r))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + n - a, s + r, o + n, s + r, o + n, s + r - a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + n, s + a, o + n, s, o + n - a, s))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + a, s, o, s, o, s + a)), t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    d = t.fillAlpha,
                    c = l[0] * d,
                    u = l[1] * d,
                    p = l[2] * d,
                    b = e.points,
                    m = e.indices,
                    y = b.length / 6,
                    f = PIXI.EarCut.Triangulate(h, null, 2),
                    x = 0;
                for (x = 0; x < f.length; x += 3) m.push(f[x] + y), m.push(f[x] + y), m.push(f[x + 1] + y), m.push(f[x + 2] + y), m.push(f[x + 2] + y);
                for (x = 0; x < h.length; x++) b.push(h[x], h[++x], c, u, p, d)
            }
            if (t.lineWidth) {
                var g = t.points;
                t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = g
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, o, s, n) {
            var r, a, h, l, d, c, u = [];

            function p(t, e, i) {
                return t + (e - t) * i
            }
            for (var b = 0, m = 0; m <= 20; m++) r = p(t, i, b = m / 20), a = p(e, o, b), h = p(i, s, b), l = p(o, n, b), d = p(r, h, b), c = p(a, l, b), u.push(d, c);
            return u
        }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
            var i, o, s = t.shape,
                n = s.x,
                r = s.y;
            o = t.type === PIXI.Graphics.CIRC ? (i = s.radius, s.radius) : (i = s.width, s.height);
            var a = 2 * Math.PI / 40,
                h = 0;
            if (t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    d = t.fillAlpha,
                    c = l[0] * d,
                    u = l[1] * d,
                    p = l[2] * d,
                    b = e.points,
                    m = e.indices,
                    y = b.length / 6;
                for (m.push(y), h = 0; h < 41; h++) b.push(n, r, c, u, p, d), b.push(n + Math.sin(a * h) * i, r + Math.cos(a * h) * o, c, u, p, d), m.push(y++, y++);
                m.push(y - 1)
            }
            if (t.lineWidth) {
                var f = t.points;
                for (t.points = [], h = 0; h < 41; h++) t.points.push(n + Math.sin(a * h) * i, r + Math.cos(a * h) * o);
                PIXI.WebGLGraphics.buildLine(t, e), t.points = f
            }
        }, PIXI.WebGLGraphics.buildLine = function(t, e) {
            var i = 0,
                o = t.points;
            if (0 !== o.length) {
                if (t.lineWidth % 2)
                    for (i = 0; i < o.length; i++) o[i] += .5;
                var s = new PIXI.Point(o[0], o[1]),
                    n = new PIXI.Point(o[o.length - 2], o[o.length - 1]);
                if (s.x === n.x && s.y === n.y) {
                    (o = o.slice()).pop(), o.pop();
                    var r = (n = new PIXI.Point(o[o.length - 2], o[o.length - 1])).x + .5 * (s.x - n.x),
                        a = n.y + .5 * (s.y - n.y);
                    o.unshift(r, a), o.push(r, a)
                }
                var h, l, d, c, u, p, b, m, y, f, x, g, _, v, S, C, w, A, P, T, B, M, E = e.points,
                    I = e.indices,
                    V = o.length / 2,
                    R = o.length,
                    L = E.length / 6,
                    D = t.lineWidth / 2,
                    F = PIXI.hex2rgb(t.lineColor),
                    k = t.lineAlpha,
                    G = F[0] * k,
                    O = F[1] * k,
                    N = F[2] * k;
                for (d = o[0], c = o[1], u = o[2], y = -(c - (p = o[3])), f = d - u, y /= M = Math.sqrt(y * y + f * f), f /= M, y *= D, f *= D, E.push(d - y, c - f, G, O, N, k), E.push(d + y, c + f, G, O, N, k), i = 1; i < V - 1; i++) d = o[2 * (i - 1)], c = o[2 * (i - 1) + 1], u = o[2 * i], p = o[2 * i + 1], b = o[2 * (i + 1)], m = o[2 * (i + 1) + 1], y = -(c - p), f = d - u, y /= M = Math.sqrt(y * y + f * f), f /= M, y *= D, f *= D, x = -(p - m), g = u - b, x /= M = Math.sqrt(x * x + g * g), g /= M, w = (-y + d) * (-f + p) - (-y + u) * (-f + c), T = (-(x *= D) + b) * (-(g *= D) + p) - (-x + u) * (-g + m), B = (S = -f + c - (-f + p)) * (P = -x + u - (-x + b)) - (A = -g + m - (-g + p)) * (C = -y + u - (-y + d)), Math.abs(B) < .1 ? (B += 10.1, E.push(u - y, p - f, G, O, N, k), E.push(u + y, p + f, G, O, N, k)) : 19600 < ((h = (C * T - P * w) / B) - u) * (h - u) + ((l = (A * w - S * T) / B) - p) + (l - p) ? (_ = y - x, v = f - g, _ /= M = Math.sqrt(_ * _ + v * v), v /= M, _ *= D, v *= D, E.push(u - _, p - v), E.push(G, O, N, k), E.push(u + _, p + v), E.push(G, O, N, k), E.push(u - _, p - v), E.push(G, O, N, k), R++) : (E.push(h, l), E.push(G, O, N, k), E.push(u - (h - u), p - (l - p)), E.push(G, O, N, k));
                for (d = o[2 * (V - 2)], c = o[2 * (V - 2) + 1], u = o[2 * (V - 1)], y = -(c - (p = o[2 * (V - 1) + 1])), f = d - u, y /= M = Math.sqrt(y * y + f * f), f /= M, y *= D, f *= D, E.push(u - y, p - f), E.push(G, O, N, k), E.push(u + y, p + f), E.push(G, O, N, k), I.push(L), i = 0; i < R; i++) I.push(L++);
                I.push(L - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
            var i = t.points.slice();
            if (!(i.length < 6)) {
                var o = e.indices;
                e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                for (var s, n, r = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, d = 0; d < i.length; d += 2) r = (s = i[d]) < r ? s : r, a = a < s ? s : a, h = (n = i[d + 1]) < h ? n : h, l = l < n ? n : l;
                i.push(r, h, a, h, a, l, r, l);
                var c = i.length / 2;
                for (d = 0; d < c; d++) o.push(d)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
            var i = t.points;
            if (!(i.length < 6)) {
                var o = e.points,
                    s = e.indices,
                    n = i.length / 2,
                    r = PIXI.hex2rgb(t.fillColor),
                    a = t.fillAlpha,
                    h = r[0] * a,
                    l = r[1] * a,
                    d = r[2] * a,
                    c = PIXI.EarCut.Triangulate(i, null, 2);
                if (!c) return !1;
                var u = o.length / 6,
                    p = 0;
                for (p = 0; p < c.length; p += 3) s.push(c[p] + u), s.push(c[p] + u), s.push(c[p + 1] + u), s.push(c[p + 2] + u), s.push(c[p + 2] + u);
                for (p = 0; p < n; p++) o.push(i[2 * p], i[2 * p + 1], h, l, d, a);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for (var o = 0; o < t.graphicsData.length; o++) {
                var s = t.graphicsData[o],
                    n = s.shape,
                    r = s._fillTint,
                    a = s._lineTint;
                if (e.lineWidth = s.lineWidth, s.type === PIXI.Graphics.POLY) {
                    e.beginPath();
                    var h = n.points;
                    e.moveTo(h[0], h[1]);
                    for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                    n.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RECT)(s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fillRect(n.x, n.y, n.width, n.height)), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(n.x, n.y, n.width, n.height));
                else if (s.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke());
                else if (s.type === PIXI.Graphics.ELIP) {
                    var d = 2 * n.width,
                        c = 2 * n.height,
                        u = n.x - d / 2,
                        p = n.y - c / 2;
                    e.beginPath();
                    var b = d / 2 * .5522848,
                        m = c / 2 * .5522848,
                        y = u + d,
                        f = p + c,
                        x = u + d / 2,
                        g = p + c / 2;
                    e.moveTo(u, g), e.bezierCurveTo(u, g - m, x - b, p, x, p), e.bezierCurveTo(x + b, p, y, g - m, y, g), e.bezierCurveTo(y, g + m, x + b, f, x, f), e.bezierCurveTo(x - b, f, u, g + m, u, g), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RREC) {
                    var _ = n.x,
                        v = n.y,
                        S = n.width,
                        C = n.height,
                        w = n.radius,
                        A = Math.min(S, C) / 2 | 0;
                    w = A < w ? A : w, e.beginPath(), e.moveTo(_, v + w), e.lineTo(_, v + C - w), e.quadraticCurveTo(_, v + C, _ + w, v + C), e.lineTo(_ + S - w, v + C), e.quadraticCurveTo(_ + S, v + C, _ + S, v + C - w), e.lineTo(_ + S, v + w), e.quadraticCurveTo(_ + S, v, _ + S - w, v), e.lineTo(_ + w, v), e.quadraticCurveTo(_, v, _, v + w), e.closePath(), (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if (0 !== i) {
                e.beginPath();
                for (var o = 0; o < i; o++) {
                    var s = t.graphicsData[o],
                        n = s.shape;
                    if (s.type === PIXI.Graphics.POLY) {
                        var r = n.points;
                        e.moveTo(r[0], r[1]);
                        for (var a = 1; a < r.length / 2; a++) e.lineTo(r[2 * a], r[2 * a + 1]);
                        r[0] === r[r.length - 2] && r[1] === r[r.length - 1] && e.closePath()
                    } else if (s.type === PIXI.Graphics.RECT) e.rect(n.x, n.y, n.width, n.height), e.closePath();
                    else if (s.type === PIXI.Graphics.CIRC) e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath();
                    else if (s.type === PIXI.Graphics.ELIP) {
                        var h = 2 * n.width,
                            l = 2 * n.height,
                            d = n.x - h / 2,
                            c = n.y - l / 2,
                            u = h / 2 * .5522848,
                            p = l / 2 * .5522848,
                            b = d + h,
                            m = c + l,
                            y = d + h / 2,
                            f = c + l / 2;
                        e.moveTo(d, f), e.bezierCurveTo(d, f - p, y - u, c, y, c), e.bezierCurveTo(y + u, c, b, f - p, b, f), e.bezierCurveTo(b, f + p, y + u, m, y, m), e.bezierCurveTo(y - u, m, d, f + p, d, f), e.closePath()
                    } else if (s.type === PIXI.Graphics.RREC) {
                        var x = n.x,
                            g = n.y,
                            _ = n.width,
                            v = n.height,
                            S = n.radius,
                            C = Math.min(_, v) / 2 | 0;
                        S = C < S ? C : S, e.moveTo(x, g + S), e.lineTo(x, g + v - S), e.quadraticCurveTo(x, g + v, x + S, g + v), e.lineTo(x + _ - S, g + v), e.quadraticCurveTo(x + _, g + v, x + _, g + v - S), e.lineTo(x + _, g + S), e.quadraticCurveTo(x + _, g, x + _ - S, g), e.lineTo(x + S, g), e.quadraticCurveTo(x, g, x, g + S), e.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, o = (255 & t.tint) / 255, s = 0; s < t.graphicsData.length; s++) {
                    var n = t.graphicsData[s],
                        r = 0 | n.fillColor,
                        a = 0 | n.lineColor;
                    n._fillTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * o * 255, n._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * o * 255
                }
        }, U.Graphics = function(t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = U.GRAPHICS, this.physicsType = U.SPRITE, this.anchor = new U.Point, PIXI.Graphics.call(this), U.Component.Core.init.call(this, t, e, i, "", null)
        }, U.Graphics.prototype = Object.create(PIXI.Graphics.prototype), U.Graphics.prototype.constructor = U.Graphics, U.Component.Core.install.call(U.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), U.Graphics.prototype.preUpdatePhysics = U.Component.PhysicsBody.preUpdate, U.Graphics.prototype.preUpdateLifeSpan = U.Component.LifeSpan.preUpdate, U.Graphics.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.Graphics.prototype.preUpdateCore = U.Component.Core.preUpdate, U.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.Graphics.prototype.postUpdate = function() {
            U.Component.PhysicsBody.postUpdate.call(this), U.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, U.Graphics.prototype.destroy = function(t) {
            this.clear(), U.Component.Destroy.prototype.destroy.call(this, t)
        }, U.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var i = new U.Polygon(t);
            if (e) {
                var o = new U.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    s = new U.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    n = new U.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(s);
                0 < o.dot(n) && this.drawPolygon(i)
            } else this.drawPolygon(i)
        }, U.Graphics.prototype.drawTriangles = function(t, e, i) {
            void 0 === i && (i = !1);
            var o, s = new U.Point,
                n = new U.Point,
                r = new U.Point,
                a = [];
            if (e)
                if (t[0] instanceof U.Point)
                    for (o = 0; o < e.length / 3; o++) a.push(t[e[3 * o]]), a.push(t[e[3 * o + 1]]), a.push(t[e[3 * o + 2]]), 3 === a.length && (this.drawTriangle(a, i), a = []);
                else
                    for (o = 0; o < e.length; o++) s.x = t[2 * e[o]], s.y = t[2 * e[o] + 1], a.push(s.copyTo({})), 3 === a.length && (this.drawTriangle(a, i), a = []);
            else if (t[0] instanceof U.Point)
                for (o = 0; o < t.length / 3; o++) this.drawTriangle([t[3 * o], t[3 * o + 1], t[3 * o + 2]], i);
            else
                for (o = 0; o < t.length / 6; o++) s.x = t[6 * o + 0], s.y = t[6 * o + 1], n.x = t[6 * o + 2], n.y = t[6 * o + 3], r.x = t[6 * o + 4], r.y = t[6 * o + 5], this.drawTriangle([s, n, r], i)
        }, U.RenderTexture = function(t, e, i, o, s, n) {
            void 0 === o && (o = ""), void 0 === s && (s = U.scaleModes.DEFAULT), void 0 === n && (n = 1), this.game = t, this.key = o, this.type = U.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, i, this.game.renderer, s, n), this.render = U.RenderTexture.prototype.render
        }, U.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), U.RenderTexture.prototype.constructor = U.RenderTexture, U.RenderTexture.prototype.renderXY = function(t, e, i, o) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o)
        }, U.RenderTexture.prototype.renderRawXY = function(t, e, i, o) {
            this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o)
        }, U.RenderTexture.prototype.render = function(t, e, i) {
            null == e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
        }, U.Text = function(t, e, i, o, s) {
            e = e || 0, i = i || 0, o = null == o ? "" : o.toString(), s = U.Utils.extend({}, s), this.type = U.TEXT, this.physicsType = U.SPRITE, this.padding = new U.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = o, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, U.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(s), "" !== o && this.updateText()
        }, U.Text.prototype = Object.create(U.Sprite.prototype), U.Text.prototype.constructor = U.Text, U.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.Text.prototype.update = function() {}, U.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), U.Component.Destroy.prototype.destroy.call(this, t)
        }, U.Text.prototype.setShadow = function(t, e, i, o, s, n) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === o && (o = 0), void 0 === s && (s = !0), void 0 === n && (n = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = o, this.style.shadowStroke = s, this.style.shadowFill = n, this.dirty = !0, this
        }, U.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
            var i = this.fontToComponents(t.font);
            return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
        }, U.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(/(?:\r\n|\r|\n)/),
                i = this.style.tabs,
                o = [],
                s = 0,
                n = this.determineFontProperties(this.style.font),
                r = e.length;
            0 < this.style.maxLines && this.style.maxLines < e.length && (r = this.style.maxLines);
            for (var a = this._charCount = 0; a < r; a++) {
                if (0 === i) {
                    var h = this.style.strokeThickness + this.padding.x;
                    0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                } else {
                    var l = e[a].split(/(?:\t)/);
                    h = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var d = 0, c = 0; c < l.length; c++) {
                            var u = 0;
                            u = 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(l[c]) : Math.ceil(this.context.measureText(l[c]).width), 0 < c && (d += i[c - 1]), h = d + u
                        } else
                            for (c = 0; c < l.length; c++) {
                                0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(l[c]) : h += Math.ceil(this.context.measureText(l[c]).width), h += this.game.math.snapToCeil(h, i) - h
                            }
                }
                o[a] = Math.ceil(h), s = Math.max(s, o[a])
            }
            this.canvas.width = s * this._res;
            var p, b, m = n.fontSize + this.style.strokeThickness + this.padding.y,
                y = m * r,
                f = this._lineSpacing;
            for (f < 0 && Math.abs(f) > m && (f = -m), 0 !== f && (y += 0 < f ? f * e.length : f * (e.length - 1)), this.canvas.height = y * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", a = this._charCount = 0; a < r; a++) p = this.style.strokeThickness / 2, b = this.style.strokeThickness / 2 + a * m + n.ascent, 0 < a && (b += f * a), "right" === this.style.align ? p += s - o[a] : "center" === this.style.align && (p += (s - o[a]) / 2), this.autoRound && (p = Math.round(p), b = Math.round(b)), 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.updateLine(e[a], p, b) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, b) : this.renderTabLine(e[a], p, b, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, b) : this.renderTabLine(e[a], p, b, !0)));
            this.updateTexture(), this.dirty = !1
        }, U.Text.prototype.renderTabLine = function(t, e, i, o) {
            var s = t.split(/(?:\t)/),
                n = this.style.tabs,
                r = 0;
            if (Array.isArray(n))
                for (var a = 0, h = 0; h < s.length; h++) 0 < h && (a += n[h - 1]), r = e + a, o ? this.context.fillText(s[h], r, i) : this.context.strokeText(s[h], r, i);
            else
                for (h = 0; h < s.length; h++) {
                    var l = Math.ceil(this.context.measureText(s[h]).width);
                    r = this.game.math.snapToCeil(e, n), o ? this.context.fillText(s[h], r, i) : this.context.strokeText(s[h], r, i), e = r + l
                }
        }, U.Text.prototype.updateShadow = function(t) {
            this.context.shadowBlur = t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0)
        }, U.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var o = t[i];
                if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                    var s = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(o).width, this._charCount++
            }
            return Math.ceil(e)
        }, U.Text.prototype.updateLine = function(t, e, i) {
            for (var o = 0; o < t.length; o++) {
                var s = t[o];
                if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(s, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(s, e, i)), e += this.context.measureText(s).width, this._charCount++
            }
        }, U.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, U.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, U.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, U.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, U.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, U.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, U.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, U.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, U.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, o = "", s = t.replace(/ +/gi, " ").split(/\r?\n/gi), n = s.length, r = 0; r < n; r++) {
                var a = s[r],
                    h = "";
                if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) o += a + "\n";
                else {
                    for (var l = i, d = a.split(" "), c = 0; c < d.length; c++) {
                        var u = d[c],
                            p = u + " ",
                            b = e.measureText(p).width;
                        if (l < b) {
                            if (0 === c) {
                                for (var m = p; m.length && (m = m.slice(0, -1), !((b = e.measureText(m).width) <= l)););
                                if (!m.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var y = u.substr(m.length);
                                d[c] = y, h += m
                            }
                            var f = d[c].length ? c : c + 1,
                                x = d.slice(f).join(" ").replace(/[ \n]*$/gi, "");
                            s[r + 1] = x + " " + (s[r + 1] || ""), n = s.length;
                            break
                        }
                        h += p, l -= b
                    }
                    o += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return o = o.replace(/[\s|\n]*$/gi, "")
        }, U.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), o = 0; o < i.length; o++) {
                for (var s = this.style.wordWrapWidth, n = i[o].split(" "), r = 0; r < n.length; r++) {
                    var a = this.context.measureText(n[r]).width,
                        h = a + this.context.measureText(" ").width;
                    s < h ? (0 < r && (e += "\n"), e += n[r] + " ", s = this.style.wordWrapWidth - a) : (s -= h, e += n[r] + " ")
                }
                o < i.length - 1 && (e += "\n")
            }
            return e
        }, U.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, U.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return {
                font: t
            }
        }, U.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, U.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
        }, U.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, U.Text.prototype.setTextBounds = function(t, e, i, o) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, o) : this.textBounds = new U.Rectangle(t, e, i, o), this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)), this.updateTexture(), this
        }, U.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                o = this.canvas.width,
                s = this.canvas.height;
            if (t.width = o, t.height = s, e.width = o, e.height = s, i.width = o, i.height = s, this.texture.width = o, this.texture.height = s, this._width = o, this._height = s, this.textBounds) {
                var n = this.textBounds.x,
                    r = this.textBounds.y;
                "right" === this.style.boundsAlignH ? n += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (n += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? r += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (r += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -n, this.pivot.y = -r
            }
            this.renderable = 0 !== o && 0 !== s, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, U.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, U.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, U.Text.prototype.determineFontProperties = function(t) {
            var e = U.Text.fontPropertiesCache[t];
            if (!e) {
                e = {};
                var i = U.Text.fontPropertiesCanvas,
                    o = U.Text.fontPropertiesContext;
                o.font = t;
                var s = Math.ceil(o.measureText("|Mq").width),
                    n = Math.ceil(o.measureText("|Mq").width),
                    r = 2 * n;
                if (n = 1.4 * n | 0, i.width = s, i.height = r, o.fillStyle = "#f00", o.fillRect(0, 0, s, r), o.font = t, o.textBaseline = "alphabetic", o.fillStyle = "#000", o.fillText("|Mq", 0, n), !o.getImageData(0, 0, s, r)) return e.ascent = n, e.descent = n + 6, e.fontSize = e.ascent + e.descent, U.Text.fontPropertiesCache[t] = e;
                var a, h, l = o.getImageData(0, 0, s, r).data,
                    d = l.length,
                    c = 4 * s,
                    u = 0,
                    p = !1;
                for (a = 0; a < n; a++) {
                    for (h = 0; h < c; h += 4)
                        if (255 !== l[u + h]) {
                            p = !0;
                            break
                        }
                    if (p) break;
                    u += c
                }
                for (e.ascent = n - a, u = d - c, p = !1, a = r; n < a; a--) {
                    for (h = 0; h < c; h += 4)
                        if (255 !== l[u + h]) {
                            p = !0;
                            break
                        }
                    if (p) break;
                    u -= c
                }
                e.descent = a - n, e.descent += 6, e.fontSize = e.ascent + e.descent, U.Text.fontPropertiesCache[t] = e
            }
            return e
        }, U.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, Object.defineProperty(U.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(U.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(U.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                t !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(U.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(U.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(U.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), U.Text.fontPropertiesCache = {}, U.Text.fontPropertiesCanvas = document.createElement("canvas"), U.Text.fontPropertiesContext = U.Text.fontPropertiesCanvas.getContext("2d"), U.BitmapText = function(t, e, i, o, s, n, r) {
            e = e || 0, i = i || 0, o = o || "", s = s || "", n = n || 32, r = r || "left", PIXI.DisplayObjectContainer.call(this), this.type = U.BITMAPTEXT, this.physicsType = U.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new U.Point, this._prevAnchor = new U.Point, this._glyphs = [], this._maxWidth = 0, this._text = s.toString() || "", this._data = t.cache.getBitmapFont(o), this._font = o, this._fontSize = n, this._align = r, this._tint = 16777215, this.updateText(), this.dirty = !1, U.Component.Core.init.call(this, t, e, i, "", null)
        }, U.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), U.BitmapText.prototype.constructor = U.BitmapText, U.Component.Core.install.call(U.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), U.BitmapText.prototype.preUpdatePhysics = U.Component.PhysicsBody.preUpdate, U.BitmapText.prototype.preUpdateLifeSpan = U.Component.LifeSpan.preUpdate, U.BitmapText.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.BitmapText.prototype.preUpdateCore = U.Component.Core.preUpdate, U.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.BitmapText.prototype.postUpdate = function() {
            U.Component.PhysicsBody.postUpdate.call(this), U.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === U.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, U.BitmapText.prototype.setText = function(t) {
            this.text = t
        }, U.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var o = 0, s = 0, n = -1, r = 0, a = null, h = 0 < this._maxWidth ? this._maxWidth : null, l = [], d = 0; d < i.length; d++) {
                var c = d === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(d))) return {
                    width: s,
                    text: i.substr(0, d),
                    end: c,
                    chars: l
                };
                var u, p = i.charCodeAt(d),
                    b = t.chars[p];
                void 0 === b && (p = 32, b = t.chars[p]);
                var m = a && b.kerning[a] ? b.kerning[a] : 0;
                if (/(\s)/.test(i.charAt(d)) && (n = d, r = s), u = (m + b.texture.width + b.xOffset) * e, h && h <= s + u && -1 < n) return {
                    width: r || s,
                    text: i.substr(0, d - (d - n)),
                    end: c,
                    chars: l
                };
                s += (b.xAdvance + m) * e, l.push(o + (b.xOffset + m) * e), o += (b.xAdvance + m) * e, a = p
            }
            return {
                width: s,
                text: i,
                end: c,
                chars: l
            }
        }, U.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var o = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), s = 0; s < o.length; s++) {
                for (var n = "", r = o[s], a = 0; a < r.length; a++) n = i.chars[r.charCodeAt(a)] ? n.concat(r[a]) : n.concat(e);
                o[s] = n
            }
            return o.join("\n")
        }, U.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    o = [],
                    s = 0;
                this.textWidth = 0;
                do {
                    (d = this.scanLine(t, i, e)).y = s, o.push(d), d.width > this.textWidth && (this.textWidth = d.width), s += t.lineHeight * i, e = e.substr(d.text.length + 1)
                } while (!1 === d.end);
                this.textHeight = s;
                for (var n = 0, r = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < o.length; l++) {
                    var d = o[l];
                    "right" === this._align ? r = this.textWidth - d.width : "center" === this._align && (r = (this.textWidth - d.width) / 2);
                    for (var c = 0; c < d.text.length; c++) {
                        var u = d.text.charCodeAt(c),
                            p = t.chars[u];
                        void 0 === p && (u = 32, p = t.chars[u]);
                        var b = this._glyphs[n];
                        b ? b.texture = p.texture : ((b = new PIXI.Sprite(p.texture)).name = d.text[c], this._glyphs.push(b)), b.position.x = d.chars[c] + r - a, b.position.y = d.y + p.yOffset * i - h, b.scale.set(i), b.tint = this.tint, b.texture.requiresReTint = !0, b.parent || this.addChild(b), n++
                    }
                }
                for (l = n; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
            }
        }, U.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, U.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(U.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && 0 < t && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(U.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1
            }
        }), U.RetroFont = function(t, e, i, o, s, n, r, a, h, l) {
            if (!t.cache.checkImageKey(e)) return !1;
            null == n && (n = t.cache.getImage(e).width / i), this.characterWidth = i, this.characterHeight = o, this.characterSpacingX = r || 0, this.characterSpacingY = a || 0, this.characterPerRow = n, this.offsetX = h || 0, this.offsetY = l || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new U.FrameData;
            for (var d = this.offsetX, c = this.offsetY, u = 0, p = 0; p < s.length; p++) {
                var b = this.frameData.addFrame(new U.Frame(p, d, c, this.characterWidth, this.characterHeight));
                this.grabData[s.charCodeAt(p)] = b.index, ++u === this.characterPerRow ? (u = 0, d = this.offsetX, c += this.characterHeight + this.characterSpacingY) : d += this.characterWidth + this.characterSpacingX
            }
            t.cache.updateFrameData(e, this.frameData), this.stamp = new U.Image(t, 0, 0, e, 0), U.RenderTexture.call(this, t, 100, 100, "", U.scaleModes.NEAREST), this.type = U.RETROFONT
        }, U.RetroFont.prototype = Object.create(U.RenderTexture.prototype), U.RetroFont.prototype.constructor = U.RetroFont, U.RetroFont.ALIGN_LEFT = "left", U.RetroFont.ALIGN_RIGHT = "right", U.RetroFont.ALIGN_CENTER = "center", U.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", U.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", U.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", U.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", U.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", U.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", U.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", U.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", U.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", U.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", U.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", U.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
        }, U.RetroFont.prototype.setText = function(t, e, i, o, s, n) {
            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = o || 0, this.align = s || "left", this.autoUpperCase = !n, 0 < t.length && (this.text = t)
        }, U.RetroFont.prototype.buildRetroFontText = function() {
            var t = 0,
                e = 0;
            if (this.clear(), this.multiLine) {
                var i = this._text.split("\n");
                0 < this.fixedWidth ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var o = 0; o < i.length; o++) t = 0, this.align === U.RetroFont.ALIGN_RIGHT ? t = this.width - i[o].length * (this.characterWidth + this.customSpacingX) : this.align === U.RetroFont.ALIGN_CENTER && (t = this.width / 2 - i[o].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(i[o], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
            } else 0 < this.fixedWidth ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === U.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === U.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, U.RetroFont.prototype.pasteLine = function(t, e, i, o) {
            for (var s = 0; s < t.length; s++)
                if (" " === t.charAt(s)) e += this.characterWidth + o;
                else if (0 <= this.grabData[t.charCodeAt(s)] && (this.stamp.frame = this.grabData[t.charCodeAt(s)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + o) > this.width)) break
        }, U.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (0 < this._text.length)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
            return t
        }, U.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var o = this._text[i],
                    s = o.charCodeAt(0);
                (0 <= this.grabData[s] || !t && "\n" === o) && (e = e.concat(o))
            }
            return e
        }, U.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, o = e - this.offsetY, s = this.game.cache.getFrameData(this.stamp.key).getFrames(), n = s.length; n--;) s[n].x += i, s[n].y += o;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(U.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(U.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t, this.buildRetroFontText()
            }
        }), U.Rope = function(t, e, i, o, s, n) {
            this.points = [], this.points = n, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, i = i || 0, o = o || null, s = s || null, this.type = U.ROPE, PIXI.Rope.call(this, U.Cache.DEFAULT, this.points), U.Component.Core.init.call(this, t, e, i, o, s)
        }, U.Rope.prototype = Object.create(PIXI.Rope.prototype), U.Rope.prototype.constructor = U.Rope, U.Component.Core.install.call(U.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), U.Rope.prototype.preUpdatePhysics = U.Component.PhysicsBody.preUpdate, U.Rope.prototype.preUpdateLifeSpan = U.Component.LifeSpan.preUpdate, U.Rope.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.Rope.prototype.preUpdateCore = U.Component.Core.preUpdate, U.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, U.Rope.prototype.reset = function(t, e) {
            return U.Component.Reset.prototype.reset.call(this, t, e), this
        }, Object.defineProperty(U.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                this._updateAnimation = t && "function" == typeof t ? (this._hasUpdateAnimation = !0, t) : (this._hasUpdateAnimation = !1, null)
            }
        }), Object.defineProperty(U.Rope.prototype, "segments", {
            get: function() {
                for (var t, e, i, o, s, n, r, a, h = [], l = 0; l < this.points.length; l++) t = 4 * l, e = this.vertices[t] * this.scale.x, i = this.vertices[t + 1] * this.scale.y, o = this.vertices[t + 4] * this.scale.x, s = this.vertices[t + 3] * this.scale.y, n = U.Math.difference(e, o), r = U.Math.difference(i, s), e += this.world.x, i += this.world.y, a = new U.Rectangle(e, i, n, r), h.push(a);
                return h
            }
        }), U.TileSprite = function(t, e, i, o, s, n, r) {
            e = e || 0, i = i || 0, o = o || 256, s = s || 256, n = n || null, r = r || null, this.type = U.TILESPRITE, this.physicsType = U.SPRITE, this._scroll = new U.Point;
            var a = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(a.base), o, s), U.Component.Core.init.call(this, t, e, i, n, r)
        }, U.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), U.TileSprite.prototype.constructor = U.TileSprite, U.Component.Core.install.call(U.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), U.TileSprite.prototype.preUpdatePhysics = U.Component.PhysicsBody.preUpdate, U.TileSprite.prototype.preUpdateLifeSpan = U.Component.LifeSpan.preUpdate, U.TileSprite.prototype.preUpdateInWorld = U.Component.InWorld.preUpdate, U.TileSprite.prototype.preUpdateCore = U.Component.Core.preUpdate, U.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, U.TileSprite.prototype.autoScroll = function(t, e) {
            this._scroll.set(t, e)
        }, U.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        }, U.TileSprite.prototype.destroy = function(t) {
            U.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
        }, U.TileSprite.prototype.reset = function(t, e) {
            return U.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, U.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.wechatMinigame = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, U.Device = new U.Device, U.Device.onInitialized = new U.Signal, U.Device.whenReady = function(t, e, i) {
            var o = this._readyCheck;
            if (this.deviceReadyAt || !o) t.call(e, this);
            else if (o._monitor || i) o._queue = o._queue || [], o._queue.push([t, e]);
            else {
                o._monitor = o.bind(this), o._queue = o._queue || [], o._queue.push([t, e]);
                var s = void 0 !== window.cordova,
                    n = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(o._monitor, 0) : s && !n ? document.addEventListener("deviceready", o._monitor, !1) : (document.addEventListener("DOMContentLoaded", o._monitor, !1), window.addEventListener("load", o._monitor, !1))
            }
        }, U.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    var e;
                    for (this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this); e = t._queue.shift();) {
                        var i = e[0],
                            o = e[1];
                        i.call(o, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, U.Device._initialize = function() {
            var t, e, i, s = this;
            ! function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? s.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? s.kindle = !0 : /Android/.test(t) ? s.android = !0 : /CrOS/.test(t) ? s.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (s.iOS = !0, navigator.appVersion.match(/OS (\d+)/), s.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? s.linux = !0 : /Mac OS/.test(t) ? s.macOS = !0 : /Windows/.test(t) && (s.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (s.android = !1, s.iOS = !1, s.macOS = !1, s.windows = !0, s.windowsPhone = !0);
                var e = /Silk/.test(t);
                (s.windows || s.macOS || s.linux && !e || s.chromeOS) && (s.desktop = !0), (s.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (s.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? s.arora = !0 : /Edge\/\d+/.test(t) ? s.edge = !0 : /Chrome\/(\d+)/.test(t) && !s.windowsPhone ? (s.chrome = !0, s.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? s.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (s.firefox = !0, s.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && s.iOS ? s.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (s.ie = !0, s.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? s.midori = !0 : /Opera/.test(t) ? s.opera = !0 : /Safari\/(\d+)/.test(t) && !s.windowsPhone ? (s.safari = !0, /Version\/(\d+)\./.test(t) && (s.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (s.ie = !0, s.trident = !0, s.tridentVersion = parseInt(RegExp.$1, 10), s.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (s.silk = !0), navigator.standalone && (s.webApp = !0), void 0 !== window.cordova && (s.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (s.node = !0), s.node && "object" == typeof process.versions && (s.nodeWebkit = !!process.versions["node-webkit"], s.electron = !!process.versions.electron), navigator.isCocoonJS && (s.cocoonJS = !0), void 0 !== window.wx && (s.wechatMinigame = !0), s.cocoonJS) try {
                    s.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    s.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (s.ejecta = !0), /Crosswalk/.test(t) && (s.crosswalk = !0)
            }(),
            function() {
                s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (s.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (s.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (s.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (s.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (s.edge) s.dolby = !0;
                        else if (s.safari && 9 <= s.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var e = parseInt(RegExp.$1, 10),
                            i = parseInt(RegExp.$2, 10);
                        (10 === e && 11 <= i || 10 < e) && (s.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (s.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.h264Video = !0, s.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (s.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (s.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"),
                    i = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                for (var o in document.body.insertBefore(e, null), i) void 0 !== e.style[o] && (e.style[o] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[o]));
                document.body.removeChild(e), s.css3D = void 0 !== t && 0 < t.length && "none" !== t
            }(), s.pixelRatio = window.devicePixelRatio || 1, s.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), s.iPhone4 = 2 === s.pixelRatio && s.iPhone, s.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? s.typedArray = !0 : s.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (s.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null), s.LITTLE_ENDIAN = s.littleEndian), s.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== s.littleEndian && function() {
                    if (void 0 === Uint8ClampedArray) return !1;
                    var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d");
                    if (!t) return !1;
                    var e = t.createImageData(1, 1);
                    return PIXI.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
                }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (s.vibration = !0),
                function() {
                    s.canvas = !!window.CanvasRenderingContext2D || s.cocoonJS;
                    try {
                        s.localStorage = !!localStorage.getItem
                    } catch (t) {
                        s.localStorage = !1
                    }
                    s.file = !!(window.File && window.FileReader && window.FileList && window.Blob), s.fileSystem = !!window.requestFileSystem;
                    var e = {
                        stencil: !0
                    };
                    s.webGL = function() {
                        try {
                            var t = document.createElement("canvas");
                            return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl", e) || t.getContext("experimental-webgl", e))
                        } catch (t) {
                            return !1
                        }
                    }(), s.webGL = !!s.webGL, s.worker = !!window.Worker, s.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, s.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, s.getUserMedia = s.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (s.getUserMedia = !1), !s.iOS && (s.ie || s.firefox || s.chrome) && (s.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (s.canvasBitBltShift = !1)
                }(),
                function() {
                    for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                        if (e[t[i]]) {
                            s.fullscreen = !0, s.requestFullscreen = t[i];
                            break
                        }
                    var o = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (s.fullscreen)
                        for (i = 0; i < o.length; i++)
                            if (document[o[i]]) {
                                s.cancelFullscreen = o[i];
                                break
                            }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (s.fullscreenKeyboard = !0)
                }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && 1 <= window.navigator.maxTouchPoints) && (s.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (s.mspointer = !0), s.cocoonJS || ("onwheel" in window || s.ie && "WheelEvent" in window ? s.wheelEvent = "wheel" : "onmousewheel" in window ? s.wheelEvent = "mousewheel" : s.firefox && "MouseScrollEvent" in window && (s.wheelEvent = "DOMMouseScroll"))
        }, U.Device.canPlayAudio = function(t) {
            return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
        }, U.Device.canPlayVideo = function(t) {
            return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
        }, U.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && 0 < console.profiles.length
        }, U.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, U.Canvas = {
            create: function(t, e, i, o, s) {
                e = e || 256, i = i || 256;
                var n = s ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                return "string" == typeof o && "" !== o && (n.id = o), n.width = e, n.height = i, n.style.display = "block", n
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var o;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? o = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (o = e)), o || (o = document.body), i && o.style && (o.style.overflow = "hidden"), o.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, o, s, n, r) {
                return t.setTransform(o, n, r, s, e, i), t
            },
            setSmoothingEnabled: function(t, e) {
                var i = U.Canvas.getSmoothingPrefix(t);
                return i && (t[i] = e), t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var o = e[i] + "mageSmoothingEnabled";
                    if (o in t) return o
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var e = U.Canvas.getSmoothingPrefix(t);
                if (e) return t[e]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, U.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], o = 0; o < i.length && !window.requestAnimationFrame; o++) window.requestAnimationFrame = window[i[o] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[o] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, U.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var e = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return e.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(t) {
                    return e.updateRAF(t)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, U.RequestAnimationFrame.prototype.constructor = U.RequestAnimationFrame, U.Math = {
            PI2: 2 * Math.PI,
            between: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), e - i < t
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.round(t * o) / o
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.floor(t * o) / o
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.ceil(t * o) / o
            },
            rotateToAngle: function(t, e, i) {
                return void 0 === i && (i = .05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= U.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += U.Math.PI2 : e -= U.Math.PI2), t < e ? t += i : e < t && (t -= i))), t
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, o) {
                return Math.atan2(o - e, i - t)
            },
            angleBetweenY: function(t, e, i, o) {
                return Math.atan2(i - t, o - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return 0 <= (t %= 2 * Math.PI) ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var o = i - e;
                if (o <= 0) return 0;
                var s = (t - e) % o;
                return s < 0 && (s += o), s + e
            },
            wrapValue: function(t, e, i) {
                return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else t = arguments;
                for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else t = arguments;
                for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else e = arguments.slice(1);
                for (var i = 1, o = 0, s = e.length; i < s; i++) e[i][t] < e[o][t] && (o = i);
                return e[o][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else e = arguments.slice(1);
                for (var i = 1, o = 0, s = e.length; i < s; i++) e[i][t] > e[o][t] && (o = i);
                return e[o][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    o = i * e,
                    s = Math.floor(o);
                return e < 0 ? this.linear(t[0], t[1], o) : 1 < e ? this.linear(t[i], t[i - 1], i - o) : this.linear(t[s], t[i < s + 1 ? i : s + 1], o - s)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, o = t.length - 1, s = 0; s <= o; s++) i += Math.pow(1 - e, o - s) * Math.pow(e, s) * t[s] * this.bernstein(o, s);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    o = i * e,
                    s = Math.floor(o);
                return t[0] === t[i] ? (e < 0 && (s = Math.floor(o = i * (1 + e))), this.catmullRom(t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i], o - s)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -o) - t[0]) : 1 < e ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], o - i) - t[i]) : this.catmullRom(t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2], o - s)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, o, s) {
                var n = .5 * (i - t),
                    r = .5 * (o - e),
                    a = s * s;
                return (2 * e - 2 * i + n + r) * (s * a) + (-3 * e + 3 * i - 2 * n - r) * a + n * s + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return 0 < t ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, o) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === o && (o = 1);
                for (var s = e, n = i, r = o * Math.PI / t, a = [], h = [], l = 0; l < t; l++) s += (n -= s * r) * r, a[l] = n, h[l] = s;
                return {
                    sin: h,
                    cos: a,
                    length: t
                }
            },
            distance: function(t, e, i, o) {
                var s = t - i,
                    n = e - o;
                return Math.sqrt(s * s + n * n)
            },
            distanceSq: function(t, e, i, o) {
                var s = t - i,
                    n = e - o;
                return s * s + n * n
            },
            distancePow: function(t, e, i, o, s) {
                return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(o - e, s))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, o, s) {
                return o + (t - e) * (s - o) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : 0 < t ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), e < t || e < i ? 1 : t < i || t < i ? 0 : (t - i) / e
            }
        };
        var r = Math.PI / 180,
            a = 180 / Math.PI;
        return U.Math.degToRad = function(t) {
            return t * r
        }, U.Math.radToDeg = function(t) {
            return t * a
        }, U.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, U.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, o;
                for (o = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (o += t.charCodeAt(i)), e -= o = e >>> 0, o = (e *= o) >>> 0, o += 4294967296 * (e -= o);
                return 2.3283064365386963e-10 * (o >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 11102230246251565e-32 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = "",
                    e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, U.RandomDataGenerator.prototype.constructor = U.RandomDataGenerator, U.QuadTree = function(t, e, i, o, s, n, r) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, o, s, n, r)
        }, U.QuadTree.prototype = {
            reset: function(t, e, i, o, s, n, r) {
                this.maxObjects = s || 10, this.maxLevels = n || 4, this.level = r || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: o,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(o / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(o / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new U.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new U.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new U.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new U.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            },
            retrieve: function(t) {
                if (t instanceof U.Rectangle) var e = this.objects,
                    i = this.getIndex(t);
                else {
                    if (!t.body) return this._empty;
                    e = this.objects, i = this.getIndex(t.body)
                }
                return this.nodes[0] && (e = -1 !== i ? e.concat(this.nodes[i].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, U.QuadTree.prototype.constructor = U.QuadTree, U.Net = function(t) {
            this.game = t
        }, U.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(t) {
                return -1 !== window.location.hostname.indexOf(t)
            },
            updateQueryString: function(t, e, i, o) {
                void 0 === i && (i = !1), void 0 !== o && "" !== o || (o = window.location.href);
                var s = "",
                    n = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                if (n.test(o)) s = null != e ? o.replace(n, "$1" + t + "=" + e + "$2$3") : o.replace(n, "$1$3").replace(/(&|\?)$/, "");
                else if (null != e) {
                    var r = -1 !== o.indexOf("?") ? "&" : "?",
                        a = o.split("#");
                    o = a[0] + r + t + "=" + e, a[1] && (o += "#" + a[1]), s = o
                } else s = o;
                if (!i) return s;
                window.location.href = s
            },
            getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {},
                    i = location.search.substring(1).split("&");
                for (var o in i) {
                    var s = i[o].split("=");
                    if (1 < s.length) {
                        if (t && t === this.decodeURI(s[0])) return this.decodeURI(s[1]);
                        e[this.decodeURI(s[0])] = this.decodeURI(s[1])
                    }
                }
                return e
            },
            decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        }, U.Net.prototype.constructor = U.Net, U.TweenManager = function(t) {
            this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: U.Easing.Power0,
                Power1: U.Easing.Power1,
                Power2: U.Easing.Power2,
                Power3: U.Easing.Power3,
                Power4: U.Easing.Power4,
                Linear: U.Easing.Linear.None,
                Quad: U.Easing.Quadratic.Out,
                Cubic: U.Easing.Cubic.Out,
                Quart: U.Easing.Quartic.Out,
                Quint: U.Easing.Quintic.Out,
                Sine: U.Easing.Sinusoidal.Out,
                Expo: U.Easing.Exponential.Out,
                Circ: U.Easing.Circular.Out,
                Elastic: U.Easing.Elastic.Out,
                Back: U.Easing.Back.Out,
                Bounce: U.Easing.Bounce.Out,
                "Quad.easeIn": U.Easing.Quadratic.In,
                "Cubic.easeIn": U.Easing.Cubic.In,
                "Quart.easeIn": U.Easing.Quartic.In,
                "Quint.easeIn": U.Easing.Quintic.In,
                "Sine.easeIn": U.Easing.Sinusoidal.In,
                "Expo.easeIn": U.Easing.Exponential.In,
                "Circ.easeIn": U.Easing.Circular.In,
                "Elastic.easeIn": U.Easing.Elastic.In,
                "Back.easeIn": U.Easing.Back.In,
                "Bounce.easeIn": U.Easing.Bounce.In,
                "Quad.easeOut": U.Easing.Quadratic.Out,
                "Cubic.easeOut": U.Easing.Cubic.Out,
                "Quart.easeOut": U.Easing.Quartic.Out,
                "Quint.easeOut": U.Easing.Quintic.Out,
                "Sine.easeOut": U.Easing.Sinusoidal.Out,
                "Expo.easeOut": U.Easing.Exponential.Out,
                "Circ.easeOut": U.Easing.Circular.Out,
                "Elastic.easeOut": U.Easing.Elastic.Out,
                "Back.easeOut": U.Easing.Back.Out,
                "Bounce.easeOut": U.Easing.Bounce.Out,
                "Quad.easeInOut": U.Easing.Quadratic.InOut,
                "Cubic.easeInOut": U.Easing.Cubic.InOut,
                "Quart.easeInOut": U.Easing.Quartic.InOut,
                "Quint.easeInOut": U.Easing.Quintic.InOut,
                "Sine.easeInOut": U.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": U.Easing.Exponential.InOut,
                "Circ.easeInOut": U.Easing.Circular.InOut,
                "Elastic.easeInOut": U.Easing.Elastic.InOut,
                "Back.easeInOut": U.Easing.Back.InOut,
                "Bounce.easeInOut": U.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, U.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(t, e) {
                if (void 0 === e && (e = !0), Array.isArray(t))
                    for (i = 0, o = t.length; i < o; i++) this.removeFrom(t[i]);
                else if (t.type === U.GROUP && e)
                    for (var i = 0, o = t.children.length; i < o; i++) this.removeFrom(t.children[i]);
                else {
                    for (i = 0, o = this._tweens.length; i < o; i++) t === this._tweens[i].target && this.remove(this._tweens[i]);
                    for (i = 0, o = this._add.length; i < o; i++) t === this._add[i].target && this.remove(this._add[i])
                }
            },
            add: function(t) {
                (t._manager = this)._add.push(t)
            },
            create: function(t) {
                return new U.Tween(t, this.game, this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length,
                    e = this._tweens.length;
                if (0 === e && 0 === t) return !1;
                for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                return 0 < t && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(e) {
                return this._tweens.some(function(t) {
                    return t.target === e
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].resume(!0)
            }
        }, U.TweenManager.prototype.constructor = U.TweenManager, U.Tween = function(t, e, i) {
            this.game = e, this.target = t, this.manager = i, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new U.Signal, this.onLoop = new U.Signal, this.onRepeat = new U.Signal, this.onChildComplete = new U.Signal, this.onComplete = new U.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = i.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, U.Tween.prototype = {
            to: function(t, e, i, o, s, n, r) {
                return (void 0 === e || e <= 0) && (e = 1e3), null == i && (i = U.Easing.Default), void 0 === o && (o = !1), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning || (this.timeline.push(new U.TweenData(this).to(t, e, i, s, n, r)), o && this.start()), this
            },
            from: function(t, e, i, o, s, n, r) {
                return void 0 === e && (e = 1e3), null == i && (i = U.Easing.Default), void 0 === o && (o = !1), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning || (this.timeline.push(new U.TweenData(this).from(t, e, i, s, n, r)), o && this.start()), this
            },
            start: function(t) {
                if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (var e = 0; e < this.timeline.length; e++)
                    for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            },
            stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length) return this;
                if (void 0 === i && (i = 0), -1 === i)
                    for (var o = 0; o < this.timeline.length; o++) this.timeline[o][t] = e;
                else this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(t, e, i) {
                return void 0 === e && (e = U.Math), this.updateTweenData("interpolationFunction", t, i), this.updateTweenData("interpolationContext", e, i)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            },
            chain: function() {
                for (var t = arguments.length; t--;) 0 < t ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(t) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var e = this.timeline[this.current].update(t);
                if (e === U.TweenData.PENDING) return !0;
                if (e === U.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (e === U.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (e === U.TweenData.COMPLETE) {
                    var i = !1;
                    return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, i = !0)) : (this.current++, this.current === this.timeline.length && (i = !(this.current = 0))), i ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : 0 < this.repeatCounter ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target) return null;
                void 0 === t && (t = 60), void 0 === e && (e = []);
                for (var i = 0; i < this.timeline.length; i++)
                    for (var o in this.timeline[i].vEnd) this.properties[o] = this.target[o] || 0, Array.isArray(this.properties[o]) || (this.properties[o] *= 1);
                for (i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                for (i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                return e
            }
        }, Object.defineProperty(U.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                return t
            }
        }), U.Tween.prototype.constructor = U.Tween, U.TweenData = function(t) {
            this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = U.Easing.Default, this.interpolationFunction = U.Math.linearInterpolation, this.interpolationContext = U.Math, this.isRunning = !1, this.isFrom = !1
        }, U.TweenData.PENDING = 0, U.TweenData.RUNNING = 1, U.TweenData.LOOPED = 2, U.TweenData.COMPLETE = 3, U.TweenData.prototype = {
            to: function(t, e, i, o, s, n) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = s, this.yoyo = n, this.isFrom = !1, this
            },
            from: function(t, e, i, o, s, n) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = s, this.yoyo = n, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, 0 < this.delay ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(t) {
                if (this.isRunning) {
                    if (t < this.startTime) return U.TweenData.RUNNING
                } else {
                    if (!(t >= this.startTime)) return U.TweenData.PENDING;
                    this.isRunning = !0
                }
                var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                for (var i in this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                    var o = this.vStart[i],
                        s = this.vEnd[i];
                    Array.isArray(s) ? this.parent.target[i] = this.interpolationFunction.call(this.interpolationContext, s, this.value) : this.parent.target[i] = o + (s - o) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : U.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [],
                    i = !1,
                    o = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= o, this.dt = Math.max(this.dt, 0)) : (this.dt += o, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var s = {};
                    for (var n in this.vEnd) {
                        var r = this.vStart[n],
                            a = this.vEnd[n];
                        Array.isArray(a) ? s[n] = this.interpolationFunction(a, this.value) : s[n] = r + (a - r) * this.value
                    }
                    e.push(s), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1, U.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return U.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                else {
                    for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    0 < this.repeatCounter && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, U.TweenData.LOOPED
            }
        }, U.TweenData.prototype.constructor = U.TweenData, U.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    return t * t * (2.70158 * t - 1.70158)
                },
                Out: function(t) {
                    return --t * t * (2.70158 * t + 1.70158) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - U.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * U.Easing.Bounce.In(2 * t) : .5 * U.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, U.Easing.Default = U.Easing.Linear.None, U.Easing.Power0 = U.Easing.Linear.None, U.Easing.Power1 = U.Easing.Quadratic.Out, U.Easing.Power2 = U.Easing.Cubic.Out, U.Easing.Power3 = U.Easing.Quartic.Out, U.Easing.Power4 = U.Easing.Quintic.Out, U.Time = function(t) {
            this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new U.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, U.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t), t
            },
            create: function(t) {
                void 0 === t && (t = !0);
                var e = new U.Timer(this.game, t);
                return this._timers.push(e), e
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
            },
            updateAdvancedTiming: function() {
                this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for (var t = this._timers.length; t--;) this._timers[t]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for (var t = this._timers.length; t--;) this._timers[t]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(U.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
            }
        }), U.Time.prototype.constructor = U.Time, U.Timer = function(t, e) {
            void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new U.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, U.Timer.MINUTE = 6e4, U.Timer.SECOND = 1e3, U.Timer.HALF = 500, U.Timer.QUARTER = 250, U.Timer.prototype = {
            create: function(t, e, i, o, s, n) {
                var r = t = Math.round(t);
                0 === this._now ? r += this.game.time.time : r += this._now;
                var a = new U.TimerEvent(this, t, r, i, e, o, s, n);
                return this.events.push(a), this.order(), this.expired = !1, a
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, o) {
                return this.create(t, !1, e, i, o, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.time + (t || 0), this.running = !0;
                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0;
                return !1
            },
            order: function() {
                0 < this.events.length && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(t) {
                if (this.paused) return !0;
                if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && 0 < this._len) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? this.events[this._i].tick = this._newTick : 0 < this.events[this._i].repeatCount ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick) : (this._marked++, this.events[this._i].pendingDelete = !0), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i
                    }
                var o = this.nextTick - t;
                this.nextTick = o < 0 ? this._now : this._now + o
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(U.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(U.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(U.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(U.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(U.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), U.Timer.prototype.constructor = U.Timer, U.TimerEvent = function(t, e, i, o, s, n, r, a) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = o - 1, this.loop = s, this.callback = n, this.callbackContext = r, this.args = a, this.pendingDelete = !1
        }, U.TimerEvent.prototype.constructor = U.TimerEvent, U.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, U.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t) return !1;
                if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                return this._frameData = t, null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
            },
            add: function(t, e, i, o, s) {
                return e = e || [], i = i || 60, void 0 === o && (o = !1), void 0 === s && (s = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, s, this._outputFrames), this._anims[t] = new U.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, o), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total) return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                return !0
            },
            play: function(t, e, i, o) {
                if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, o)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, o))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                var t = null;
                for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, U.AnimationManager.prototype.constructor = U.AnimationManager, Object.defineProperty(U.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(U.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(U.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(U.AnimationManager.prototype, "name", {
            get: function() {
                if (this.currentAnim) return this.currentAnim.name
            }
        }), Object.defineProperty(U.AnimationManager.prototype, "frame", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.index
            },
            set: function(t) {
                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(U.AnimationManager.prototype, "frameName", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.name
            },
            set: function(t) {
                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) && (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)))
            }
        }), U.Animation = function(t, e, i, o, s, n, r) {
            void 0 === r && (r = !1), this.game = t, this._parent = e, this._frameData = o, this.name = i, this._frames = [], this._frames = this._frames.concat(s), this.delay = 1e3 / n, this.loop = r, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new U.Signal, this.onUpdate = null, this.onComplete = new U.Signal, this.onLoop = new U.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, U.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1), "string" == typeof t)
                    for (var o = 0; o < this._frames.length; o++) this._frameData.getFrame(this._frames[o]).name === t && (i = o);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (o = 0; o < this._frames.length; o++) this._frames[o] === t && (i = o);
                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
            },
            stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1), !this._frameData) return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, U.Animation.prototype.constructor = U.Animation, Object.defineProperty(U.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                (this.isPaused = t) ? this._pauseStartTime = this.game.time.time: this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(U.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(U.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(U.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(U.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                0 < t && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(U.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new U.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), U.Animation.generateFrameNames = function(t, e, i, o, s) {
            void 0 === o && (o = "");
            var n = [],
                r = "";
            if (e < i)
                for (var a = e; a <= i; a++) r = t + (r = "number" == typeof s ? U.Utils.pad(a.toString(), s, "0", 1) : a.toString()) + o, n.push(r);
            else
                for (a = e; i <= a; a--) r = t + (r = "number" == typeof s ? U.Utils.pad(a.toString(), s, "0", 1) : a.toString()) + o, n.push(r);
            return n
        }, U.Frame = function(t, e, i, o, s, n) {
            this.index = t, this.x = e, this.y = i, this.width = o, this.height = s, this.name = n, this.centerX = Math.floor(o / 2), this.centerY = Math.floor(s / 2), this.distance = U.Math.distance(0, 0, o, s), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = o, this.sourceSizeH = s, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, U.Frame.prototype = {
            resize: function(t, e) {
                this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = U.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
            },
            setTrim: function(t, e, i, o, s, n, r) {
                (this.trimmed = t) && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = o, this.spriteSourceSizeY = s, this.spriteSourceSizeW = n, this.spriteSourceSizeH = r)
            },
            clone: function() {
                var t = new U.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                return t
            },
            getRect: function(t) {
                return void 0 === t ? t = new U.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }
        }, U.Frame.prototype.constructor = U.Frame, U.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, U.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var t = new U.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                for (var i in this._frameNames) this._frameNames.hasOwnProperty(i) && t._frameNames.push(this._frameNames[i]);
                return t
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var o = t; o <= e; o++) i.push(this._frames[o]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (var o = 0; o < this._frames.length; o++) i.push(this._frames[o]);
                else
                    for (o = 0; o < t.length; o++) e ? i.push(this.getFrame(t[o])) : i.push(this.getFrameByName(t[o]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (var o = 0; o < this._frames.length; o++) i.push(this._frames[o].index);
                else
                    for (o = 0; o < t.length; o++) e && this._frames[t[o]] ? i.push(this._frames[t[o]].index) : this.getFrameByName(t[o]) && i.push(this.getFrameByName(t[o]).index);
                return i
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, U.FrameData.prototype.constructor = U.FrameData, Object.defineProperty(U.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), U.AnimationParser = {
            spriteSheet: function(t, e, i, o, s, n, r) {
                var a = e;
                if ("string" == typeof e && (a = t.cache.getImage(e)), null === a) return null;
                var h = a.width,
                    l = a.height;
                i <= 0 && (i = Math.floor(-h / Math.min(-1, i))), o <= 0 && (o = Math.floor(-l / Math.min(-1, o)));
                var d = Math.floor((h - n) / (i + r)) * Math.floor((l - n) / (o + r));
                if (-1 !== s && (d = s), 0 === h || 0 === l || h < i || l < o || 0 === d) return null;
                for (var c = new U.FrameData, u = n, p = n, b = 0; b < d; b++) c.addFrame(new U.Frame(b, u, p, i, o, "")), h < (u += i + r) + i && (u = n, p += o + r);
                return c
            },
            JSONData: function(t, e) {
                if (e.frames) {
                    for (var i, o = new U.FrameData, s = e.frames, n = 0; n < s.length; n++) i = o.addFrame(new U.Frame(n, s[n].frame.x, s[n].frame.y, s[n].frame.w, s[n].frame.h, s[n].filename)), s[n].trimmed && i.setTrim(s[n].trimmed, s[n].sourceSize.w, s[n].sourceSize.h, s[n].spriteSourceSize.x, s[n].spriteSourceSize.y, s[n].spriteSourceSize.w, s[n].spriteSourceSize.h);
                    return o
                }
            },
            JSONDataPyxel: function(t, e) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                        e[t]
                    }), 1 === e.layers.length) {
                    for (var i = new U.FrameData, o = e.tileheight, s = e.tilewidth, n = e.layers[0].tiles, r = 0; r < n.length; r++) i.addFrame(new U.Frame(r, n[r].x, n[r].y, s, o, "frame_" + r)).setTrim(!1);
                    return i
                }
            },
            JSONDataHash: function(t, e) {
                if (e.frames) {
                    var i, o = new U.FrameData,
                        s = e.frames,
                        n = 0;
                    for (var r in s) i = o.addFrame(new U.Frame(n, s[r].frame.x, s[r].frame.y, s[r].frame.w, s[r].frame.h, r)), s[r].trimmed && i.setTrim(s[r].trimmed, s[r].sourceSize.w, s[r].sourceSize.h, s[r].spriteSourceSize.x, s[r].spriteSourceSize.y, s[r].spriteSourceSize.w, s[r].spriteSourceSize.h), n++;
                    return o
                }
            },
            XMLData: function(t, e) {
                if (e.getElementsByTagName("TextureAtlas")) {
                    for (var i, o, s, n, r, a, h, l, d, c, u, p = new U.FrameData, b = e.getElementsByTagName("SubTexture"), m = 0; m < b.length; m++) o = (s = b[m].attributes).name.value, n = parseInt(s.x.value, 10), r = parseInt(s.y.value, 10), a = parseInt(s.width.value, 10), h = parseInt(s.height.value, 10), d = l = null, s.frameX && (l = Math.abs(parseInt(s.frameX.value, 10)), d = Math.abs(parseInt(s.frameY.value, 10)), c = parseInt(s.frameWidth.value, 10), u = parseInt(s.frameHeight.value, 10)), i = p.addFrame(new U.Frame(m, n, r, a, h, o)), null === l && null === d || i.setTrim(!0, a, h, l, d, c, u);
                    return p
                }
            }
        }, U.Cache = function(t) {
            this.game = t, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new U.Signal, this._cacheMap = [], this._cacheMap[U.Cache.CANVAS] = this._cache.canvas, this._cacheMap[U.Cache.IMAGE] = this._cache.image, this._cacheMap[U.Cache.TEXTURE] = this._cache.texture, this._cacheMap[U.Cache.SOUND] = this._cache.sound, this._cacheMap[U.Cache.TEXT] = this._cache.text, this._cacheMap[U.Cache.PHYSICS] = this._cache.physics, this._cacheMap[U.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[U.Cache.BINARY] = this._cache.binary, this._cacheMap[U.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[U.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[U.Cache.JSON] = this._cache.json, this._cacheMap[U.Cache.XML] = this._cache.xml, this._cacheMap[U.Cache.VIDEO] = this._cache.video, this._cacheMap[U.Cache.SHADER] = this._cache.shader, this._cacheMap[U.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
        }, U.Cache.CANVAS = 1, U.Cache.IMAGE = 2, U.Cache.TEXTURE = 3, U.Cache.SOUND = 4, U.Cache.TEXT = 5, U.Cache.PHYSICS = 6, U.Cache.TILEMAP = 7, U.Cache.BINARY = 8, U.Cache.BITMAPDATA = 9, U.Cache.BITMAPFONT = 10, U.Cache.JSON = 11, U.Cache.XML = 12, U.Cache.VIDEO = 13, U.Cache.SHADER = 14, U.Cache.RENDER_TEXTURE = 15, U.Cache.DEFAULT = null, U.Cache.MISSING = null, U.Cache.prototype = {
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(t, e, i) {
                this.checkImageKey(t) && this.removeImage(t);
                var o = {
                    key: t,
                    url: e,
                    data: i,
                    base: new PIXI.BaseTexture(i),
                    frame: new U.Frame(0, 0, 0, i.width, i.height, t),
                    frameData: new U.FrameData
                };
                return o.frameData.addFrame(new U.Frame(0, 0, 0, i.width, i.height, e)), this._cache.image[t] = o, this._resolveURL(e, o), "__default" === t ? U.Cache.DEFAULT = new PIXI.Texture(o.base) : "__missing" === t && (U.Cache.MISSING = new PIXI.Texture(o.base)), o
            },
            addDefaultImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var e = this.addImage("__default", null, t);
                e.base.skipRender = !0, U.Cache.DEFAULT = new PIXI.Texture(e.base)
            },
            addMissingImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var e = this.addImage("__missing", null, t);
                U.Cache.MISSING = new PIXI.Texture(e.base)
            },
            addSound: function(t, e, i, o, s) {
                void 0 === o && (s = !(o = !0)), void 0 === s && (s = !(o = !1));
                var n = !1;
                s && (n = !0), this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: n,
                    webAudio: o,
                    audioTag: s,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, o) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: o
                }, this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, o) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: o
                }, this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(t, e, i) {
                return e.key = t, void 0 === i && (i = new U.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                    data: e,
                    frameData: i
                }, e
            },
            addBitmapFont: function(t, e, i, o, s, n, r) {
                var a = {
                    url: e,
                    data: i,
                    font: null,
                    base: new PIXI.BaseTexture(i)
                };
                void 0 === n && (n = 0), void 0 === r && (r = 0), a.font = "json" === s ? U.LoaderParser.jsonBitmapFont(o, a.base, n, r) : U.LoaderParser.xmlBitmapFont(o, a.base, n, r), this._cache.bitmapFont[t] = a, this._resolveURL(e, a)
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, o) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: o,
                    locked: !0
                }, this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(t, e) {
                this._cache.renderTexture[t] = {
                    texture: e,
                    frame: new U.Frame(0, 0, 0, e.width, e.height, "", "")
                }
            },
            addSpriteSheet: function(t, e, i, o, s, n, r, a) {
                void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === a && (a = 0);
                var h = {
                    key: t,
                    url: e,
                    data: i,
                    frameWidth: o,
                    frameHeight: s,
                    margin: r,
                    spacing: a,
                    base: new PIXI.BaseTexture(i),
                    frameData: U.AnimationParser.spriteSheet(this.game, i, o, s, n, r, a)
                };
                this._cache.image[t] = h, this._resolveURL(e, h)
            },
            addTextureAtlas: function(t, e, i, o, s) {
                var n = {
                    key: t,
                    url: e,
                    data: i,
                    base: new PIXI.BaseTexture(i)
                };
                s === U.Loader.TEXTURE_ATLAS_XML_STARLING ? n.frameData = U.AnimationParser.XMLData(this.game, o, t) : s === U.Loader.TEXTURE_ATLAS_JSON_PYXEL ? n.frameData = U.AnimationParser.JSONDataPyxel(this.game, o, t) : Array.isArray(o.frames) ? n.frameData = U.AnimationParser.JSONData(this.game, o, t) : n.frameData = U.AnimationParser.JSONDataHash(this.game, o, t), this._cache.image[t] = n, this._resolveURL(e, n)
            },
            reloadSound: function(t) {
                var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1), i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var o = this.getSound(t);
                o && (o[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1
            },
            isSoundDecoded: function(t) {
                var e = this.getItem(t, U.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded
            },
            isSoundReady: function(t) {
                var e = this.getItem(t, U.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(t) {
                return this.checkKey(U.Cache.CANVAS, t)
            },
            checkImageKey: function(t) {
                return this.checkKey(U.Cache.IMAGE, t)
            },
            checkTextureKey: function(t) {
                return this.checkKey(U.Cache.TEXTURE, t)
            },
            checkSoundKey: function(t) {
                return this.checkKey(U.Cache.SOUND, t)
            },
            checkTextKey: function(t) {
                return this.checkKey(U.Cache.TEXT, t)
            },
            checkPhysicsKey: function(t) {
                return this.checkKey(U.Cache.PHYSICS, t)
            },
            checkTilemapKey: function(t) {
                return this.checkKey(U.Cache.TILEMAP, t)
            },
            checkBinaryKey: function(t) {
                return this.checkKey(U.Cache.BINARY, t)
            },
            checkBitmapDataKey: function(t) {
                return this.checkKey(U.Cache.BITMAPDATA, t)
            },
            checkBitmapFontKey: function(t) {
                return this.checkKey(U.Cache.BITMAPFONT, t)
            },
            checkJSONKey: function(t) {
                return this.checkKey(U.Cache.JSON, t)
            },
            checkXMLKey: function(t) {
                return this.checkKey(U.Cache.XML, t)
            },
            checkVideoKey: function(t) {
                return this.checkKey(U.Cache.VIDEO, t)
            },
            checkShaderKey: function(t) {
                return this.checkKey(U.Cache.SHADER, t)
            },
            checkRenderTextureKey: function(t) {
                return this.checkKey(U.Cache.RENDER_TEXTURE, t)
            },
            getItem: function(t, e, i, o) {
                return this.checkKey(e, t) ? void 0 === o ? this._cacheMap[e][t] : this._cacheMap[e][t][o] : null
            },
            getCanvas: function(t) {
                return this.getItem(t, U.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(t, e) {
                null == t && (t = "__default"), void 0 === e && (e = !1);
                var i = this.getItem(t, U.Cache.IMAGE, "getImage");
                return null === i && (i = this.getItem("__missing", U.Cache.IMAGE, "getImage")), e ? i : i.data
            },
            getTextureFrame: function(t) {
                return this.getItem(t, U.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(t) {
                return this.getItem(t, U.Cache.SOUND, "getSound")
            },
            getSoundData: function(t) {
                return this.getItem(t, U.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(t) {
                return this.getItem(t, U.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(t, e, i) {
                var o = this.getItem(t, U.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === o || null == e) return o;
                if (o[e]) {
                    var s = o[e];
                    if (!s || !i) return s;
                    for (var n in s)
                        if ((n = s[n]).fixtureKey === i) return n
                }
                return null
            },
            getTilemapData: function(t) {
                return this.getItem(t, U.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(t) {
                return this.getItem(t, U.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(t) {
                return this.getItem(t, U.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(t) {
                return this.getItem(t, U.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(t, e) {
                var i = this.getItem(t, U.Cache.JSON, "getJSON", "data");
                return i ? e ? U.Utils.extend(!0, Array.isArray(i) ? [] : {}, i) : i : null
            },
            getXML: function(t) {
                return this.getItem(t, U.Cache.XML, "getXML", "data")
            },
            getVideo: function(t) {
                return this.getItem(t, U.Cache.VIDEO, "getVideo")
            },
            getShader: function(t) {
                return this.getItem(t, U.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(t) {
                return this.getItem(t, U.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(t, e) {
                return void 0 === e && (e = U.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
            },
            getFrame: function(t, e) {
                return void 0 === e && (e = U.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(t, e) {
                return void 0 === e && (e = U.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
            },
            hasFrameData: function(t, e) {
                return void 0 === e && (e = U.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
            },
            updateFrameData: function(t, e, i) {
                void 0 === i && (i = U.Cache.IMAGE), this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
            },
            getFrameByIndex: function(t, e, i) {
                var o = this.getFrameData(t, i);
                return o ? o.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var o = this.getFrameData(t, i);
                return o ? o.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : null
            },
            getKeys: function(t) {
                void 0 === t && (t = U.Cache.IMAGE);
                var e = [];
                if (this._cacheMap[t])
                    for (var i in this._cacheMap[t]) "__default" !== i && "__missing" !== i && e.push(i);
                return e
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.atlas[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            }
        }, U.Cache.prototype.constructor = U.Cache, U.Loader = function(t) {
            this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new U.Signal, this.onLoadComplete = new U.Signal, this.onPackComplete = new U.Signal, this.onFileStart = new U.Signal, this.onFileComplete = new U.Signal, this.onFileError = new U.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, U.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, U.Loader.TEXTURE_ATLAS_JSON_HASH = 1, U.Loader.TEXTURE_ATLAS_XML_STARLING = 2, U.Loader.PHYSICS_LIME_CORONA_JSON = 3, U.Loader.PHYSICS_PHASER_JSON = 4, U.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, U.Loader.prototype = {
            setPreloadSprite: function(t, e) {
                e = e || 0, this.preloadSprite = {
                    sprite: t,
                    direction: e,
                    width: t.width,
                    height: t.height,
                    rect: null
                }, this.preloadSprite.rect = 0 === e ? new U.Rectangle(0, 0, 1, t.height) : new U.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return -1 < this.getAssetIndex(t, e)
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, o = 0; o < this._fileList.length; o++) {
                    var s = this._fileList[o];
                    if (s.type === t && s.key === e && (i = o, !s.loaded && !s.loading)) break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return -1 < i && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, o, s, n) {
                if (void 0 === s && (s = !1), void 0 === e || "" === e) return this;
                if (null == i) {
                    if (!n) return this;
                    i = e + n
                }
                var r = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: 0 < this._withSyncPointDepth,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (o)
                    for (var a in o) r[a] = o[a];
                var h = this.getAssetIndex(t, e);
                if (s && -1 < h) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(r), this._totalFileCount++) : this._fileList[h] = r
                } else -1 === h && (this._fileList.push(r), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, o) {
                return this.addToFileList(t, e, i, o, !0)
            },
            pack: function(t, e, i, o) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = null), !e && !i) return this;
                var s = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: o
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), s.data = i || {}, s.loaded = !0);
                for (var n = 0; n < this._fileList.length + 1; n++) {
                    var r = this._fileList[n];
                    if (!r || !r.loaded && !r.loading && "packfile" !== r.type) {
                        this._fileList.splice(n, 0, s), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return this.addToFileList("image", t, e, void 0, i, ".png")
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (i = 0; i < t.length; i++) this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, o) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: o
                }, !1, ".js")
            },
            binary: function(t, e, i, o) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: o
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, o, s, n, r) {
                return void 0 === s && (s = -1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: o,
                    frameMax: s,
                    margin: n,
                    spacing: r
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, o, s) {
                return this.game.sound.noAudio || (void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = !0), this.audio(t, e, s), i ? this.json(t + "-audioatlas", i) : o && ("string" == typeof o && (o = JSON.parse(o)), this.cache.addJSON(t + "-audioatlas", "", o))), this
            },
            audiosprite: function(t, e, i, o, s) {
                return this.audioSprite(t, e, i, o, s)
            },
            video: function(t, e, i, o) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === o && (o = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: o,
                    loadEvent: i
                })
            },
            tilemap: function(t, e, i, o) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = U.Tilemap.CSV), e || i || (e = o === U.Tilemap.CSV ? t + ".csv" : t + ".json"), i) {
                    switch (o) {
                        case U.Tilemap.CSV:
                            break;
                        case U.Tilemap.TILED_JSON:
                            "string" == typeof i && (i = JSON.parse(i))
                    }
                    this.cache.addTilemap(t, null, i, o)
                } else this.addToFileList("tilemap", t, e, {
                    format: o
                });
                return this
            },
            physics: function(t, e, i, o) {
                return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = U.Physics.LIME_CORONA_JSON), e || i || (e = t + ".json"), i ? ("string" == typeof i && (i = JSON.parse(i)), this.cache.addPhysicsData(t, null, i, o)) : this.addToFileList("physics", t, e, {
                    format: o
                }), this
            },
            bitmapFont: function(t, e, i, o, s, n) {
                if (null == e && (e = t + ".png"), void 0 === i && (i = null), void 0 === o && (o = null), null === i && null === o && (i = t + ".xml"), void 0 === s && (s = 0), void 0 === n && (n = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: s,
                    ySpacing: n
                });
                else if ("string" == typeof o) {
                    var r, a;
                    try {
                        r = JSON.parse(o)
                    } catch (t) {
                        a = this.parseXml(o)
                    }
                    if (!a && !r) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: r || a,
                        atlasType: r ? "json" : "xml",
                        xSpacing: s,
                        ySpacing: n
                    })
                }
                return this
            },
            atlasJSONArray: function(t, e, i, o) {
                return this.atlas(t, e, i, o, U.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(t, e, i, o) {
                return this.atlas(t, e, i, o, U.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(t, e, i, o) {
                return void 0 === i && (i = null), void 0 === o && (o = null), i || o || (i = t + ".xml"), this.atlas(t, e, i, o, U.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(t, e, i, o, s) {
                if (null == e && (e = t + ".png"), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = U.Loader.TEXTURE_ATLAS_JSON_ARRAY), i || o || (i = s === U.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), i) this.addToFileList("textureatlas", t, e, {
                    atlasURL: i,
                    format: s
                });
                else {
                    switch (s) {
                        case U.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof o && (o = JSON.parse(o));
                            break;
                        case U.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof o) {
                                var n = this.parseXml(o);
                                if (!n) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                o = n
                            }
                    }
                    this.addToFileList("textureatlas", t, e, {
                        atlasURL: null,
                        atlasData: o,
                        format: s
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (this.isLoading) {
                    for (var t = 0; t < this._flightQueue.length; t++) {
                        ((o = this._flightQueue[t]).loaded || o.error) && (this._flightQueue.splice(t, 1), t--, o.loading = !1, o.requestUrl = null, o.requestObject = null, o.error && this.onFileError.dispatch(o.key, o), "packfile" !== o.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, o.key, !o.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === o.type && o.error && (this._loadedPackCount++, this.onPackComplete.dispatch(o.key, !o.error, this._loadedPackCount, this._totalPackCount)))
                    }
                    var e = !1,
                        i = this.enableParallel ? U.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
                    for (t = this._processingHead; t < this._fileList.length; t++) {
                        var o;
                        if ("packfile" === (o = this._fileList[t]).type && !o.error && o.loaded && t === this._processingHead && (this.processPack(o), this._loadedPackCount++, this.onPackComplete.dispatch(o.key, !o.error, this._loadedPackCount, this._totalPackCount)), o.loaded || o.error ? t === this._processingHead && (this._processingHead = t + 1) : !o.loading && this._flightQueue.length < i && ("packfile" !== o.type || o.data ? e || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(o), o.loading = !0, this.onFileStart.dispatch(this.progress, o.key, o.url), this.loadFile(o)) : (this._flightQueue.push(o), o.loading = !0, this.loadFile(o))), !o.loaded && o.syncPoint && (e = !0), this._flightQueue.length >= i || e && this._loadedPackCount === this._totalPackCount) break
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) {
                        var s = this;
                        setTimeout(function() {
                            s.finishedLoading(!0)
                        }, 2e3)
                    }
                } else this.finishedLoading(!0)
            },
            finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e), this.processLoadQueue()
            },
            processPack: function(t) {
                var e = t.data[t.key];
                if (e)
                    for (var i = 0; i < e.length; i++) {
                        var o = e[i];
                        switch (o.type) {
                            case "image":
                                this.image(o.key, o.url, o.overwrite);
                                break;
                            case "text":
                                this.text(o.key, o.url, o.overwrite);
                                break;
                            case "json":
                                this.json(o.key, o.url, o.overwrite);
                                break;
                            case "xml":
                                this.xml(o.key, o.url, o.overwrite);
                                break;
                            case "script":
                                this.script(o.key, o.url, o.callback, t.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(o.key, o.url, o.callback, t.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(o.key, o.url, o.frameWidth, o.frameHeight, o.frameMax, o.margin, o.spacing);
                                break;
                            case "video":
                                this.video(o.key, o.urls);
                                break;
                            case "audio":
                                this.audio(o.key, o.urls, o.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(o.key, o.urls, o.jsonURL, o.jsonData, o.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(o.key, o.url, o.data, U.Tilemap[o.format]);
                                break;
                            case "physics":
                                this.physics(o.key, o.url, o.data, U.Loader[o.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(o.key, o.textureURL, o.atlasURL, o.atlasData, o.xSpacing, o.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(o.key, o.textureURL, o.atlasURL, o.atlasData);
                                break;
                            case "atlas":
                                this.atlas(o.key, o.textureURL, o.atlasURL, o.atlasData, U.Loader[o.format]);
                                break;
                            case "shader":
                                this.shader(o.key, o.url, o.overwrite)
                        }
                    }
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(t) {
                switch (t.type) {
                    case "packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(t);
                        break;
                    case "audio":
                        t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        t.format === U.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === U.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadVideoTag: function(t) {
                var e = this;
                t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                var i = function() {
                    t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !0, U.GAMES[e.game.id].load.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                }, t.data.addEventListener(t.loadEvent, i, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else {
                    t.data = new Audio, t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                }
            },
            xhrLoad: function(e, t, i, o, s) {
                if (this.useXDomainRequest && window.XDomainRequest) this.xhrLoadWithXDR(e, t, i, o, s);
                else {
                    var n = new XMLHttpRequest;
                    n.open("GET", t, !0), n.responseType = i, !1 !== this.headers.requestedWith && n.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[e.type] && n.setRequestHeader("Accept", this.headers[e.type]), s = s || this.fileError;
                    var r = this;
                    n.onload = function() {
                        try {
                            return 4 === n.readyState && 400 <= n.status && n.status <= 599 ? s.call(r, e, n) : o.call(r, e, n)
                        } catch (t) {
                            r.hasLoaded ? window.console : r.asyncComplete(e, t.message || "Exception")
                        }
                    }, n.onerror = function() {
                        try {
                            return s.call(r, e, n)
                        } catch (t) {
                            r.hasLoaded ? window.console : r.asyncComplete(e, t.message || "Exception")
                        }
                    }, e.requestObject = n, e.requestUrl = t, n.send()
                }
            },
            xhrLoadWithXDR: function(e, t, i, o, s) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(10 <= this.game.device.ieVersion) || (this._warnedAboutXDomainRequest = !0);
                var n = new window.XDomainRequest;
                n.open("GET", t, !0), n.responseType = i, n.timeout = 3e3, s = s || this.fileError;
                var r = this;
                n.onerror = function() {
                    try {
                        return s.call(r, e, n)
                    } catch (t) {
                        r.asyncComplete(e, t.message || "Exception")
                    }
                }, n.ontimeout = function() {
                    try {
                        return s.call(r, e, n)
                    } catch (t) {
                        r.asyncComplete(e, t.message || "Exception")
                    }
                }, n.onprogress = function() {}, n.onload = function() {
                    try {
                        return 4 === n.readyState && 400 <= n.status && n.status <= 599 ? s.call(r, e, n) : o.call(r, e, n)
                    } catch (t) {
                        r.asyncComplete(e, t.message || "Exception")
                    }
                }, e.requestObject = n, e.requestUrl = t, setTimeout(function() {
                    n.send()
                }, 0)
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, o = t[e];
                    if (o.uri) {
                        if (i = o.type, o = o.uri, this.game.device.canPlayVideo(i)) return o
                    } else {
                        if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o;
                        if (0 <= o.indexOf("?") && (o = o.substr(0, o.indexOf("?"))), i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio) return null;
                for (var e = 0; e < t.length; e++) {
                    var i, o = t[e];
                    if (o.uri) {
                        if (i = o.type, o = o.uri, this.game.device.canPlayAudio(i)) return o
                    } else {
                        if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o;
                        if (0 <= o.indexOf("?") && (o = o.substr(0, o.indexOf("?"))), i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var o = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status), i && (o = o + " (" + i + ")"), this.asyncComplete(t, o)
            },
            fileComplete: function(e, t) {
                var i = !0;
                switch (e.type) {
                    case "packfile":
                        var o = JSON.parse(t.responseText);
                        e.data = o || {};
                        break;
                    case "image":
                        this.cache.addImage(e.key, e.url, e.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                        break;
                    case "textureatlas":
                        if (null == e.atlasURL) this.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format);
                        else if (i = !1, e.format === U.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format === U.Loader.TEXTURE_ATLAS_JSON_HASH || e.format === U.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.jsonLoadComplete);
                        else {
                            if (e.format !== U.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                            this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        e.atlasURL ? (i = !1, this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", function(t, e) {
                            var i;
                            try {
                                i = JSON.parse(e.responseText)
                            } catch (t) {}
                            i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                        })) : this.cache.addBitmapFont(e.key, e.url, e.data, e.atlasData, e.atlasType, e.xSpacing, e.ySpacing);
                        break;
                    case "video":
                        if (e.asBlob) try {
                            e.data = t.response
                        } catch (t) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + e.key)
                        }
                        this.cache.addVideo(e.key, e.url, e.data, e.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (e.data = t.response, this.cache.addSound(e.key, e.url, e.data, !0, !1), e.autoDecode && this.game.sound.decode(e.key)) : this.cache.addSound(e.key, e.url, e.data, !1, !0);
                        break;
                    case "text":
                        e.data = t.responseText, this.cache.addText(e.key, e.url, e.data);
                        break;
                    case "shader":
                        e.data = t.responseText, this.cache.addShader(e.key, e.url, e.data);
                        break;
                    case "physics":
                        o = JSON.parse(t.responseText);
                        this.cache.addPhysicsData(e.key, e.url, o, e.format);
                        break;
                    case "script":
                        e.data = document.createElement("script"), e.data.language = "javascript", e.data.type = "text/javascript", e.data.defer = !1, e.data.text = t.responseText, document.head.appendChild(e.data), e.callback && (e.data = e.callback.call(e.callbackContext, e.key, t.responseText));
                        break;
                    case "binary":
                        e.callback ? e.data = e.callback.call(e.callbackContext, e.key, t.response) : e.data = t.response, this.cache.addBinary(e.key, e.data)
                }
                i && this.asyncComplete(e)
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText,
                    o = this.parseXml(i);
                if (o) "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, o, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, o, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, o), this.asyncComplete(t);
                else {
                    e.responseType || e.contentType;
                    this.asyncComplete(t, "invalid XML")
                }
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml");
                    else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(U.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return U.Math.clamp(t || 0, 0, 100)
            }
        }), Object.defineProperty(U.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), U.Loader.prototype.constructor = U.Loader, U.LoaderParser = {
            bitmapFont: function(t, e, i, o) {
                return this.xmlBitmapFont(t, e, i, o)
            },
            xmlBitmapFont: function(t, e, i, o) {
                var s = {},
                    n = t.getElementsByTagName("info")[0],
                    r = t.getElementsByTagName("common")[0];
                s.font = n.getAttribute("face"), s.size = parseInt(n.getAttribute("size"), 10), s.lineHeight = parseInt(r.getAttribute("lineHeight"), 10) + o, s.chars = {};
                for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                    var l = parseInt(a[h].getAttribute("id"), 10);
                    s.chars[l] = {
                        x: parseInt(a[h].getAttribute("x"), 10),
                        y: parseInt(a[h].getAttribute("y"), 10),
                        width: parseInt(a[h].getAttribute("width"), 10),
                        height: parseInt(a[h].getAttribute("height"), 10),
                        xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i,
                        kerning: {}
                    }
                }
                var d = t.getElementsByTagName("kerning");
                for (h = 0; h < d.length; h++) {
                    var c = parseInt(d[h].getAttribute("first"), 10),
                        u = parseInt(d[h].getAttribute("second"), 10),
                        p = parseInt(d[h].getAttribute("amount"), 10);
                    s.chars[u].kerning[c] = p
                }
                return this.finalizeBitmapFont(e, s)
            },
            jsonBitmapFont: function(t, e, i, o) {
                var s = {
                    font: t.font.info._face,
                    size: parseInt(t.font.info._size, 10),
                    lineHeight: parseInt(t.font.common._lineHeight, 10) + o,
                    chars: {}
                };
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10);
                    s.chars[e] = {
                        x: parseInt(t._x, 10),
                        y: parseInt(t._y, 10),
                        width: parseInt(t._width, 10),
                        height: parseInt(t._height, 10),
                        xOffset: parseInt(t._xoffset, 10),
                        yOffset: parseInt(t._yoffset, 10),
                        xAdvance: parseInt(t._xadvance, 10) + i,
                        kerning: {}
                    }
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    s.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                }), this.finalizeBitmapFont(e, s)
            },
            finalizeBitmapFont: function(i, o) {
                return Object.keys(o.chars).forEach(function(t) {
                    var e = o.chars[t];
                    e.texture = new PIXI.Texture(i, new U.Rectangle(e.x, e.y, e.width, e.height))
                }), o
            }
        }, U.AudioSprite = function(t, e) {
            for (var i in this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}, this.config.spritemap) {
                var o = this.config.spritemap[i],
                    s = this.game.add.sound(this.key);
                s.addMarker(i, o.start, o.end - o.start, null, o.loop), this.sounds[i] = s
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, U.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        }, U.AudioSprite.prototype.constructor = U.AudioSprite, U.Sound = function(t, e, i, o, s) {
            void 0 === i && (i = 1), void 0 === o && (o = !1), void 0 === s && (s = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = o, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = i * this.game.sound.volume, s && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new U.Signal, this.onPlay = new U.Signal, this.onPause = new U.Signal, this.onResume = new U.Signal, this.onLoop = new U.Signal, this.onStop = new U.Signal, this.onMute = new U.Signal, this.onMarkerComplete = new U.Signal, this.onFadeComplete = new U.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, U.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, o, s) {
                null == i && (i = 1), null == o && (o = 1), void 0 === s && (s = !1), this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: o,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: s
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
            },
            update: function() {
                this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, o, s) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === s && (s = !0), this.isPlaying && !this.allowMultiple && !s && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || s)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                var n = Object.keys(this.markers);
                if ("" === t && 1 === n.length && (t = n[0]), "" === t && 0 < n.length) return this;
                if ("" !== t) {
                    if (!this.markers[t]) return this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== o && (this.loop = o), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else e = e || 0, void 0 === i && (i = this._volume), void 0 === o && (o = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = o, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = o;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.wechatMinigame || this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this.loop && (this._sound.loop = !0), !this.loop && "" === t && this.game.device.wechatMinigame && this._sound.addEventListener("ended", this.onEndedHandler.bind(this)), this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
            },
            restart: function(t, e, i, o) {
                t = t || "", e = e || 0, i = i || 1, void 0 === o && (o = !1), this.play(t, e, i, o, !0)
            },
            pause: function() {
                this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var e = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                    } else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(t, e) {
                this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e && (this.fadeTween = this.game.add.tween(this).to({
                    volume: e
                }, t, U.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)))
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            }
        }, U.Sound.prototype.constructor = U.Sound, Object.defineProperty(U.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(U.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(U.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.game.device.wechatMinigame ? this._sound.pause() : this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.game.device.wechatMinigame && this.isPlaying ? this._sound.play() : this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(U.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t))
            }
        }), U.SoundManager = function(t) {
            this.game = t, this.onSoundDecode = new U.Signal, this.onVolumeChange = new U.Signal, this.onMute = new U.Signal, this.onUnMute = new U.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new U.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
        }, U.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                    if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try {
                    this.context = new window.AudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                } else if (window.webkitAudioContext) try {
                    this.context = new window.webkitAudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || !this.game.device.cocoonJS && (this.game.device.chrome || this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (8 < this.game.device.iOSVersion || 55 <= this.game.device.chromeVersion ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), "suspended" === this._unlockSource.context.state && this._unlockSource.context.resume()
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(e, i) {
                i = i || null;
                var t = this.game.cache.getSoundData(e);
                if (t && !1 === this.game.cache.isSoundDecoded(e)) {
                    this.game.cache.updateSound(e, "isDecoding", !0);
                    var o = this;
                    try {
                        this.context.decodeAudioData(t, function(t) {
                            t && (o.game.cache.decodedSound(e, t), o.onSoundDecode.dispatch(e, i))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(t, e, i) {
                "string" == typeof t && (t = [t]), this._watchList.reset();
                for (var o = 0; o < t.length; o++) t[o] instanceof U.Sound ? this.game.cache.isSoundDecoded(t[o].key) || this._watchList.add(t[o].key) : this.game.cache.isSoundDecoded(t[o]) || this._watchList.add(t[o]);
                0 === this._watchList.total ? (this._watching = !1, e.call(i)) : (this._watching = !0, this._watchCallback = e, this._watchContext = i)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(t, e, i, o) {
                void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === o && (o = this.connectToMaster);
                var s = new U.Sound(this.game, t, e, i, o);
                return this._sounds.push(s), s
            },
            addSprite: function(t) {
                return new U.AudioSprite(this.game, t)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                return !1
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var o = this.add(t, e, i);
                    return o.play(), o
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        }, U.SoundManager.prototype.constructor = U.SoundManager, Object.defineProperty(U.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(U.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : 1 < t && (t = 1), this._volume !== t) {
                    if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }), U.ScaleManager = function(t, e, i) {
            this.game = t, this.dom = U.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new U.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new U.Signal, this.enterIncorrectOrientation = new U.Signal, this.leaveIncorrectOrientation = new U.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new U.Signal, this.onFullScreenChange = new U.Signal, this.onFullScreenError = new U.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new U.Point(1, 1), this.scaleFactorInversed = new U.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new U.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = U.ScaleManager.NO_SCALE, this._fullScreenScaleMode = U.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new U.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new U.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new U.Rectangle, this._userScaleFactor = new U.Point(1, 1), this._userScaleTrim = new U.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new U.Rectangle, this._tempBounds = new U.Rectangle, this._lastReportedCanvasSize = new U.Rectangle, this._lastReportedGameSize = new U.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, i)
        }, U.ScaleManager.EXACT_FIT = 0, U.ScaleManager.NO_SCALE = 1, U.ScaleManager.SHOW_ALL = 2, U.ScaleManager.RESIZE = 3, U.ScaleManager.USER_SCALE = 4, U.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new U.Point(0, 1) : t.scrollTo = new U.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                var e = this;
                this._orientationChange = function(t) {
                    return e.orientationChange(t)
                }, this._windowResize = function(t) {
                    return e.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return e.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return e.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), U.FlexGrid && (this.grid = new U.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
            },
            setupScale: function(t, e) {
                var i, o = new U.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? i = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (i = this.game.parent)), i ? (this.parentNode = i, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), o.width = this._parentBounds.width, o.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, o.width = this.dom.visualBounds.width, o.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var s = 0,
                    n = 0;
                s = "number" == typeof t ? t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, o.width * this.parentScaleFactor.x), n = "number" == typeof e ? e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o.height * this.parentScaleFactor.y), s = Math.floor(s), n = Math.floor(n), this._gameSize.setTo(0, 0, s, n), this.updateDimensions(s, n, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(t, e) {
                this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== U.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, o) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | o), this.queueUpdate(!0)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!U.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !U.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width,
                        e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === U.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                }
            },
            setMinMax: function(t, e, i, o) {
                this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== o && (this.maxHeight = o)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = 400 <= t ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var e = this._parentBounds.width,
                        i = this._parentBounds.height,
                        o = this.getParentBounds(this._parentBounds),
                        s = o.width !== e || o.height !== i,
                        n = this.updateOrientationState();
                    (s || n) && (this.onResize && this.onResize.call(this.onResizeContext, this, o), this.updateLayout(), this.signalSizeChange());
                    var r = 2 * this._updateThrottle;
                    this._updateThrottle < t && (r = Math.min(t, this._updateThrottleReset)), this._updateThrottle = U.Math.clamp(r, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation,
                    o = e !== this.incorrectOrientation;
                return o && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || o) && this.onOrientationChange.dispatch(this, t, e), i || o
            },
            orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var t = this.currentScaleMode;
                if (t !== U.ScaleManager.RESIZE) {
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === U.ScaleManager.EXACT_FIT ? this.setExactFit() : t === U.ScaleManager.SHOW_ALL ? (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent && (this.setShowAll(!0), this.resetCanvas()), this.setShowAll()) : t === U.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === U.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === U.ScaleManager.SHOW_ALL || t === U.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                } else this.reflowGame()
            },
            getParentBounds: function(t) {
                var e = t || new U.Rectangle,
                    i = this.boundingParent,
                    o = this.dom.visualBounds,
                    s = this.dom.layoutBounds;
                if (i) {
                    var n = i.getBoundingClientRect(),
                        r = i.offsetParent ? i.offsetParent.getBoundingClientRect() : i.getBoundingClientRect();
                    e.setTo(n.left - r.left, n.top - r.top, n.width, n.height);
                    var a = this.windowConstraints;
                    if (a.right) {
                        var h = "layout" === a.right ? s : o;
                        e.right = Math.min(e.right, h.width)
                    }
                    if (a.bottom) {
                        h = "layout" === a.bottom ? s : o;
                        e.bottom = Math.min(e.bottom, h.height)
                    }
                } else e.setTo(0, 0, o.width, o.height);
                return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds),
                    o = this.game.canvas,
                    s = this.margin;
                if (t) {
                    s.left = s.right = 0;
                    var n = o.getBoundingClientRect();
                    if (this.width < i.width && !this.incorrectOrientation) {
                        var r = n.left - i.x,
                            a = i.width / 2 - this.width / 2,
                            h = (a = Math.max(a, 0)) - r;
                        s.left = Math.round(h)
                    }
                    o.style.marginLeft = s.left + "px", 0 !== s.left && (s.right = -(i.width - n.width - s.left), o.style.marginRight = s.right + "px")
                }
                if (e) {
                    s.top = s.bottom = 0;
                    n = o.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        r = n.top - i.y, a = i.height / 2 - this.height / 2, h = (a = Math.max(a, 0)) - r;
                        s.top = Math.round(h)
                    }
                    o.style.marginTop = s.top + "px", 0 !== s.top && (s.bottom = -(i.height - n.height - s.top), o.style.marginBottom = s.bottom + "px")
                }
                s.x = s.left, s.y = s.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = U.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = U.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds),
                    o = i.width,
                    s = i.height;
                e = t ? Math.max(s / this.game.height, o / this.game.width) : Math.min(s / this.game.height, o / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            },
            startFullScreen: function(t, e) {
                if (this.isFullScreen) return !1;
                if (this.compatibility.supportsFullScreen) {
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var i = this.game.input;
                        if (i.activePointer && i.activePointer !== i.mousePointer && (e || !1 !== e)) return void i.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                    }
                    void 0 !== t && this.game.renderType === U.CANVAS && (this.game.stage.smoothed = t);
                    var o = this.fullScreenTarget;
                    o || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), o = this._createdFullScreenTarget);
                    var s = {
                        targetElement: o
                    };
                    if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, s), this._createdFullScreenTarget) {
                        var n = this.game.canvas;
                        n.parentNode.insertBefore(o, n), o.appendChild(n)
                    }
                    return this.game.device.fullscreenKeyboard ? o[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : o[this.game.device.requestFullscreen](), !0
                }
                var r = this;
                setTimeout(function() {
                    r.fullScreenError()
                }, 10)
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(t) {
                var e = !!this._createdFullScreenTarget,
                    i = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (e || this.fullScreenScaleMode === U.ScaleManager.EXACT_FIT) && i !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: i.style.width,
                    targetHeight: i.style.height
                }, i.style.width = "100%", i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth, i.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? this.prepScreenMode(!0) : (this.prepScreenMode(!1), this.cleanupCreatedTarget()), this.updateLayout(), this.queueUpdate(!0), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, o) {
                if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === o && (o = !1), !t || !t.scale) return t;
                if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                var s = e,
                    n = t.height * e / t.width,
                    r = t.width * i / t.height,
                    a = i,
                    h = e < r;
                return h = h ? o : !o, t.height = h ? (t.width = Math.floor(s), Math.floor(n)) : (t.width = Math.floor(r), Math.floor(a)), t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, U.ScaleManager.prototype.constructor = U.ScaleManager, Object.defineProperty(U.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(U.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), U.Utils.Debug = function(t) {
            this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
        }, U.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === U.CANVAS ? this.context = this.game.context : (this.bmd = new U.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
            },
            resize: function(t, e, i) {
                this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, o) {
                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === o && (o = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = o, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(t, e, i, o) {
                this.start(e, i, o), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
            },
            cameraInfo: function(t, e, i, o) {
                this.start(e, i, o), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
            },
            timer: function(t, e, i, o) {
                this.start(e, i, o), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
            },
            pointer: function(t, e, i, o, s) {
                null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", o = o || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, s), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = o, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
            },
            spriteInputInfo: function(t, e, i, o) {
                this.start(e, i, o), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
            },
            key: function(t, e, i, o) {
                this.start(e, i, o, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(t, e, i) {
                this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
            },
            spriteBounds: function(t, e, i) {
                var o = t.getBounds();
                o.x += this.game.camera.x, o.y += this.game.camera.y, this.rectangle(o, e, i)
            },
            ropeSegments: function(t, e, i) {
                var o = t.segments,
                    s = this;
                o.forEach(function(t) {
                    s.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, o) {
                this.start(e, i, o), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
            },
            spriteCoords: function(t, e, i, o) {
                this.start(e, i, o, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(t, e, i, o) {
                this.start(e, i, o, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
            },
            pixel: function(t, e, i, o) {
                o = o || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, o, o), this.stop()
            },
            geom: function(t, e, i, o) {
                void 0 === i && (i = !0), void 0 === o && (o = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof U.Rectangle || 1 === o ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof U.Circle || 2 === o ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : t instanceof U.Point || 3 === o ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof U.Line || 4 === o) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
            },
            text: function(t, e, i, o, s) {
                o = o || "rgb(255,255,255)", s = s || "16px Courier", this.start(), this.context.font = s, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = o, this.context.fillText(t, e, i), this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)", this.start();
                var i = t.bounds;
                if (0 === t.nodes.length) {
                    this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                    for (var o = 0; o < t.objects.length; o++) this.context.strokeRect(t.objects[o].x, t.objects[o].y, t.objects[o].width, t.objects[o].height)
                } else
                    for (o = 0; o < t.nodes.length; o++) this.quadTree(t.nodes[o]);
                this.stop()
            },
            body: function(t, e, i) {
                t.body && (this.start(), t.body.type === U.Physics.ARCADE ? U.Physics.Arcade.Body.render(this.context, t.body, e, i) : t.body.type === U.Physics.NINJA ? U.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === U.Physics.BOX2D && U.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
            },
            bodyInfo: function(t, e, i, o) {
                t.body && (this.start(e, i, o, 210), t.body.type === U.Physics.ARCADE ? U.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === U.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(t, e) {
                this.start(), U.Physics.Box2D.renderBody(this.context, t, e), this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID"), t.children && 0 < t.children.length)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
            },
            destroy: function() {
                PIXI.CanvasPool.remove(this)
            }
        }, U.Utils.Debug.prototype.constructor = U.Utils.Debug, U.DOM = {
            getOffset: function(t, e) {
                e = e || new U.Point;
                var i = t.getBoundingClientRect(),
                    o = U.DOM.scrollY,
                    s = U.DOM.scrollX,
                    n = document.documentElement.clientTop,
                    r = document.documentElement.clientLeft;
                return e.x = i.left + s - r, e.y = i.top + o - n, e
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && 0 <= i.bottom && 0 <= i.right && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type) return i.type;
                if ("string" == typeof i) return i;
                var o = "portrait-primary",
                    s = "landscape-primary";
                if ("screen" === t) return e.height > e.width ? o : s;
                if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? o : s;
                if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? o : s;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return o;
                    if (window.matchMedia("(orientation: landscape)").matches) return s
                }
                return this.visualBounds.height > this.visualBounds.width ? o : s
            },
            visualBounds: new U.Rectangle,
            layoutBounds: new U.Rectangle,
            documentBounds: new U.Rectangle
        }, U.Device.whenReady(function(t) {
            var e = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                i = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            if (Object.defineProperty(U.DOM, "scrollX", {
                    get: e
                }), Object.defineProperty(U.DOM, "scrollY", {
                    get: i
                }), Object.defineProperty(U.DOM.visualBounds, "x", {
                    get: e
                }), Object.defineProperty(U.DOM.visualBounds, "y", {
                    get: i
                }), Object.defineProperty(U.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(U.DOM.layoutBounds, "y", {
                    value: 0
                }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                var o = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    s = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(U.DOM.visualBounds, "width", {
                    get: o
                }), Object.defineProperty(U.DOM.visualBounds, "height", {
                    get: s
                }), Object.defineProperty(U.DOM.layoutBounds, "width", {
                    get: o
                }), Object.defineProperty(U.DOM.layoutBounds, "height", {
                    get: s
                })
            } else Object.defineProperty(U.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(U.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(U.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth,
                        e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(U.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight,
                        e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(U.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(U.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(U.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(U.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), U.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, U.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i];
                return null
            },
            exists: function(t) {
                return -1 < this.list.indexOf(t)
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (-1 < e) return this.list.splice(e, 1), t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--;)
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(U.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(U.ArraySet.prototype, "first", {
            get: function() {
                return (this.position = 0) < this.list.length ? this.list[0] : null
            }
        }), Object.defineProperty(U.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), U.ArraySet.prototype.constructor = U.ArraySet, U.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var o = e + Math.floor(Math.random() * i);
                return void 0 === t[o] ? null : t[o]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var o = e + Math.floor(Math.random() * i);
                if (o < t.length) {
                    var s = t.splice(o, 1);
                    return void 0 === s[0] ? null : s[0]
                }
                return null
            },
            shuffle: function(t) {
                for (var e = t.length - 1; 0 < e; e--) {
                    var i = Math.floor(Math.random() * (e + 1)),
                        o = t[e];
                    t[e] = t[i], t[i] = o
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, o = new Array(i), s = 0; s < i; s++) {
                    o[s] = new Array(e);
                    for (var n = e - 1; - 1 < n; n--) o[s][n] = t[n][s]
                }
                return o
            },
            rotateMatrix: function(t, e) {
                if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = U.ArrayUtils.transposeMatrix(t)).reverse();
                else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = U.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(e) || "rotate180" === e) {
                    for (var i = 0; i < t.length; i++) t[i].reverse();
                    t = t.reverse()
                }
                return t
            },
            findClosest: function(t, e) {
                if (!e.length) return NaN;
                if (1 === e.length || t < e[0]) return e[0];
                for (var i = 1; e[i] < t;) i++;
                var o = e[i - 1],
                    s = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return s - t <= t - o ? s : o
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            rotate: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            numberArray: function(t, e) {
                for (var i = [], o = t; o <= e; o++) i.push(o);
                return i
            },
            numberArrayStep: function(t, e, i) {
                null == t && (t = 0), null == e && (e = t, t = 0), void 0 === i && (i = 1);
                for (var o = [], s = Math.max(U.Math.roundAwayFromZero((e - t) / (i || 1)), 0), n = 0; n < s; n++) o.push(t), t += i;
                return o
            }
        }, U.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, U.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, ((this.next = t).prev = this).total++) : ((this.last.next = t).prev = this.last, this.last = t, this.total++), t
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(t) {
                if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
            },
            callAll: function(t) {
                if (this.first && this.last)
                    for (var e = this.first; e && e[t] && e[t].call(e), (e = e.next) !== this.last.next;);
            }
        }, U.LinkedList.prototype.constructor = U.LinkedList, U.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, U.Create.PALETTE_ARNE = 0, U.Create.PALETTE_JMP = 1, U.Create.PALETTE_CGA = 2, U.Create.PALETTE_C64 = 3, U.Create.PALETTE_JAPANESE_MACHINE = 4, U.Create.prototype = {
            texture: function(t, e, i, o, s) {
                void 0 === i && (i = 8), void 0 === o && (o = i), void 0 === s && (s = 0);
                var n = e[0].length * i,
                    r = e.length * o;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(n, r), this.bmd.clear();
                for (var a = 0; a < e.length; a++)
                    for (var h = e[a], l = 0; l < h.length; l++) {
                        var d = h[l];
                        "." !== d && " " !== d && (this.ctx.fillStyle = this.palettes[s][d], this.ctx.fillRect(l * i, a * o, i, o))
                    }
                return this.bmd.generateTexture(t)
            },
            grid: function(t, e, i, o, s, n) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = n;
                for (var r = 0; r < i; r += s) this.ctx.fillRect(0, r, e, 1);
                for (var a = 0; a < e; a += o) this.ctx.fillRect(a, 0, 1, i);
                return this.bmd.generateTexture(t)
            }
        }, U.Create.prototype.constructor = U.Create, U.FlexGrid = function(t, e, i) {
            this.game = t.game, this.manager = t, this.width = e, this.height = i, this.boundsCustom = new U.Rectangle(0, 0, e, i), this.boundsFluid = new U.Rectangle(0, 0, e, i), this.boundsFull = new U.Rectangle(0, 0, e, i), this.boundsNone = new U.Rectangle(0, 0, e, i), this.positionCustom = new U.Point(0, 0), this.positionFluid = new U.Point(0, 0), this.positionFull = new U.Point(0, 0), this.positionNone = new U.Point(0, 0), this.scaleCustom = new U.Point(1, 1), this.scaleFluid = new U.Point(1, 1), this.scaleFluidInversed = new U.Point(1, 1), this.scaleFull = new U.Point(1, 1), this.scaleNone = new U.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / i, this.ratioV = i / e, this.multiplier = 0, this.layers = []
        }, U.FlexGrid.prototype = {
            setSize: function(t, e) {
                this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new U.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
            },
            createCustomLayer: function(t, e, i, o) {
                void 0 === o && (o = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                var s = new U.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                return o && this.game.world.add(s), this.layers.push(s), void 0 !== i && null !== typeof i && s.addMultiple(i), s
            },
            createFluidLayer: function(t, e) {
                void 0 === e && (e = !0);
                var i = new U.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                return e && this.game.world.add(i), this.layers.push(i), void 0 !== t && null !== typeof t && i.addMultiple(t), i
            },
            createFullLayer: function(t) {
                var e = new U.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            createFixedLayer: function(t) {
                var e = new U.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            reset: function() {
                for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
            },
            onResize: function(t, e) {
                this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(t) {
                this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        }, U.FlexGrid.prototype.constructor = U.FlexGrid, U.FlexLayer = function(t, e, i, o) {
            U.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = i, this.scale = o, this.topLeft = i.topLeft, this.topMiddle = new U.Point(i.halfWidth, 0), this.topRight = i.topRight, this.bottomLeft = i.bottomLeft, this.bottomMiddle = new U.Point(i.halfWidth, i.bottom), this.bottomRight = i.bottomRight
        }, U.FlexLayer.prototype = Object.create(U.Group.prototype), U.FlexLayer.prototype.constructor = U.FlexLayer, U.FlexLayer.prototype.resize = function() {}, U.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }, U.Color = {
            packPixel: function(t, e, i, o) {
                return U.Device.LITTLE_ENDIAN ? (o << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | o) >>> 0
            },
            unpackPixel: function(t, e, i, o) {
                return null == e && (e = U.Color.createColor()), null == i && (i = !1), null == o && (o = !1), U.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", i && U.Color.RGBtoHSL(e.r, e.g, e.b, e), o && U.Color.RGBtoHSV(e.r, e.g, e.b, e), e
            },
            fromRGBA: function(t, e) {
                return e || (e = U.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
            },
            toRGBA: function(t, e, i, o) {
                return t << 24 | e << 16 | i << 8 | o
            },
            toABGR: function(t, e, i, o) {
                return (o << 24 | i << 16 | e << 8 | t) >>> 0
            },
            RGBtoHSL: function(t, e, i, o) {
                o || (o = U.Color.createColor(t, e, i, 1)), t /= 255, e /= 255, i /= 255;
                var s = Math.min(t, e, i),
                    n = Math.max(t, e, i);
                if (o.h = 0, o.s = 0, o.l = (n + s) / 2, n !== s) {
                    var r = n - s;
                    o.s = .5 < o.l ? r / (2 - n - s) : r / (n + s), n === t ? o.h = (e - i) / r + (e < i ? 6 : 0) : n === e ? o.h = (i - t) / r + 2 : n === i && (o.h = (t - e) / r + 4), o.h /= 6
                }
                return o
            },
            HSLtoRGB: function(t, e, i, o) {
                if (o ? (o.r = i, o.g = i, o.b = i) : o = U.Color.createColor(i, i, i), 0 !== e) {
                    var s = i < .5 ? i * (1 + e) : i + e - i * e,
                        n = 2 * i - s;
                    o.r = U.Color.hueToColor(n, s, t + 1 / 3), o.g = U.Color.hueToColor(n, s, t), o.b = U.Color.hueToColor(n, s, t - 1 / 3)
                }
                return o.r = Math.floor(255 * o.r | 0), o.g = Math.floor(255 * o.g | 0), o.b = Math.floor(255 * o.b | 0), U.Color.updateColor(o), o
            },
            RGBtoHSV: function(t, e, i, o) {
                o || (o = U.Color.createColor(t, e, i, 255)), t /= 255, e /= 255, i /= 255;
                var s = Math.min(t, e, i),
                    n = Math.max(t, e, i),
                    r = n - s;
                return o.h = 0, o.s = 0 === n ? 0 : r / n, (o.v = n) !== s && (n === t ? o.h = (e - i) / r + (e < i ? 6 : 0) : n === e ? o.h = (i - t) / r + 2 : n === i && (o.h = (t - e) / r + 4), o.h /= 6), o
            },
            HSVtoRGB: function(t, e, i, o) {
                var s, n, r;
                void 0 === o && (o = U.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                var a = Math.floor(6 * t),
                    h = 6 * t - a,
                    l = i * (1 - e),
                    d = i * (1 - h * e),
                    c = i * (1 - (1 - h) * e);
                switch (a % 6) {
                    case 0:
                        s = i, n = c, r = l;
                        break;
                    case 1:
                        s = d, n = i, r = l;
                        break;
                    case 2:
                        s = l, n = i, r = c;
                        break;
                    case 3:
                        s = l, n = d, r = i;
                        break;
                    case 4:
                        s = c, n = l, r = i;
                        break;
                    case 5:
                        s = i, n = l, r = d
                }
                return o.r = Math.floor(255 * s), o.g = Math.floor(255 * n), o.b = Math.floor(255 * r), U.Color.updateColor(o), o
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(t, e, i, o, s, n, r, a) {
                var h = {
                    r: t || 0,
                    g: e || 0,
                    b: i || 0,
                    a: o || 1,
                    h: s || 0,
                    s: n || 0,
                    l: r || 0,
                    v: a || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return U.Color.updateColor(h)
            },
            updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = U.Color.getColor(t.r, t.g, t.b), t.color32 = U.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
            },
            getColor32: function(t, e, i, o) {
                return t << 24 | e << 16 | i << 8 | o
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(t, e, i, o, s) {
                return void 0 === o && (o = 255), void 0 === s && (s = "#"), "#" === s ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + U.Color.componentToHex(o) + U.Color.componentToHex(t) + U.Color.componentToHex(e) + U.Color.componentToHex(i)
            },
            hexToRGB: function(t) {
                var e = U.Color.hexToColor(t);
                if (e) return U.Color.getColor32(e.a, e.r, e.g, e.b)
            },
            hexToColor: function(t, e) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, o) {
                    return e + e + i + i + o + o
                });
                var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if (i) {
                    var o = parseInt(i[1], 16),
                        s = parseInt(i[2], 16),
                        n = parseInt(i[3], 16);
                    e ? (e.r = o, e.g = s, e.b = n) : e = U.Color.createColor(o, s, n)
                }
                return e
            },
            webToColor: function(t, e) {
                e || (e = U.Color.createColor());
                var i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return i && (e.r = parseInt(i[1], 10), e.g = parseInt(i[2], 10), e.b = parseInt(i[3], 10), e.a = void 0 !== i[4] ? parseFloat(i[4]) : 1, U.Color.updateColor(e)), e
            },
            valueToColor: function(t, e) {
                if (e || (e = U.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? U.Color.webToColor(t, e) : (e.a = 1, U.Color.hexToColor(t, e));
                if ("number" != typeof t) return e;
                var i = U.Color.getRGB(t);
                return e.r = i.r, e.g = i.g, e.b = i.b, e.a = i.a / 255, e
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 1);
                for (var i = [], o = 0; o <= 359; o++) i.push(U.Color.HSVtoRGB(o / 359, t, e));
                return i
            },
            HSLColorWheel: function(t, e) {
                void 0 === t && (t = .5), void 0 === e && (e = .5);
                for (var i = [], o = 0; o <= 359; o++) i.push(U.Color.HSLtoRGB(o / 359, t, e));
                return i
            },
            interpolateColor: function(t, e, i, o, s) {
                void 0 === s && (s = 255);
                var n = U.Color.getRGB(t),
                    r = U.Color.getRGB(e),
                    a = (r.red - n.red) * o / i + n.red,
                    h = (r.green - n.green) * o / i + n.green,
                    l = (r.blue - n.blue) * o / i + n.blue;
                return U.Color.getColor32(s, a, h, l)
            },
            interpolateColorWithRGB: function(t, e, i, o, s, n) {
                var r = U.Color.getRGB(t),
                    a = (e - r.red) * n / s + r.red,
                    h = (i - r.green) * n / s + r.green,
                    l = (o - r.blue) * n / s + r.blue;
                return U.Color.getColor(a, h, l)
            },
            interpolateRGB: function(t, e, i, o, s, n, r, a) {
                var h = (o - t) * a / r + t,
                    l = (s - e) * a / r + e,
                    d = (n - i) * a / r + i;
                return U.Color.getColor(h, l, d)
            },
            getRandomColor: function(t, e, i) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === i && (i = 255), 255 < e || e < t) return U.Color.getColor(255, 255, 255);
                var o = t + Math.round(Math.random() * (e - t)),
                    s = t + Math.round(Math.random() * (e - t)),
                    n = t + Math.round(Math.random() * (e - t));
                return U.Color.getColor32(i, o, s, n)
            },
            getRGB: function(t) {
                return 16777215 < t ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(t) {
                if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var e = U.Color.getRGB(t);
                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return t < e ? e : t
            },
            blendDarken: function(t, e) {
                return t < e ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(t, e) {
                return U.Color.blendOverlay(e, t)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(t, e) {
                return U.Color.blendAdd(t, e)
            },
            blendLinearBurn: function(t, e) {
                return U.Color.blendSubtract(t, e)
            },
            blendLinearLight: function(t, e) {
                return e < 128 ? U.Color.blendLinearBurn(t, 2 * e) : U.Color.blendLinearDodge(t, 2 * (e - 128))
            },
            blendVividLight: function(t, e) {
                return e < 128 ? U.Color.blendColorBurn(t, 2 * e) : U.Color.blendColorDodge(t, 2 * (e - 128))
            },
            blendPinLight: function(t, e) {
                return e < 128 ? U.Color.blendDarken(t, 2 * e) : U.Color.blendLighten(t, 2 * (e - 128))
            },
            blendHardMix: function(t, e) {
                return U.Color.blendVividLight(t, e) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(t, e) {
                return U.Color.blendReflect(e, t)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, U.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, U.Physics.ARCADE = 0, U.Physics.P2JS = 1, U.Physics.NINJA = 2, U.Physics.BOX2D = 3, U.Physics.CHIPMUNK = 4, U.Physics.MATTERJS = 5, U.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !U.Physics.hasOwnProperty("Arcade") || (this.arcade = new U.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && U.Physics.hasOwnProperty("Ninja") && (this.ninja = new U.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && U.Physics.hasOwnProperty("P2") && (this.p2 = new U.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && U.Physics.hasOwnProperty("BOX2D") && (this.box2d = new U.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && U.Physics.hasOwnProperty("Matter") && (this.matter = new U.Physics.Matter(this.game, this.config))
            },
            startSystem: function(t) {
                t === U.Physics.ARCADE ? this.arcade = new U.Physics.Arcade(this.game) : t === U.Physics.P2JS ? null === this.p2 ? this.p2 = new U.Physics.P2(this.game, this.config) : this.p2.reset() : t === U.Physics.NINJA ? this.ninja = new U.Physics.Ninja(this.game) : t === U.Physics.BOX2D ? null === this.box2d ? this.box2d = new U.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === U.Physics.MATTERJS && (null === this.matter ? this.matter = new U.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(t, e, i) {
                void 0 === e && (e = U.Physics.ARCADE), void 0 === i && (i = !1), e === U.Physics.ARCADE ? this.arcade.enable(t) : e === U.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === U.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === U.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === U.Physics.MATTERJS && this.matter && this.matter.enable(t)
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, U.Physics.prototype.constructor = U.Physics, U.Physics.Arcade = function(t) {
            this.game = t, this.gravity = new U.Point, this.bounds = new U.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = U.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new U.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, U.Physics.Arcade.prototype.constructor = U.Physics.Arcade, U.Physics.Arcade.SORT_NONE = 0, U.Physics.Arcade.LEFT_RIGHT = 1, U.Physics.Arcade.RIGHT_LEFT = 2, U.Physics.Arcade.TOP_BOTTOM = 3, U.Physics.Arcade.BOTTOM_TOP = 4, U.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, o) {
                this.bounds.setTo(t, e, i, o)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(t, e) {
                void 0 === e && (e = !0);
                var i = 1;
                if (Array.isArray(t))
                    for (i = t.length; i--;) t[i] instanceof U.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && 0 < t[i].children.length && this.enable(t[i], !0));
                else t instanceof U.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, !0))
            },
            enableBody: function(t) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new U.Physics.Arcade.Body(t), t.parent && t.parent instanceof U.Group && t.parent.addToHash(t))
            },
            updateMotion: function(t) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            },
            computeVelocity: function(t, e, i, o, s, n) {
                return void 0 === n && (n = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), o ? i += o * this.game.time.physicsElapsed : s && (0 < i - (s *= this.game.time.physicsElapsed) ? i -= s : i + s < 0 ? i += s : i = 0), n < i ? i = n : i < -n && (i = -n), i
            },
            overlap: function(t, e, i, o, s) {
                if (i = i || null, o = o || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (var n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, o, s, !0);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, o, s, !0);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (n = 0; n < t.length; n++)
                        for (var r = 0; r < e.length; r++) this.collideHandler(t[n], e[r], i, o, s, !0);
                else this.collideHandler(t, e, i, o, s, !0);
                return 0 < this._total
            },
            collide: function(t, e, i, o, s) {
                if (i = i || null, o = o || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (var n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, o, s, !1);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, o, s, !1);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (n = 0; n < t.length; n++)
                        for (var r = 0; r < e.length; r++) this.collideHandler(t[n], e[r], i, o, s, !1);
                else this.collideHandler(t, e, i, o, s, !1);
                return 0 < this._total
            },
            sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            },
            sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            },
            sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            },
            sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            },
            sort: function(t, e) {
                null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === U.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === U.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === U.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === U.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
            },
            collideHandler: function(t, e, i, o, s, n) {
                if (void 0 === e && t.physicsType === U.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, i, o, s, n);
                t && e && t.exists && e.exists && (this.sortDirection !== U.Physics.Arcade.SORT_NONE && (t.physicsType === U.GROUP && this.sort(t), e.physicsType === U.GROUP && this.sort(e)), t.physicsType === U.SPRITE ? e.physicsType === U.SPRITE ? this.collideSpriteVsSprite(t, e, i, o, s, n) : e.physicsType === U.GROUP ? this.collideSpriteVsGroup(t, e, i, o, s, n) : e.physicsType === U.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, o, s, n) : t.physicsType === U.GROUP ? e.physicsType === U.SPRITE ? this.collideSpriteVsGroup(e, t, i, o, s, n) : e.physicsType === U.GROUP ? this.collideGroupVsGroup(t, e, i, o, s, n) : e.physicsType === U.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, o, s, n) : t.physicsType === U.TILEMAPLAYER && (e.physicsType === U.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, o, s, n) : e.physicsType === U.GROUP && this.collideGroupVsTilemapLayer(e, t, i, o, s, n)))
            },
            collideSpriteVsSprite: function(t, e, i, o, s, n) {
                return !(!t.body || !e.body) && (this.separate(t.body, e.body, o, s, n) && (i && i.call(s, t, e), this._total++), !0)
            },
            collideSpriteVsGroup: function(t, e, i, o, s, n) {
                if (0 !== e.length && t.body)
                    if (this.skipQuadTree || t.body.skipQuadTree)
                        for (var r = {}, a = 0; a < e.hash.length; a++) {
                            var h = e.hash[a];
                            if (h && h.exists && h.body) {
                                if (r = h.body.getBounds(r), this.sortDirection === U.Physics.Arcade.LEFT_RIGHT) {
                                    if (t.body.right < r.x) break;
                                    if (r.right < t.body.x) continue
                                } else if (this.sortDirection === U.Physics.Arcade.RIGHT_LEFT) {
                                    if (t.body.x > r.right) break;
                                    if (r.x > t.body.right) continue
                                } else if (this.sortDirection === U.Physics.Arcade.TOP_BOTTOM) {
                                    if (t.body.bottom < r.y) break;
                                    if (r.bottom < t.body.y) continue
                                } else if (this.sortDirection === U.Physics.Arcade.BOTTOM_TOP) {
                                    if (t.body.y > r.bottom) break;
                                    if (r.y > t.body.bottom) continue
                                }
                                this.collideSpriteVsSprite(t, h, i, o, s, n)
                            }
                        } else {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                            var l = this.quadTree.retrieve(t);
                            for (a = 0; a < l.length; a++) this.separate(t.body, l[a], o, s, n) && (i && i.call(s, t, l[a].sprite), this._total++)
                        }
            },
            collideGroupVsSelf: function(t, e, i, o, s) {
                if (0 !== t.length)
                    for (var n = 0; n < t.hash.length; n++) {
                        var r = {},
                            a = t.hash[n];
                        if (a && a.exists && a.body) {
                            r = a.body.getBounds(r);
                            for (var h = n + 1; h < t.hash.length; h++) {
                                var l = {},
                                    d = t.hash[h];
                                if (d && d.exists && d.body) {
                                    if (l = d.body.getBounds(l), this.sortDirection === U.Physics.Arcade.LEFT_RIGHT) {
                                        if (r.right < l.x) break;
                                        if (l.right < r.x) continue
                                    } else if (this.sortDirection === U.Physics.Arcade.RIGHT_LEFT) {
                                        if (r.x > l.right) continue;
                                        if (l.x > r.right) break
                                    } else if (this.sortDirection === U.Physics.Arcade.TOP_BOTTOM) {
                                        if (r.bottom < l.y) continue;
                                        if (l.bottom < r.y) break
                                    } else if (this.sortDirection === U.Physics.Arcade.BOTTOM_TOP) {
                                        if (r.y > l.bottom) continue;
                                        if (l.y > a.body.bottom) break
                                    }
                                    this.collideSpriteVsSprite(a, d, e, i, o, s)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(t, e, i, o, s, n) {
                if (0 !== t.length && 0 !== e.length)
                    for (var r = 0; r < t.children.length; r++) t.children[r].exists && (t.children[r].physicsType === U.GROUP ? this.collideGroupVsGroup(t.children[r], e, i, o, s, n) : this.collideSpriteVsGroup(t.children[r], e, i, o, s, n))
            },
            separate: function(t, e, i, o, s) {
                if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                if (i && !1 === i.call(o, t.sprite, e.sprite)) return !1;
                if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s);
                if (t.isCircle !== e.isCircle) {
                    var n = t.isCircle ? e : t,
                        r = t.isCircle ? t : e,
                        a = n.x,
                        h = n.y,
                        l = n.right,
                        d = n.bottom,
                        c = r.x + r.radius,
                        u = r.y + r.radius;
                    if ((u < h || d < u) && (c < a || l < c)) return this.separateCircle(t, e, s)
                }
                var p = !1,
                    b = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (p = this.separateX(t, e, s), this.intersects(t, e) && (b = this.separateY(t, e, s))) : (b = this.separateY(t, e, s), this.intersects(t, e) && (p = this.separateX(t, e, s)));
                var m = p || b;
                return m && (s ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), m
            },
            intersects: function(t, e) {
                return t !== e && (t.isCircle ? e.isCircle ? U.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
            },
            circleBodyIntersects: function(t, e) {
                var i = U.Math.clamp(t.center.x, e.left, e.right),
                    o = U.Math.clamp(t.center.y, e.top, e.bottom);
                return (t.center.x - i) * (t.center.x - i) + (t.center.y - o) * (t.center.y - o) <= t.radius * t.radius
            },
            separateCircle: function(t, e, i) {
                this.getOverlapX(t, e), this.getOverlapY(t, e);
                var o = e.center.x - t.center.x,
                    s = e.center.y - t.center.y,
                    n = Math.atan2(s, o),
                    r = 0;
                if (t.isCircle !== e.isCircle) {
                    var a = {
                            x: e.isCircle ? t.position.x : e.position.x,
                            y: e.isCircle ? t.position.y : e.position.y,
                            right: e.isCircle ? t.right : e.right,
                            bottom: e.isCircle ? t.bottom : e.bottom
                        },
                        h = {
                            x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                            y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                            radius: t.isCircle ? t.radius : e.radius
                        };
                    h.y < a.y ? h.x < a.x ? r = U.Math.distance(h.x, h.y, a.x, a.y) - h.radius : a.right < h.x && (r = U.Math.distance(h.x, h.y, a.right, a.y) - h.radius) : a.bottom < h.y && (h.x < a.x ? r = U.Math.distance(h.x, h.y, a.x, a.bottom) - h.radius : a.right < h.x && (r = U.Math.distance(h.x, h.y, a.right, a.bottom) - h.radius)), r *= -1
                } else r = t.radius + e.radius - U.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                if (i || 0 === r || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== r && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== r;
                var l = t.velocity.x * Math.cos(n) + t.velocity.y * Math.sin(n),
                    d = t.velocity.x * Math.sin(n) - t.velocity.y * Math.cos(n),
                    c = e.velocity.x * Math.cos(n) + e.velocity.y * Math.sin(n),
                    u = e.velocity.x * Math.sin(n) - e.velocity.y * Math.cos(n),
                    p = ((t.mass - e.mass) * l + 2 * e.mass * c) / (t.mass + e.mass),
                    b = (2 * t.mass * l + (e.mass - t.mass) * c) / (t.mass + e.mass);
                return t.immovable || (t.velocity.x = (p * Math.cos(n) - d * Math.sin(n)) * t.bounce.x, t.velocity.y = (d * Math.cos(n) + p * Math.sin(n)) * t.bounce.y), e.immovable || (e.velocity.x = (b * Math.cos(n) - u * Math.sin(n)) * e.bounce.x, e.velocity.y = (u * Math.cos(n) + b * Math.sin(n)) * e.bounce.y), Math.abs(n) < Math.PI / 2 ? 0 < t.velocity.x && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : 0 < t.velocity.y && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(n) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : 0 < e.velocity.x && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : 0 < e.velocity.y && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - r * Math.cos(n), t.y += t.velocity.y * this.game.time.physicsElapsed - r * Math.sin(n)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + r * Math.cos(n), e.y += e.velocity.y * this.game.time.physicsElapsed + r * Math.sin(n)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
            },
            getOverlapX: function(t, e, i) {
                var o = 0,
                    s = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? s < (o = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? o = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (s < -(o = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? o = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = o, e.overlapX = o
            },
            getOverlapY: function(t, e, i) {
                var o = 0,
                    s = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? s < (o = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? o = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (s < -(o = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? o = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = o, e.overlapY = o
            },
            separateX: function(t, e, i) {
                var o = this.getOverlapX(t, e, i);
                if (i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== o || t.embedded && e.embedded;
                var s = t.velocity.x,
                    n = e.velocity.x;
                if (t.immovable || e.immovable) t.immovable ? (e.x += o, e.velocity.x = s - n * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= o, t.velocity.x = n - s * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else {
                    o *= .5, t.x -= o, e.x += o;
                    var r = Math.sqrt(n * n * e.mass / t.mass) * (0 < n ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (0 < s ? 1 : -1),
                        h = .5 * (r + a);
                    r -= h, a -= h, t.velocity.x = h + r * t.bounce.x, e.velocity.x = h + a * e.bounce.x
                }
                return !0
            },
            separateY: function(t, e, i) {
                var o = this.getOverlapY(t, e, i);
                if (i || 0 === o || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== o || t.embedded && e.embedded;
                var s = t.velocity.y,
                    n = e.velocity.y;
                if (t.immovable || e.immovable) t.immovable ? (e.y += o, e.velocity.y = s - n * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= o, t.velocity.y = n - s * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else {
                    o *= .5, t.y -= o, e.y += o;
                    var r = Math.sqrt(n * n * e.mass / t.mass) * (0 < n ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (0 < s ? 1 : -1),
                        h = .5 * (r + a);
                    r -= h, a -= h, t.velocity.y = h + r * t.bounce.y, e.velocity.y = h + a * e.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(t, e, i, o) {
                if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, o, t)
            },
            getObjectsAtLocation: function(t, e, i, o, s, n) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(i);
                for (var r = new U.Rectangle(t, e, 1, 1), a = [], h = this.quadTree.retrieve(r), l = 0; l < h.length; l++) h[l].hitTest(t, e) && (o && o.call(s, n, h[l].sprite), a.push(h[l].sprite));
                return a
            },
            moveToObject: function(t, e, i, o) {
                void 0 === i && (i = 60), void 0 === o && (o = 0);
                var s = Math.atan2(e.y - t.y, e.x - t.x);
                return 0 < o && (i = this.distanceBetween(t, e) / (o / 1e3)), t.body.velocity.x = Math.cos(s) * i, t.body.velocity.y = Math.sin(s) * i, s
            },
            moveToPointer: function(t, e, i, o) {
                void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === o && (o = 0);
                var s = this.angleToPointer(t, i);
                return 0 < o && (e = this.distanceToPointer(t, i) / (o / 1e3)), t.body.velocity.x = Math.cos(s) * e, t.body.velocity.y = Math.sin(s) * e, s
            },
            moveToXY: function(t, e, i, o, s) {
                void 0 === o && (o = 60), void 0 === s && (s = 0);
                var n = Math.atan2(i - t.y, e - t.x);
                return 0 < s && (o = this.distanceToXY(t, e, i) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * o, t.body.velocity.y = Math.sin(n) * o, n
            },
            velocityFromAngle: function(t, e, i) {
                return void 0 === e && (e = 60), (i = i || new U.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
            },
            velocityFromRotation: function(t, e, i) {
                return void 0 === e && (e = 60), (i = i || new U.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerationFromRotation: function(t, e, i) {
                return void 0 === e && (e = 60), (i = i || new U.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerateToObject: function(t, e, i, o, s) {
                void 0 === i && (i = 60), void 0 === o && (o = 1e3), void 0 === s && (s = 1e3);
                var n = this.angleBetween(t, e);
                return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(o, s), n
            },
            accelerateToPointer: function(t, e, i, o, s) {
                void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === o && (o = 1e3), void 0 === s && (s = 1e3);
                var n = this.angleToPointer(t, e);
                return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(o, s), n
            },
            accelerateToXY: function(t, e, i, o, s, n) {
                void 0 === o && (o = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                var r = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(Math.cos(r) * o, Math.sin(r) * o), t.body.maxVelocity.setTo(s, n), r
            },
            distanceBetween: function(t, e, i) {
                void 0 === i && (i = !1);
                var o = i ? t.world.x - e.world.x : t.x - e.x,
                    s = i ? t.world.y - e.world.y : t.y - e.y;
                return Math.sqrt(o * o + s * s)
            },
            distanceToXY: function(t, e, i, o) {
                void 0 === o && (o = !1);
                var s = o ? t.world.x - e : t.x - e,
                    n = o ? t.world.y - i : t.y - i;
                return Math.sqrt(s * s + n * n)
            },
            distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                var o = i ? t.world.x - e.worldX : t.x - e.worldX,
                    s = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(o * o + s * s)
            },
            angleBetween: function(t, e, i) {
                return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX,
                    o = e.centerY - t.centerY;
                return Math.atan2(o, i)
            },
            angleToXY: function(t, e, i, o) {
                return void 0 === o && (o = !1), o ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            },
            angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            },
            worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        }, U.Physics.Arcade.Body = function(t) {
            this.sprite = t, this.game = t.game, this.type = U.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new U.Point, this.position = new U.Point(t.x, t.y), this.prev = new U.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new U.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new U.Point, this.newVelocity = new U.Point, this.deltaMax = new U.Point, this.acceleration = new U.Point, this.drag = new U.Point, this.allowGravity = !0, this.gravity = new U.Point, this.bounce = new U.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new U.Point(1e4, 1e4), this.friction = new U.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = U.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                any: !0,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new U.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new U.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
        }, U.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x),
                        i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var t = 0,
                    e = 0 !== this.overlapX || 0 !== this.overlapY;
                if (t = 0 < this.moveDuration ? (this.moveTimer += this.game.time.elapsedMS, this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || 1 <= t || void 0 !== i && !0 !== i) || (this.stopMovement(1 <= t || this.stopVelocityOnCollide && e), !1)
            },
            stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = U.LEFT : 0 < this.deltaX() && (this.facing = U.RIGHT), this.deltaY() < 0 ? this.facing = U.UP : 0 < this.deltaY() && (this.facing = U.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : 0 < this._dx && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : 0 < this._dy && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var t = this.position,
                    e = this.game.physics.arcade.bounds,
                    i = this.game.physics.arcade.checkCollision,
                    o = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var n = this.center.x - this.radius,
                        r = this.center.y - this.radius,
                        a = this.center.x + this.radius,
                        h = this.center.y + this.radius;
                    n < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= o, this.blocked.left = !0) : a > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= o, this.blocked.right = !0), r < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= s, this.blocked.up = !0) : h > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= s, this.blocked.down = !0)
                } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= o, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= o, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(t, e, i) {
                return void 0 === e && (e = this.speed), 0 !== e && (void 0 === i ? (o = this.angle, i = this.game.math.radToDeg(o)) : o = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(o) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(o) * e) : this.velocity.set(Math.cos(o) * e, Math.sin(o) * e), this.isMoving = !0);
                var o
            },
            moveTo: function(t, e, i) {
                var o, s = e / (t / 1e3);
                return 0 !== s && (void 0 === i ? (o = this.angle, i = this.game.math.radToDeg(o)) : o = this.game.math.degToRad(i), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new U.Line, this.moveEnd = new U.Point), this.moveTarget.fromAngle(this.x, this.y, o, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === i || 180 === i ? this.velocity.set(Math.cos(o) * s, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(o) * s) : this.velocity.set(Math.cos(o) * s, Math.sin(o) * s), this.isMoving = !0)
            },
            setSize: function(t, e, i, o) {
                void 0 === i && (i = this.offset.x), void 0 === o && (o = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, o), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
            },
            setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), 0 < t ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
            },
            reset: function(t, e) {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            getBounds: function(t) {
                return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
            },
            hitTest: function(t, e) {
                return this.isCircle ? U.Circle.contains(this, t, e) : U.Rectangle.contains(this, t, e)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof U.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(U.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(U.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(U.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(U.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(U.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        }), Object.defineProperty(U.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }), U.Physics.Arcade.Body.render = function(t, e, i, o) {
            void 0 === o && (o = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), o ? t.fill() : t.stroke()) : o ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }, U.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }, U.Physics.Arcade.Body.prototype.constructor = U.Physics.Arcade.Body, U.Physics.Arcade.TilemapCollision = function() {}, U.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(t, e, i, o, s, n) {
                if (t.body) {
                    var r = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if (0 !== r.length)
                        for (var a = 0; a < r.length; a++) o ? o.call(s, t, r[a]) && this.separateTile(a, t.body, r[a], e, n) && (this._total++, i && i.call(s, t, r[a])) : this.separateTile(a, t.body, r[a], e, n) && (this._total++, i && i.call(s, t, r[a]))
                }
            },
            collideGroupVsTilemapLayer: function(t, e, i, o, s, n) {
                if (0 !== t.length)
                    for (var r = 0; r < t.children.length; r++) t.children[r].exists && this.collideSpriteVsTilemapLayer(t.children[r], e, i, o, s, n)
            },
            separateTile: function(t, e, i, o, s) {
                if (!e.enable) return !1;
                var n = o.fixedToCamera ? 0 : o.position.x,
                    r = o.fixedToCamera ? 0 : o.position.y;
                if (!i.intersects(e.position.x - n, e.position.y - r, e.right - n, e.bottom - r)) return !1;
                if (s) return !0;
                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                var a = 0,
                    h = 0,
                    l = 0,
                    d = 1;
                if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (d = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - n - i.right), Math.abs(e.right - n - i.left)), d = Math.min(Math.abs(e.position.y - r - i.bottom), Math.abs(e.bottom - r - i.top))), l < d) {
                    if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, o)) && !i.intersects(e.position.x - n, e.position.y - r, e.right - n, e.bottom - r)) return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, o))
                } else {
                    if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, o)) && !i.intersects(e.position.x - n, e.position.y - r, e.right - n, e.bottom - r)) return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, o))
                }
                return 0 !== a || 0 !== h
            },
            tileCheckX: function(t, e, i) {
                var o = 0,
                    s = i.fixedToCamera ? 0 : i.position.x;
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - s < e.right && (o = t.x - s - e.right) < -this.TILE_BIAS && (o = 0) : 0 < t.deltaX() && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - s > e.left && (o = t.right - s - e.left) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateX ? t.overlapX = o : this.processTileSeparationX(t, o)), o
            },
            tileCheckY: function(t, e, i) {
                var o = 0,
                    s = i.fixedToCamera ? 0 : i.position.y;
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - s < e.bottom && (o = t.y - s - e.bottom) < -this.TILE_BIAS && (o = 0) : 0 < t.deltaY() && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - s > e.top && (o = t.bottom - s - e.top) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateY ? t.overlapY = o : this.processTileSeparationY(t, o)), o
            },
            processTileSeparationX: function(t, e) {
                e < 0 ? t.blocked.left = !0 : 0 < e && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            },
            processTileSeparationY: function(t, e) {
                e < 0 ? t.blocked.up = !0 : 0 < e && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        }, U.Utils.mixinPrototype(U.Physics.Arcade.prototype, U.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, U.Physics.P2 = function(t, e) {
            this.game = t, void 0 === e ? e = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new U.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }, this.onBodyAdded = new U.Signal, this.onBodyRemoved = new U.Signal, this.onSpringAdded = new U.Signal, this.onSpringRemoved = new U.Signal, this.onConstraintAdded = new U.Signal, this.onConstraintRemoved = new U.Signal, this.onContactMaterialAdded = new U.Signal, this.onContactMaterialRemoved = new U.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new U.Signal, this.onEndContact = new U.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new U.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new U.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new U.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }, U.Physics.P2.prototype = {
            removeBodyNextStep: function(t) {
                this._toRemove.push(t)
            },
            preUpdate: function() {
                for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0
            },
            enable: function(t, e, i) {
                void 0 === e && (e = !1), void 0 === i && (i = !0);
                var o = 1;
                if (Array.isArray(t))
                    for (o = t.length; o--;) t[o] instanceof U.Group ? this.enable(t[o].children, e, i) : (this.enableBody(t[o], e), i && t[o].hasOwnProperty("children") && 0 < t[o].children.length && this.enable(t[o], e, !0));
                else t instanceof U.Group ? this.enable(t.children, e, i) : (this.enableBody(t, e), i && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, e, !0))
            },
            enableBody: function(t, e) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new U.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5))
            },
            setImpactEvents: function(t) {
                t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(t, e) {
                this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(t) {
                if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; 0 <= e; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
            },
            impactHandler: function(t) {
                if (t.bodyA.parent && t.bodyB.parent) {
                    var e = t.bodyA.parent,
                        i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                }
            },
            beginContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
            },
            endContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
            },
            setBoundsToWorld: function(t, e, i, o, s) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, o, s)
            },
            setWorldMaterial: function(t, e, i, o, s) {
                void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === s && (s = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), o && this.walls.top && (this.walls.top.shapes[0].material = t), s && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
            },
            updateBoundsCollisionGroup: function(t) {
                void 0 === t && (t = !0);
                var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
            },
            setBounds: function(t, e, i, o, s, n, r, a, h) {
                void 0 === s && (s = this._boundsLeft), void 0 === n && (n = this._boundsRight), void 0 === r && (r = this._boundsTop), void 0 === a && (a = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(s, "left", t, e, 1.5707963267948966, h), this.setupWall(n, "right", t + i, e, -1.5707963267948966, h), this.setupWall(r, "top", t, e, -3.141592653589793, h), this.setupWall(a, "bottom", t, e + o, 0, h), this._boundsLeft = s, this._boundsRight = n, this._boundsTop = r, this._boundsBottom = a, this._boundsOwnGroup = h
            },
            setupWall: function(t, e, i, o, s, n) {
                t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(o)] : (this.walls[e] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(i), this.pxmi(o)],
                    angle: s
                }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), n && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new U.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new U.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new U.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var t = this.world.constraints, e = t.length - 1; 0 <= e; e--) this.world.removeConstraint(t[e]);
                var i = this.world.bodies;
                for (e = i.length - 1; 0 <= e; e--) this.world.removeBody(i[e]);
                var o = this.world.springs;
                for (e = o.length - 1; 0 <= e; e--) this.world.removeSpring(o[e]);
                var s = this.world.contactMaterials;
                for (e = s.length - 1; 0 <= e; e--) this.world.removeContactMaterial(s[e]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(), this.game = null
            },
            addBody: function(t) {
                return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
            },
            removeBody: function(t) {
                return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
            },
            addSpring: function(t) {
                return t instanceof U.Physics.P2.Spring || t instanceof U.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
            },
            removeSpring: function(t) {
                return t instanceof U.Physics.P2.Spring || t instanceof U.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
            },
            createDistanceConstraint: function(t, e, i, o, s, n) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new U.Physics.P2.DistanceConstraint(this, t, e, i, o, s, n))
            },
            createGearConstraint: function(t, e, i, o) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new U.Physics.P2.GearConstraint(this, t, e, i, o))
            },
            createRevoluteConstraint: function(t, e, i, o, s, n) {
                if (t = this.getBody(t), i = this.getBody(i), t && i) return this.addConstraint(new U.Physics.P2.RevoluteConstraint(this, t, e, i, o, s, n))
            },
            createLockConstraint: function(t, e, i, o, s) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new U.Physics.P2.LockConstraint(this, t, e, i, o, s))
            },
            createPrismaticConstraint: function(t, e, i, o, s, n, r) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new U.Physics.P2.PrismaticConstraint(this, t, e, i, o, s, n, r))
            },
            addConstraint: function(t) {
                return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
            },
            removeConstraint: function(t) {
                return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
            },
            addContactMaterial: function(t) {
                return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
            },
            removeContactMaterial: function(t) {
                return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
            },
            getContactMaterial: function(t, e) {
                return this.world.getContactMaterial(t, e)
            },
            setMaterial: function(t, e) {
                for (var i = e.length; i--;) e[i].setMaterial(t)
            },
            createMaterial: function(t, e) {
                t = t || "";
                var i = new U.Physics.P2.Material(t);
                return this.materials.push(i), void 0 !== e && e.setMaterial(i), i
            },
            createContactMaterial: function(t, e, i) {
                void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial());
                var o = new U.Physics.P2.ContactMaterial(t, e, i);
                return this.addContactMaterial(o)
            },
            getBodies: function() {
                for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                return t
            },
            getBody: function(t) {
                return t instanceof p2.Body ? t : t instanceof U.Physics.P2.Body ? t.data : t.body && t.body.type === U.Physics.P2JS ? t.body.data : null
            },
            getSprings: function() {
                for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                return t
            },
            getConstraints: function() {
                for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                return t
            },
            hitTest: function(t, e, i, o) {
                void 0 === e && (e = this.world.bodies), void 0 === i && (i = 5), void 0 === o && (o = !1);
                for (var s = [this.pxmi(t.x), this.pxmi(t.y)], n = [], r = e.length; r--;) e[r] instanceof U.Physics.P2.Body && (!o || e[r].data.type !== p2.Body.STATIC) ? n.push(e[r].data) : e[r] instanceof p2.Body && e[r].parent && (!o || e[r].type !== p2.Body.STATIC) ? n.push(e[r]) : e[r] instanceof U.Sprite && e[r].hasOwnProperty("body") && (!o || e[r].body.data.type !== p2.Body.STATIC) && n.push(e[r].body.data);
                return this.world.hitTest(s, n, i)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(t) {
                var e = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                var i = new U.Physics.P2.CollisionGroup(e);
                return this.collisionGroups.push(i), t && this.setCollisionGroup(t, i), i
            },
            setCollisionGroup: function(t, e) {
                if (t instanceof U.Group)
                    for (var i = 0; i < t.total; i++) t.children[i].body && t.children[i].body.type === U.Physics.P2JS && t.children[i].body.setCollisionGroup(e);
                else t.body.setCollisionGroup(e)
            },
            createSpring: function(t, e, i, o, s, n, r, a, h) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new U.Physics.P2.Spring(this, t, e, i, o, s, n, r, a, h))
            },
            createRotationalSpring: function(t, e, i, o, s) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new U.Physics.P2.RotationalSpring(this, t, e, i, o, s))
            },
            createBody: function(t, e, i, o, s, n) {
                void 0 === o && (o = !1);
                var r = new U.Physics.P2.Body(this.game, null, t, e, i);
                if (n && !r.addPolygon(s, n)) return !1;
                return o && this.world.addBody(r.data), r
            },
            createParticle: function(t, e, i, o, s, n) {
                void 0 === o && (o = !1);
                var r = new U.Physics.P2.Body(this.game, null, t, e, i);
                if (n && !r.addPolygon(s, n)) return !1;
                return o && this.world.addBody(r.data), r
            },
            convertCollisionObjects: function(t, e, i) {
                void 0 === i && (i = !0);
                for (var o = [], s = 0, n = t.collision[e].length; s < n; s++) {
                    var r = t.collision[e][s],
                        a = this.createBody(r.x, r.y, 0, i, {}, r.polyline);
                    a && o.push(a)
                }
                return o
            },
            clearTilemapLayerBodies: function(t, e) {
                e = t.getLayer(e);
                for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0
            },
            convertTilemap: function(t, e, i, o) {
                e = t.getLayer(e), void 0 === i && (i = !0), void 0 === o && (o = !0), this.clearTilemapLayerBodies(t, e);
                for (var s = 0, n = 0, r = 0, a = 0, h = t.layers[e].height; a < h; a++)
                    for (var l = s = 0, d = t.layers[e].width; l < d; l++) {
                        var c = t.layers[e].data[a][l];
                        if (c && -1 < c.index && c.collides)
                            if (o) {
                                var u = t.getTileRight(e, l, a);
                                if (0 === s && (n = c.x * c.width, r = c.y * c.height, s = c.width), u && u.collides) s += c.width;
                                else(p = this.createBody(n, r, 0, !1)).addRectangle(s, c.height, s / 2, c.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), s = 0
                            } else {
                                var p;
                                (p = this.createBody(c.x * c.width, c.y * c.height, 0, !1)).addRectangle(c.width, c.height, c.width / 2, c.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                            }
                    }
                return t.layers[e].bodies
            },
            mpx: function(t) {
                return 20 * t
            },
            pxm: function(t) {
                return .05 * t
            },
            mpxi: function(t) {
                return -20 * t
            },
            pxmi: function(t) {
                return -.05 * t
            }
        }, Object.defineProperty(U.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(t) {
                this.world.defaultContactMaterial.friction = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(t) {
                this.world.defaultContactMaterial.restitution = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(t) {
                this.world.defaultContactMaterial = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(t) {
                this.world.applySpringForces = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(t) {
                this.world.applyDamping = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(t) {
                this.world.applyGravity = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(t) {
                this.world.solveConstraints = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(t) {
                this.world.emitImpactEvent = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(t) {
                this.world.sleepMode = t
            }
        }), Object.defineProperty(U.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }), U.Physics.P2.FixtureList = function(t) {
            Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
        }, U.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
            },
            setCategory: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.collisionGroup = e
                })
            },
            setMask: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.collisionMask = e
                })
            },
            setSensor: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.sensor = e
                })
            },
            setMaterial: function(e, t) {
                this.getFixtures(t).forEach(function(t) {
                    t.material = e
                })
            },
            getFixtures: function(t) {
                var e = [];
                if (t) {
                    t instanceof Array || (t = [t]);
                    var i = this;
                    return t.forEach(function(t) {
                        i.namedFixtures[t] && e.push(i.namedFixtures[t])
                    }), this.flatten(e)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(t) {
                return this.namedFixtures[t]
            },
            getGroup: function(t) {
                return this.groupedFixtures[t]
            },
            parse: function() {
                var t, e, i, o;
                for (t in o = [], i = this.rawList) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), o.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(t) {
                var e, i;
                return e = [], i = arguments.callee, t.forEach(function(t) {
                    return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                }), e
            }
        }, U.Physics.P2.PointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, U.Physics.P2.PointProxy.prototype.constructor = U.Physics.P2.PointProxy, Object.defineProperty(U.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxm(t)
            }
        }), Object.defineProperty(U.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxm(t)
            }
        }), Object.defineProperty(U.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = t
            }
        }), Object.defineProperty(U.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = t
            }
        }), U.Physics.P2.InversePointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, U.Physics.P2.InversePointProxy.prototype.constructor = U.Physics.P2.InversePointProxy, Object.defineProperty(U.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(U.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(U.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = -t
            }
        }), Object.defineProperty(U.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = -t
            }
        }), U.Physics.P2.Body = function(t, e, i, o, s) {
            e = e || null, i = i || 0, o = o || 0, void 0 === s && (s = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = U.Physics.P2JS, this.offset = new U.Point, this.data = new p2.Body({
                position: [this.world.pxmi(i), this.world.pxmi(o)],
                mass: s
            }), (this.data.parent = this).velocity = new U.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new U.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new U.Point, this.onBeginContact = new U.Signal, this.onEndContact = new U.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
        }, U.Physics.P2.Body.prototype = {
            createBodyCallback: function(t, e, i) {
                var o = -1;
                t.id ? o = t.id : t.body && (o = t.body.id), -1 < o && (null === e ? (delete this._bodyCallbacks[o], delete this._bodyCallbackContext[o]) : (this._bodyCallbacks[o] = e, this._bodyCallbackContext[o] = i))
            },
            createGroupCallback: function(t, e, i) {
                null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
            },
            getCollisionMask: function() {
                var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                return t
            },
            updateCollisionMask: function(t) {
                var e = this.getCollisionMask();
                if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; 0 <= i; i--) this.data.shapes[i].collisionMask = e;
                else t.collisionMask = e
            },
            setCollisionGroup: function(t, e) {
                var i = this.getCollisionMask();
                if (void 0 === e)
                    for (var o = this.data.shapes.length - 1; 0 <= o; o--) this.data.shapes[o].collisionGroup = t.mask, this.data.shapes[o].collisionMask = i;
                else e.collisionGroup = t.mask, e.collisionMask = i
            },
            clearCollision: function(t, e, i) {
                if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                    for (var o = this.data.shapes.length - 1; 0 <= o; o--) t && (this.data.shapes[o].collisionGroup = null), e && (this.data.shapes[o].collisionMask = null);
                else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(t, e, i) {
                var o;
                if (void 0 === e && (e = !0), Array.isArray(t))
                    for (var s = 0; s < t.length; s++) - 1 < (o = this.collidesWith.indexOf(t[s])) && (this.collidesWith.splice(o, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                else -1 < (o = this.collidesWith.indexOf(t)) && (this.collidesWith.splice(o, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                var n = this.getCollisionMask();
                if (void 0 === i)
                    for (s = this.data.shapes.length - 1; 0 <= s; s--) this.data.shapes[s].collisionMask = n;
                else i.collisionMask = n
            },
            collides: function(t, e, i, o) {
                if (Array.isArray(t))
                    for (var s = 0; s < t.length; s++) - 1 === this.collidesWith.indexOf(t[s]) && (this.collidesWith.push(t[s]), e && this.createGroupCallback(t[s], e, i));
                else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                var n = this.getCollisionMask();
                if (void 0 === o)
                    for (s = this.data.shapes.length - 1; 0 <= s; s--) this.data.shapes[s].collisionMask = n;
                else o.collisionMask = n
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(), this.shapeChanged()
            },
            getVelocityAtPoint: function(t, e) {
                return this.data.getVelocityAtPoint(t, e)
            },
            applyDamping: function(t) {
                this.data.applyDamping(t)
            },
            applyImpulse: function(t, e, i) {
                this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyImpulseLocal: function(t, e, i) {
                this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyForce: function(t, e, i) {
                this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0, this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0, this.data.angularDamping = 0
            },
            toLocalFrame: function(t, e) {
                return this.data.toLocalFrame(t, e)
            },
            toWorldFrame: function(t, e) {
                return this.data.toWorldFrame(t, e)
            },
            rotateLeft: function(t) {
                this.data.angularVelocity = this.world.pxm(-t)
            },
            rotateRight: function(t) {
                this.data.angularVelocity = this.world.pxm(t)
            },
            moveForward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
            },
            moveBackward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i)
            },
            thrust: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustLeft: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustRight: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            reverse: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            moveLeft: function(t) {
                this.data.velocity[0] = this.world.pxmi(-t)
            },
            moveRight: function(t) {
                this.data.velocity[0] = this.world.pxmi(t)
            },
            moveUp: function(t) {
                this.data.velocity[1] = this.world.pxmi(-t)
            },
            moveDown: function(t) {
                this.data.velocity[1] = this.world.pxmi(t)
            },
            preUpdate: function() {
                this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
            },
            reset: function(t, e, i, o) {
                void 0 === i && (i = !1), void 0 === o && (o = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), o && (this.mass = 1), this.x = t, this.y = e
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
            },
            clearShapes: function() {
                for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged()
            },
            addShape: function(t, e, i, o) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], o), this.shapeChanged(), t
            },
            addCircle: function(t, e, i, o) {
                var s = new p2.Circle({
                    radius: this.world.pxm(t)
                });
                return this.addShape(s, e, i, o)
            },
            addRectangle: function(t, e, i, o, s) {
                var n = new p2.Box({
                    width: this.world.pxm(t),
                    height: this.world.pxm(e)
                });
                return this.addShape(n, i, o, s)
            },
            addPlane: function(t, e, i) {
                var o = new p2.Plane;
                return this.addShape(o, t, e, i)
            },
            addParticle: function(t, e, i) {
                var o = new p2.Particle;
                return this.addShape(o, t, e, i)
            },
            addLine: function(t, e, i, o) {
                var s = new p2.Line({
                    length: this.world.pxm(t)
                });
                return this.addShape(s, e, i, o)
            },
            addCapsule: function(t, e, i, o, s) {
                var n = new p2.Capsule({
                    length: this.world.pxm(t),
                    radius: this.world.pxm(e)
                });
                return this.addShape(n, i, o, s)
            },
            addPolygon: function(t, e) {
                t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                var i = [];
                if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                else if (Array.isArray(e[0])) i = e.slice();
                else if ("number" == typeof e[0])
                    for (var o = 0, s = e.length; o < s; o += 2) i.push([e[o], e[o + 1]]);
                var n = i.length - 1;
                i[n][0] === i[0][0] && i[n][1] === i[0][1] && i.pop();
                for (var r = 0; r < i.length; r++) i[r][0] = this.world.pxmi(i[r][0]), i[r][1] = this.world.pxmi(i[r][1]);
                var a = this.data.fromPolygon(i, t);
                return this.shapeChanged(), a
            },
            removeShape: function(t) {
                var e = this.data.removeShape(t);
                return this.shapeChanged(), e
            },
            setCircle: function(t, e, i, o) {
                return this.clearShapes(), this.addCircle(t, e, i, o)
            },
            setRectangle: function(t, e, i, o, s) {
                return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, o, s)
            },
            setRectangleFromSprite: function(t) {
                return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
            },
            setMaterial: function(t, e) {
                if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; 0 <= i; i--) this.data.shapes[i].material = t;
                else e.material = t
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(t, e) {
                for (var i = this.game.cache.getPhysicsData(t, e), o = [], s = 0; s < i.length; s++) {
                    var n = i[s],
                        r = this.addFixture(n);
                    o[n.filter.group] = o[n.filter.group] || [], o[n.filter.group] = o[n.filter.group].concat(r), n.fixtureKey && (o[n.fixtureKey] = r)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), o
            },
            addFixture: function(t) {
                var e = [];
                if (t.circle) {
                    (l = new p2.Circle({
                        radius: this.world.pxm(t.circle.radius)
                    })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor;
                    var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l)
                } else
                    for (var o = t.polygons, s = p2.vec2.create(), n = 0; n < o.length; n++) {
                        for (var r = o[n], a = [], h = 0; h < r.length; h += 2) a.push([this.world.pxmi(r[h]), this.world.pxmi(r[h + 1])]);
                        for (var l = new p2.Convex({
                                vertices: a
                            }), d = 0; d !== l.vertices.length; d++) {
                            var c = l.vertices[d];
                            p2.vec2.sub(c, c, l.centerOfMass)
                        }
                        p2.vec2.scale(s, l.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, s), e.push(l)
                    }
                return e
            },
            loadPolygon: function(t, e) {
                if (null === t) var i = e;
                else i = this.game.cache.getPhysicsData(t, e);
                for (var o = p2.vec2.create(), s = 0; s < i.length; s++) {
                    for (var n = [], r = 0; r < i[s].shape.length; r += 2) n.push([this.world.pxmi(i[s].shape[r]), this.world.pxmi(i[s].shape[r + 1])]);
                    for (var a = new p2.Convex({
                            vertices: n
                        }), h = 0; h !== a.vertices.length; h++) {
                        var l = a.vertices[h];
                        p2.vec2.sub(l, l, a.centerOfMass)
                    }
                    p2.vec2.scale(o, a.centerOfMass, 1), o[0] -= this.world.pxmi(this.sprite.width / 2), o[1] -= this.world.pxmi(this.sprite.height / 2), a.updateTriangles(), a.updateCenterOfMass(), a.updateBoundingRadius(), this.data.addShape(a, o)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, U.Physics.P2.Body.prototype.constructor = U.Physics.P2.Body, U.Physics.P2.Body.DYNAMIC = 1, U.Physics.P2.Body.STATIC = 2, U.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(U.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === U.Physics.P2.Body.STATIC
            },
            set: function(t) {
                t && this.data.type !== U.Physics.P2.Body.STATIC ? (this.data.type = U.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== U.Physics.P2.Body.STATIC || (this.data.type = U.Physics.P2.Body.DYNAMIC, this.mass = 1)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === U.Physics.P2.Body.DYNAMIC
            },
            set: function(t) {
                t && this.data.type !== U.Physics.P2.Body.DYNAMIC ? (this.data.type = U.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== U.Physics.P2.Body.DYNAMIC || (this.data.type = U.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === U.Physics.P2.Body.KINEMATIC
            },
            set: function(t) {
                t && this.data.type !== U.Physics.P2.Body.KINEMATIC ? (this.data.type = U.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== U.Physics.P2.Body.KINEMATIC || (this.data.type = U.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(t) {
                t !== this.data.allowSleep && (this.data.allowSleep = t)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return U.Math.wrapAngle(U.Math.radToDeg(this.data.angle))
            },
            set: function(t) {
                this.data.angle = U.Math.degToRad(U.Math.wrapAngle(t))
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(t) {
                this.data.angularDamping = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(t) {
                this.data.angularForce = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(t) {
                this.data.angularVelocity = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(t) {
                this.data.damping = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(t) {
                t !== this.data.fixedRotation && (this.data.fixedRotation = t)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(t) {
                this.data.inertia = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(t) {
                t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(t) {
                t !== this.data.type && (this.data.type = t)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(t) {
                this.data.angle = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(t) {
                this.data.sleepSpeedLimit = t
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(t) {
                this.data.position[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(t) {
                this.data.position[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(t) {
                t && !this.debugBody ? this.debugBody = new U.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
            }
        }), Object.defineProperty(U.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(t) {
                t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
            }
        }), U.Physics.P2.BodyDebug = function(t, e, i) {
            U.Group.call(this, t);
            var o = {
                pixelsPerLengthUnit: t.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = U.Utils.extend(o, i), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new U.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, U.Physics.P2.BodyDebug.prototype = Object.create(U.Group.prototype), U.Physics.P2.BodyDebug.prototype.constructor = U.Physics.P2.BodyDebug, U.Utils.extend(U.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
            },
            draw: function() {
                var t, e, i, o, s, n, r, a, h, l, d, c, u, p, b;
                if (a = this.body, (l = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), n = 16711680, r = this.lineWidth, a instanceof p2.Body && a.shapes.length) {
                    var m = a.shapes.length;
                    for (o = 0; o !== m;) {
                        if (h = (e = a.shapes[o]).position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.radius * this.ppu, i, r);
                        else if (e instanceof p2.Capsule) this.drawCapsule(l, h[0] * this.ppu, h[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, n, i, r);
                        else if (e instanceof p2.Plane) this.drawPlane(l, h[0] * this.ppu, -h[1] * this.ppu, i, n, 5 * r, 10 * r, 10 * r, 100 * this.ppu, t);
                        else if (e instanceof p2.Line) this.drawLine(l, e.length * this.ppu, n, r);
                        else if (e instanceof p2.Box) this.drawRectangle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, n, i, r);
                        else if (e instanceof p2.Convex) {
                            for (c = [], u = p2.vec2.create(), s = p = 0, b = e.vertices.length; 0 <= b ? p < b : b < p; s = 0 <= b ? ++p : --p) d = e.vertices[s], p2.vec2.rotate(u, d, t), c.push([(u[0] + h[0]) * this.ppu, -(u[1] + h[1]) * this.ppu]);
                            this.drawConvex(l, c, e.triangles, n, i, r, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                        }
                        o++
                    }
                }
            },
            drawRectangle: function(t, e, i, o, s, n, r, a, h) {
                void 0 === h && (h = 1), void 0 === r && (r = 0), t.lineStyle(h, r, 1), t.beginFill(a), t.drawRect(e - s / 2, i - n / 2, s, n)
            },
            drawCircle: function(t, e, i, o, s, n, r) {
                void 0 === r && (r = 1), void 0 === n && (n = 16777215), t.lineStyle(r, 0, 1), t.beginFill(n, 1), t.drawCircle(e, i, 2 * -s), t.endFill(), t.moveTo(e, i), t.lineTo(e + s * Math.cos(-o), i + s * Math.sin(-o))
            },
            drawLine: function(t, e, i, o) {
                void 0 === o && (o = 1), void 0 === i && (i = 0), t.lineStyle(5 * o, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
            },
            drawConvex: function(t, e, i, o, s, n, r, a) {
                var h, l, d, c, u, p, b, m, y, f, x;
                if (void 0 === n && (n = 1), void 0 === o && (o = 0), r) {
                    for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) c = e[l % e.length], u = e[(l + 1) % e.length], b = c[0], f = c[1], m = u[0], x = u[1], t.lineStyle(n, h[l % h.length], 1), t.moveTo(b, -f), t.lineTo(m, -x), t.drawCircle(b, -f, 2 * n), l++;
                    return t.lineStyle(n, 0, 1), t.drawCircle(a[0], a[1], 2 * n)
                }
                for (t.lineStyle(n, o, 1), t.beginFill(s), l = 0; l !== e.length;) p = (d = e[l])[0], y = d[1], 0 === l ? t.moveTo(p, -y) : t.lineTo(p, -y), l++;
                if (t.endFill(), 2 < e.length) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
            },
            drawPath: function(t, e, i, o, s) {
                var n, r, a, h, l, d, c, u, p, b, m;
                for (void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(s, i, 1), "number" == typeof o && t.beginFill(o), a = r = null, n = 0; n < e.length;) b = (p = e[n])[0], m = p[1], b === r && m === a || (0 === n ? t.moveTo(b, m) : (h = r, l = a, d = b, c = m, u = e[(n + 1) % e.length][0], 0 !== (d - h) * (e[(n + 1) % e.length][1] - l) - (u - h) * (c - l) && t.lineTo(b, m)), r = b, a = m), n++;
                "number" == typeof o && t.endFill(), 2 < e.length && "number" == typeof o && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
            },
            drawPlane: function(t, e, i, o, s, n, r, a, h, l) {
                var d, c;
                void 0 === n && (n = 1), void 0 === o && (o = 16777215), t.lineStyle(n, s, 11), t.beginFill(o), t.moveTo(e, -i), d = e + Math.cos(l) * this.game.width, c = i + Math.sin(l) * this.game.height, t.lineTo(d, -c), t.moveTo(e, -i), d = e + Math.cos(l) * -this.game.width, c = i + Math.sin(l) * -this.game.height, t.lineTo(d, -c)
            },
            drawCapsule: function(t, e, i, o, s, n, r, a, h) {
                void 0 === h && (h = 1), void 0 === r && (r = 0), t.lineStyle(h, r, 1);
                var l = Math.cos(o),
                    d = Math.sin(o);
                t.beginFill(a, 1), t.drawCircle(-s / 2 * l + e, -s / 2 * d + i, 2 * -n), t.drawCircle(s / 2 * l + e, s / 2 * d + i, 2 * -n), t.endFill(), t.lineStyle(h, r, 0), t.beginFill(a, 1), t.moveTo(-s / 2 * l + n * d + e, -s / 2 * d + n * l + i), t.lineTo(s / 2 * l + n * d + e, s / 2 * d + n * l + i), t.lineTo(s / 2 * l - n * d + e, s / 2 * d - n * l + i), t.lineTo(-s / 2 * l - n * d + e, -s / 2 * d - n * l + i), t.endFill(), t.lineStyle(h, r, 1), t.moveTo(-s / 2 * l + n * d + e, -s / 2 * d + n * l + i), t.lineTo(s / 2 * l + n * d + e, s / 2 * d + n * l + i), t.moveTo(-s / 2 * l - n * d + e, -s / 2 * d - n * l + i), t.lineTo(s / 2 * l - n * d + e, s / 2 * d - n * l + i)
            },
            randomPastelHex: function() {
                var t, e, i, o;
                return i = [255, 255, 255], o = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), o = Math.floor((o + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(o, e, t)
            },
            rgbToHex: function(t, e, i) {
                return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
            },
            componentToHex: function(t) {
                var e;
                return 2 === (e = t.toString(16)).length ? e : e + "0"
            }
        }), U.Physics.P2.Spring = function(t, e, i, o, s, n, r, a, h, l) {
            this.game = t.game, void 0 === o && (o = 1), void 0 === s && (s = 100), void 0 === n && (n = 1);
            var d = {
                restLength: o = (this.world = t).pxm(o),
                stiffness: s,
                damping: n
            };
            null != r && (d.worldAnchorA = [t.pxm(r[0]), t.pxm(r[1])]), null != a && (d.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]), null != h && (d.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), null != l && (d.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, d), this.data.parent = this
        }, U.Physics.P2.Spring.prototype.constructor = U.Physics.P2.Spring, U.Physics.P2.RotationalSpring = function(t, e, i, o, s, n) {
            this.game = t.game, this.world = t, void 0 === o && (o = null), void 0 === s && (s = 100), void 0 === n && (n = 1), o && (o = t.pxm(o));
            var r = {
                restAngle: o,
                stiffness: s,
                damping: n
            };
            this.data = new p2.RotationalSpring(e, i, r), this.data.parent = this
        }, U.Physics.P2.Spring.prototype.constructor = U.Physics.P2.Spring, U.Physics.P2.Material = function(t) {
            this.name = t, p2.Material.call(this)
        }, U.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), U.Physics.P2.Material.prototype.constructor = U.Physics.P2.Material, U.Physics.P2.ContactMaterial = function(t, e, i) {
            p2.ContactMaterial.call(this, t, e, i)
        }, U.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), U.Physics.P2.ContactMaterial.prototype.constructor = U.Physics.P2.ContactMaterial, U.Physics.P2.CollisionGroup = function(t) {
            this.mask = t
        }, U.Physics.P2.DistanceConstraint = function(t, e, i, o, s, n, r) {
            void 0 === o && (o = 100), void 0 === s && (s = [0, 0]), void 0 === n && (n = [0, 0]), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game;
            var a = {
                distance: o = (this.world = t).pxm(o),
                localAnchorA: s = [t.pxmi(s[0]), t.pxmi(s[1])],
                localAnchorB: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                maxForce: r
            };
            p2.DistanceConstraint.call(this, e, i, a)
        }, U.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), U.Physics.P2.DistanceConstraint.prototype.constructor = U.Physics.P2.DistanceConstraint, U.Physics.P2.GearConstraint = function(t, e, i, o, s) {
            void 0 === o && (o = 0), void 0 === s && (s = 1), this.game = t.game, this.world = t;
            var n = {
                angle: o,
                ratio: s
            };
            p2.GearConstraint.call(this, e, i, n)
        }, U.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), U.Physics.P2.GearConstraint.prototype.constructor = U.Physics.P2.GearConstraint, U.Physics.P2.LockConstraint = function(t, e, i, o, s, n) {
            void 0 === o && (o = [0, 0]), void 0 === s && (s = 0), void 0 === n && (n = Number.MAX_VALUE), this.game = t.game;
            var r = {
                localOffsetB: o = [(this.world = t).pxm(o[0]), t.pxm(o[1])],
                localAngleB: s,
                maxForce: n
            };
            p2.LockConstraint.call(this, e, i, r)
        }, U.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), U.Physics.P2.LockConstraint.prototype.constructor = U.Physics.P2.LockConstraint, U.Physics.P2.PrismaticConstraint = function(t, e, i, o, s, n, r, a) {
            void 0 === o && (o = !0), void 0 === s && (s = [0, 0]), void 0 === n && (n = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game;
            var h = {
                localAnchorA: s = [(this.world = t).pxmi(s[0]), t.pxmi(s[1])],
                localAnchorB: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                localAxisA: r,
                maxForce: a,
                disableRotationalLock: !o
            };
            p2.PrismaticConstraint.call(this, e, i, h)
        }, U.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), U.Physics.P2.PrismaticConstraint.prototype.constructor = U.Physics.P2.PrismaticConstraint, U.Physics.P2.RevoluteConstraint = function(t, e, i, o, s, n, r) {
            void 0 === n && (n = Number.MAX_VALUE), void 0 === r && (r = null), this.game = t.game, i = [(this.world = t).pxmi(i[0]), t.pxmi(i[1])], s = [t.pxmi(s[0]), t.pxmi(s[1])], r && (r = [t.pxmi(r[0]), t.pxmi(r[1])]);
            var a = {
                worldPivot: r,
                localPivotA: i,
                localPivotB: s,
                maxForce: n
            };
            p2.RevoluteConstraint.call(this, e, o, a)
        }, U.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), U.Physics.P2.RevoluteConstraint.prototype.constructor = U.Physics.P2.RevoluteConstraint, U.ImageCollection = function(t, e, i, o, s, n, r) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === s && (s = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | o, this.imageMargin = 0 | s, this.imageSpacing = 0 | n, this.properties = r || {}, this.images = [], this.total = 0
        }, U.ImageCollection.prototype = {
            containsImageIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            addImage: function(t, e) {
                this.images.push({
                    gid: t,
                    image: e
                }), this.total++
            }
        }, U.ImageCollection.prototype.constructor = U.ImageCollection, U.Tile = function(t, e, i, o, s, n) {
            this.layer = t, this.index = e, this.x = i, this.y = o, this.rotation = 0, this.flipped = !1, this.worldX = i * s, this.worldY = o * n, this.width = s, this.height = n, this.centerX = Math.abs(s / 2), this.centerY = Math.abs(n / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
        }, U.Tile.prototype = {
            containsPoint: function(t, e) {
                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
            },
            intersects: function(t, e, i, o) {
                return !(i <= this.worldX) && (!(o <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
            },
            setCollisionCallback: function(t, e) {
                this.collisionCallback = t, this.collisionCallbackContext = e
            },
            destroy: function() {
                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
            },
            setCollision: function(t, e, i, o) {
                this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = o, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = o
            },
            resetCollision: function() {
                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
            },
            isInteresting: function(t, e) {
                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(t) {
                this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
            }
        }, U.Tile.prototype.constructor = U.Tile, Object.defineProperty(U.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }), Object.defineProperty(U.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }), Object.defineProperty(U.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }), Object.defineProperty(U.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }), Object.defineProperty(U.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }), Object.defineProperty(U.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }), U.Tilemap = function(t, e, i, o, s, n) {
            this.game = t, this.key = e;
            var r = U.TilemapParser.parse(this.game, e, i, o, s, n);
            null !== r && (this.width = r.width, this.height = r.height, this.tileWidth = r.tileWidth, this.tileHeight = r.tileHeight, this.orientation = r.orientation, this.format = r.format, this.version = r.version, this.properties = r.properties, this.widthInPixels = r.widthInPixels, this.heightInPixels = r.heightInPixels, this.layers = r.layers, this.tilesets = r.tilesets, this.imagecollections = r.imagecollections, this.tiles = r.tiles, this.objects = r.objects, this.collideIndexes = [], this.collision = r.collision, this.images = r.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, U.Tilemap.CSV = 0, U.Tilemap.TILED_JSON = 1, U.Tilemap.NORTH = 0, U.Tilemap.EAST = 1, U.Tilemap.SOUTH = 2, U.Tilemap.WEST = 3, U.Tilemap.prototype = {
            create: function(t, e, i, o, s, n) {
                return void 0 === n && (n = this.game.world), this.width = e, this.height = i, this.setTileSize(o, s), this.layers.length = 0, this.createBlankLayer(t, e, i, o, s, n)
            },
            setTileSize: function(t, e) {
                this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
            },
            addTilesetImage: function(t, e, i, o, s, n, r) {
                if (void 0 === t) return null;
                void 0 === i && (i = this.tileWidth), void 0 === o && (o = this.tileHeight), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), 0 === i && (i = 32), 0 === o && (o = 32);
                var a = null;
                if (null == e && (e = t), e instanceof U.BitmapData) a = e.canvas;
                else {
                    if (!this.game.cache.checkImageKey(e)) return null;
                    a = this.game.cache.getImage(e)
                }
                var h = this.getTilesetIndex(t);
                if (null === h && this.format === U.Tilemap.TILED_JSON) return null;
                if (this.tilesets[h]) return this.tilesets[h].setImage(a), this.tilesets[h];
                var l = new U.Tileset(t, r, i, o, s, n, {});
                l.setImage(a), this.tilesets.push(l);
                for (var d = this.tilesets.length - 1, c = s, u = s, p = 0, b = 0, m = 0, y = r; y < r + l.total && (this.tiles[y] = [c, u, d], c += i + n, ++p !== l.total) && (++b !== l.columns || (c = s, u += o + n, b = 0, ++m !== l.rows)); y++);
                return l
            },
            createFromObjects: function(t, e, i, o, s, n, r, a, h) {
                if (void 0 === s && (s = !0), void 0 === n && (n = !1), void 0 === r && (r = this.game.world), void 0 === a && (a = U.Sprite), void 0 === h && (h = !0), this.objects[t])
                    for (var l = 0; l < this.objects[t].length; l++) {
                        var d = !1,
                            c = this.objects[t][l];
                        if (void 0 !== c.gid && "number" == typeof e && c.gid === e ? d = !0 : void 0 !== c.id && "number" == typeof e && c.id === e ? d = !0 : void 0 !== c.name && "string" == typeof e && c.name === e && (d = !0), d) {
                            var u = new a(this.game, parseFloat(c.x, 10), parseFloat(c.y, 10), i, o);
                            for (var p in u.name = c.name, u.visible = c.visible, u.autoCull = n, u.exists = s, c.width && (u.width = c.width), c.height && (u.height = c.height), c.rotation && (u.angle = c.rotation), h && (u.y -= u.height), r.add(u), c.properties) r.set(u, p, c.properties[p], !1, !1, 0, !0)
                        }
                    }
            },
            createFromTiles: function(t, e, i, o, s, n) {
                "number" == typeof t && (t = [t]), null == e ? e = [] : "number" == typeof e && (e = [e]), o = this.getLayer(o), void 0 === s && (s = this.game.world), void 0 === n && (n = {}), void 0 === n.customClass && (n.customClass = U.Sprite), void 0 === n.adjustY && (n.adjustY = !0);
                var r = this.layers[o].width,
                    a = this.layers[o].height;
                if (this.copy(0, 0, r, a, o), this._results.length < 2) return 0;
                for (var h, l = 0, d = 1, c = this._results.length; d < c; d++)
                    if (-1 !== t.indexOf(this._results[d].index)) {
                        for (var u in h = new n.customClass(this.game, this._results[d].worldX, this._results[d].worldY, i), n) h[u] = n[u];
                        s.add(h), l++
                    }
                if (1 === e.length)
                    for (d = 0; d < t.length; d++) this.replace(t[d], e[0], 0, 0, r, a, o);
                else if (1 < e.length)
                    for (d = 0; d < t.length; d++) this.replace(t[d], e[d], 0, 0, r, a, o);
                return l
            },
            createLayer: function(t, e, i, o) {
                void 0 === e && (e = this.game.width), void 0 === i && (i = this.game.height), void 0 === o && (o = this.game.world);
                var s = t;
                if ("string" == typeof t && (s = this.getLayerIndex(t)), !(null === s || s > this.layers.length)) {
                    void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[s].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === i || i <= 0 ? i = Math.min(this.game.height, this.layers[s].heightInPixels) : i > this.game.height && (i = this.game.height), this.enableDebug;
                    var n = o.add(new U.TilemapLayer(this.game, this, s, e, i));
                    return this.enableDebug, n
                }
            },
            createBlankLayer: function(t, e, i, o, s, n) {
                if (void 0 === n && (n = this.game.world), null === this.getLayerIndex(t)) {
                    for (var r, a = {
                            name: t,
                            x: 0,
                            y: 0,
                            width: e,
                            height: i,
                            widthInPixels: e * o,
                            heightInPixels: i * s,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: null
                        }, h = [], l = 0; l < i; l++) {
                        r = [];
                        for (var d = 0; d < e; d++) r.push(new U.Tile(a, -1, d, l, o, s));
                        h.push(r)
                    }
                    a.data = h, this.layers.push(a), this.currentLayer = this.layers.length - 1;
                    var c = a.widthInPixels,
                        u = a.heightInPixels;
                    return c > this.game.width && (c = this.game.width), u > this.game.height && (u = this.game.height), (h = new U.TilemapLayer(this.game, this, this.layers.length - 1, c, u)).name = t, n.add(h)
                }
            },
            getIndex: function(t, e) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].name === e) return i;
                return null
            },
            getLayerIndex: function(t) {
                return this.getIndex(this.layers, t)
            },
            getTilesetIndex: function(t) {
                return this.getIndex(this.tilesets, t)
            },
            getImageIndex: function(t) {
                return this.getIndex(this.images, t)
            },
            setTileIndexCallback: function(t, e, i, o) {
                if (o = this.getLayer(o), "number" == typeof t) this.layers[o].callbacks[t] = {
                    callback: e,
                    callbackContext: i
                };
                else
                    for (var s = 0, n = t.length; s < n; s++) this.layers[o].callbacks[t[s]] = {
                        callback: e,
                        callbackContext: i
                    }
            },
            setTileLocationCallback: function(t, e, i, o, s, n, r) {
                if (r = this.getLayer(r), this.copy(t, e, i, o, r), !(this._results.length < 2))
                    for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(s, n)
            },
            setCollision: function(t, e, i, o) {
                if (void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                if (Array.isArray(t)) {
                    for (var s = 0; s < t.length; s++) this.setCollisionByIndex(t[s], e, i, !1);
                    o && this.calculateFaces(i)
                }
            },
            setCollisionBetween: function(t, e, i, o, s) {
                if (void 0 === i && (i = !0), void 0 === s && (s = !0), o = this.getLayer(o), !(e < t)) {
                    for (var n = t; n <= e; n++) this.setCollisionByIndex(n, i, o, !1);
                    s && this.calculateFaces(o)
                }
            },
            setCollisionByExclusion: function(t, e, i, o) {
                void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i);
                for (var s = 0, n = this.tiles.length; s < n; s++) - 1 === t.indexOf(s) && this.setCollisionByIndex(s, e, i, !1);
                o && this.calculateFaces(i)
            },
            setCollisionByIndex: function(t, e, i, o) {
                if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === o && (o = !0), e) this.collideIndexes.push(t);
                else {
                    var s = this.collideIndexes.indexOf(t); - 1 < s && this.collideIndexes.splice(s, 1)
                }
                for (var n = 0; n < this.layers[i].height; n++)
                    for (var r = 0; r < this.layers[i].width; r++) {
                        var a = this.layers[i].data[n][r];
                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
                    }
                return o && this.calculateFaces(i), i
            },
            getLayer: function(t) {
                return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof U.TilemapLayer && (t = t.index), t
            },
            setPreventRecalculate: function(t) {
                if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                    for (var e in this.preventingRecalculate = !1, this.needToRecalculate) this.calculateFaces(e);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(t) {
                if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, o = null, s = null, n = 0, r = this.layers[t].height; n < r; n++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) {
                            var l = this.layers[t].data[n][a];
                            l && (e = this.getTileAbove(t, a, n), i = this.getTileBelow(t, a, n), o = this.getTileLeft(t, a, n), s = this.getTileRight(t, a, n), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), o && o.collides && (l.faceLeft = !1), s && s.collides && (l.faceRight = !1))
                        }
            },
            getTileAbove: function(t, e, i) {
                return 0 < i ? this.layers[t].data[i - 1][e] : null
            },
            getTileBelow: function(t, e, i) {
                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
            },
            getTileLeft: function(t, e, i) {
                return 0 < e ? this.layers[t].data[i][e - 1] : null
            },
            getTileRight: function(t, e, i) {
                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
            },
            setLayer: function(t) {
                t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
            },
            hasTile: function(t, e, i) {
                return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && -1 < this.layers[i].data[e][t].index
            },
            removeTile: function(t, e, i) {
                if (i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height && this.hasTile(t, e, i)) {
                    var o = this.layers[i].data[e][t];
                    return this.layers[i].data[e][t] = new U.Tile(this.layers[i], -1, t, e, this.tileWidth, this.tileHeight), this.layers[i].dirty = !0, this.calculateFaces(i), o
                }
            },
            removeTileWorldXY: function(t, e, i, o, s) {
                return s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.removeTile(t, e, s)
            },
            putTile: function(t, e, i, o) {
                return null === t ? this.removeTile(e, i, o) : (o = this.getLayer(o), 0 <= e && e < this.layers[o].width && 0 <= i && i < this.layers[o].height ? (t instanceof U.Tile ? (s = t.index, this.hasTile(e, i, o) ? this.layers[o].data[i][e].copy(t) : this.layers[o].data[i][e] = new U.Tile(o, s, e, i, t.width, t.height)) : (s = t, this.hasTile(e, i, o) ? this.layers[o].data[i][e].index = s : this.layers[o].data[i][e] = new U.Tile(this.layers[o], s, e, i, this.tileWidth, this.tileHeight)), -1 < this.collideIndexes.indexOf(s) ? this.layers[o].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[o].data[i][e].resetCollision(), this.layers[o].dirty = !0, this.calculateFaces(o), this.layers[o].data[i][e]) : null);
                var s
            },
            putTileWorldXY: function(t, e, i, o, s, n) {
                return n = this.getLayer(n), e = this.game.math.snapToFloor(e, o) / o, i = this.game.math.snapToFloor(i, s) / s, this.putTile(t, e, i, n)
            },
            searchTileIndex: function(t, e, i, o) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), o = this.getLayer(o);
                var s = 0;
                if (i) {
                    for (var n = this.layers[o].height - 1; 0 <= n; n--)
                        for (var r = this.layers[o].width - 1; 0 <= r; r--)
                            if (this.layers[o].data[n][r].index === t) {
                                if (s === e) return this.layers[o].data[n][r];
                                s++
                            }
                } else
                    for (n = 0; n < this.layers[o].height; n++)
                        for (r = 0; r < this.layers[o].width; r++)
                            if (this.layers[o].data[n][r].index === t) {
                                if (s === e) return this.layers[o].data[n][r];
                                s++
                            } return null
            },
            getTile: function(t, e, i, o) {
                return void 0 === o && (o = !1), i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? o ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
            },
            getTileWorldXY: function(t, e, i, o, s, n) {
                return void 0 === i && (i = this.tileWidth), void 0 === o && (o = this.tileHeight), s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.getTile(t, e, s, n)
            },
            copy: function(t, e, i, o, s) {
                if (s = this.getLayer(s), this.layers[s]) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[s].width), void 0 === o && (o = this.layers[s].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[s].width && (i = this.layers[s].width), o > this.layers[s].height && (o = this.layers[s].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: o,
                        layer: s
                    });
                    for (var n = e; n < e + o; n++)
                        for (var r = t; r < t + i; r++) this._results.push(this.layers[s].data[n][r]);
                    return this._results
                }
                this._results.length = 0
            },
            paste: function(t, e, i, o) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 0), o = this.getLayer(o), i && !(i.length < 2)) {
                    for (var s = t - i[1].x, n = e - i[1].y, r = 1; r < i.length; r++) this.layers[o].data[n + i[r].y][s + i[r].x].copy(i[r]);
                    this.layers[o].dirty = !0, this.calculateFaces(o)
                }
            },
            swap: function(t, e, i, o, s, n, r) {
                r = this.getLayer(r), this.copy(i, o, s, n, r), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, o, this._results, r))
            },
            swapHandler: function(t) {
                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
            },
            forEach: function(t, e, i, o, s, n, r) {
                r = this.getLayer(r), this.copy(i, o, s, n, r), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, o, this._results, r))
            },
            replace: function(t, e, i, o, s, n, r) {
                if (r = this.getLayer(r), this.copy(i, o, s, n, r), !(this._results.length < 2)) {
                    for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                    this.paste(i, o, this._results, r)
                }
            },
            random: function(t, e, i, o, s) {
                if (s = this.getLayer(s), this.copy(t, e, i, o, s), !(this._results.length < 2)) {
                    for (var n = [], r = 1; r < this._results.length; r++)
                        if (this._results[r].index) {
                            var a = this._results[r].index; - 1 === n.indexOf(a) && n.push(a)
                        }
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(n);
                    this.paste(t, e, this._results, s)
                }
            },
            shuffle: function(t, e, i, o, s) {
                if (s = this.getLayer(s), this.copy(t, e, i, o, s), !(this._results.length < 2)) {
                    for (var n = [], r = 1; r < this._results.length; r++) this._results[r].index && n.push(this._results[r].index);
                    U.ArrayUtils.shuffle(n);
                    for (var a = 1; a < this._results.length; a++) this._results[a].index = n[a - 1];
                    this.paste(t, e, this._results, s)
                }
            },
            fill: function(t, e, i, o, s, n) {
                if (n = this.getLayer(n), this.copy(e, i, o, s, n), !(this._results.length < 2)) {
                    for (var r = 1; r < this._results.length; r++) this._results[r].index = t;
                    this.paste(e, i, this._results, n)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0, this.currentLayer = 0
            },
            dump: function() {
                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                    for (var o = 0; o < this.layers[this.currentLayer].width; o++) t += "%c  ", 1 < this.layers[this.currentLayer].data[i][o] ? this.debugMap[this.layers[this.currentLayer].data[i][o]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][o]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n"
                }
                e[0] = t
            },
            destroy: function() {
                this.removeAllLayers(), this.data = [], this.game = null
            }
        }, U.Tilemap.prototype.constructor = U.Tilemap, Object.defineProperty(U.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(t) {
                t !== this.currentLayer && this.setLayer(t)
            }
        }), U.TilemapLayer = function(t, e, i, o, s) {
            o |= 0, s |= 0, U.Sprite.call(this, t, 0, 0), this.map = e, this.index = i, this.layer = e.layers[i], this.canvas = PIXI.CanvasPool.create(this, o, s), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = U.TILEMAPLAYER, this.physicsType = U.TILEMAPLAYER, this.renderSettings = {
                enableScrollDelta: !1,
                overdrawRatio: .2,
                copyCanvas: null
            }, this.debug = !1, this.exists = !0, this.debugSettings = {
                missingImageFill: "rgb(255,255,255)",
                debuggedTileOverfill: "rgba(0,255,0,0.4)",
                forceFullRedraw: !0,
                debugAlpha: .5,
                facingEdgeStroke: "rgba(0,255,0,1)",
                collidingTileOverfill: "rgba(0,255,0,0.2)"
            }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                scrollX: 0,
                scrollY: 0,
                renderWidth: 0,
                renderHeight: 0,
                tileWidth: e.tileWidth,
                tileHeight: e.tileHeight,
                cw: e.tileWidth,
                ch: e.tileHeight,
                tilesets: []
            }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = U.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
        }, U.TilemapLayer.prototype = Object.create(U.Sprite.prototype), U.TilemapLayer.prototype.constructor = U.TilemapLayer, U.TilemapLayer.prototype.preUpdateCore = U.Component.Core.preUpdate, U.TilemapLayer.sharedCopyCanvas = null, U.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
        }, U.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }, U.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
        }, U.TilemapLayer.prototype._renderCanvas = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, U.TilemapLayer.prototype._renderWebGL = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, U.TilemapLayer.prototype.destroy = function() {
            PIXI.CanvasPool.remove(this), U.Component.Destroy.prototype.destroy.call(this)
        }, U.TilemapLayer.prototype.resize = function(t, e) {
            this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
        }, U.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }, U.TilemapLayer.prototype._fixX = function(t) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
        }, U.TilemapLayer.prototype._unfixX = function(t) {
            return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
        }, U.TilemapLayer.prototype._fixY = function(t) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
        }, U.TilemapLayer.prototype._unfixY = function(t) {
            return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
        }, U.TilemapLayer.prototype.getTileX = function(t) {
            return Math.floor(this._fixX(t) / this._mc.tileWidth)
        }, U.TilemapLayer.prototype.getTileY = function(t) {
            return Math.floor(this._fixY(t) / this._mc.tileHeight)
        }, U.TilemapLayer.prototype.getTileXY = function(t, e, i) {
            return i.x = this.getTileX(t), i.y = this.getTileY(e), i
        }, U.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, o) {
            e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === o && (o = !1);
            var s = this.getTiles(t.x, t.y, t.width, t.height, i, o);
            if (0 === s.length) return [];
            for (var n = t.coordinatesOnLine(e), r = [], a = 0; a < s.length; a++)
                for (var h = 0; h < n.length; h++) {
                    var l = s[a],
                        d = n[h];
                    if (l.containsPoint(d[0], d[1])) {
                        r.push(l);
                        break
                    }
                }
            return r
        }, U.TilemapLayer.prototype.getTiles = function(t, e, i, o, s, n) {
            void 0 === s && (s = !1), void 0 === n && (n = !1);
            var r = !(s || n);
            t = this._fixX(t), e = this._fixY(e);
            for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, d = Math.ceil((e + o) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
            for (var c = h; c < h + d; c++)
                for (var u = a; u < a + l; u++) {
                    var p = this.layer.data[c];
                    p && p[u] && (r || p[u].isInteresting(s, n)) && this._results.push(p[u])
                }
            return this._results.slice()
        }, U.TilemapLayer.prototype.resolveTileset = function(t) {
            var e = this._mc.tilesets;
            if (t < 2e3)
                for (; e.length < t;) e.push(void 0);
            var i = this.map.tiles[t] && this.map.tiles[t][2];
            if (null !== i) {
                var o = this.map.tilesets[i];
                if (o && o.containsTileIndex(t)) return e[t] = o
            }
            return e[t] = null
        }, U.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var t = this._mc.tilesets; t.length;) t.pop()
        }, U.TilemapLayer.prototype.setScale = function(t, e) {
            t = t || 1, e = e || t;
            for (var i = 0; i < this.layer.data.length; i++)
                for (var o = this.layer.data[i], s = 0; s < o.length; s++) {
                    var n = o[s];
                    n.width = this.map.tileWidth * t, n.height = this.map.tileHeight * e, n.worldX = n.x * n.width, n.worldY = n.y * n.height
                }
            this.scale.setTo(t, e)
        }, U.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
            var o = t.canvas,
                s = o.width - Math.abs(e),
                n = o.height - Math.abs(i),
                r = 0,
                a = 0,
                h = e,
                l = i;
            e < 0 && (r = -e, h = 0), i < 0 && (a = -i, l = 0);
            var d = this.renderSettings.copyCanvas;
            if (d) {
                (d.width < s || d.height < n) && (d.width = s, d.height = n);
                var c = d.getContext("2d");
                c.clearRect(0, 0, s, n), c.drawImage(o, r, a, s, n, 0, 0, s, n), t.clearRect(h, l, s, n), t.drawImage(d, 0, 0, s, n, h, l, s, n)
            } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(o, r, a, s, n, h, l, s, n), t.restore()
        }, U.TilemapLayer.prototype.renderRegion = function(t, e, i, o, s, n) {
            var r = this.context,
                a = this.layer.width,
                h = this.layer.height,
                l = this._mc.tileWidth,
                d = this._mc.tileHeight,
                c = this._mc.tilesets,
                u = NaN;
            this._wrap || (i <= s && (i = Math.max(0, i), s = Math.min(a - 1, s)), o <= n && (o = Math.max(0, o), n = Math.min(h - 1, n)));
            var p, b, m, y, f, x, g = i * l - t,
                _ = (i + (1 << 20) * a) % a;
            for (y = (o + (1 << 20) * h) % h, x = n - o, b = o * d - e; 0 <= x; y++, x--, b += d) {
                h <= y && (y -= h);
                var v = this.layer.data[y];
                for (m = _, f = s - i, p = g; 0 <= f; m++, f--, p += l) {
                    a <= m && (m -= a);
                    var S = v[m];
                    if (S && !(S.index < 0)) {
                        var C = S.index,
                            w = c[C];
                        void 0 === w && (w = this.resolveTileset(C)), S.alpha === u || this.debug || (r.globalAlpha = S.alpha, u = S.alpha), w ? S.rotation || S.flipped ? (r.save(), r.translate(p + S.centerX, b + S.centerY), r.rotate(S.rotation), S.flipped && r.scale(-1, 1), w.draw(r, -S.centerX, -S.centerY, C), r.restore()) : w.draw(r, p, b, C) : this.debugSettings.missingImageFill && (r.fillStyle = this.debugSettings.missingImageFill, r.fillRect(p, b, l, d)), S.debug && this.debugSettings.debuggedTileOverfill && (r.fillStyle = this.debugSettings.debuggedTileOverfill, r.fillRect(p, b, l, d))
                    }
                }
            }
        }, U.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
            var i = this._mc.scrollX,
                o = this._mc.scrollY,
                s = this.canvas.width,
                n = this.canvas.height,
                r = this._mc.tileWidth,
                a = this._mc.tileHeight,
                h = 0,
                l = -r,
                d = 0,
                c = -a;
            if (t < 0 ? (h = s + t, l = s - 1) : 0 < t && (l = t), e < 0 ? (d = n + e, c = n - 1) : 0 < e && (c = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / r), l = Math.floor((l + i) / r), d = Math.floor((d + o) / a), c = Math.floor((c + o) / a), h <= l) {
                this.context.clearRect(h * r - i, 0, (l - h + 1) * r, n);
                var u = Math.floor((0 + o) / a),
                    p = Math.floor((n - 1 + o) / a);
                this.renderRegion(i, o, h, u, l, p)
            }
            if (d <= c) {
                this.context.clearRect(0, d * a - o, s, (c - d + 1) * a);
                var b = Math.floor((0 + i) / r),
                    m = Math.floor((s - 1 + i) / r);
                this.renderRegion(i, o, b, d, m, c)
            }
        }, U.TilemapLayer.prototype.renderFull = function() {
            var t = this._mc.scrollX,
                e = this._mc.scrollY,
                i = this.canvas.width,
                o = this.canvas.height,
                s = this._mc.tileWidth,
                n = this._mc.tileHeight,
                r = Math.floor(t / s),
                a = Math.floor((i - 1 + t) / s),
                h = Math.floor(e / n),
                l = Math.floor((o - 1 + e) / n);
            this.context.clearRect(0, 0, i, o), this.renderRegion(t, e, r, h, a, l)
        }, U.TilemapLayer.prototype.render = function() {
            var t = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (t = !(this.layer.dirty = !1));
                var e = this.canvas.width,
                    i = this.canvas.height,
                    o = 0 | this._scrollX,
                    s = 0 | this._scrollY,
                    n = this._mc,
                    r = n.scrollX - o,
                    a = n.scrollY - s;
                if (t || 0 !== r || 0 !== a || n.renderWidth !== e || n.renderHeight !== i) return this.context.save(), n.scrollX = o, n.scrollY = s, n.renderWidth === e && n.renderHeight === i || (n.renderWidth = e, n.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(r) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(r, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, U.TilemapLayer.prototype.renderDebug = function() {
            var t, e, i, o, s, n, r = this._mc.scrollX,
                a = this._mc.scrollY,
                h = this.context,
                l = this.canvas.width,
                d = this.canvas.height,
                c = this.layer.width,
                u = this.layer.height,
                p = this._mc.tileWidth,
                b = this._mc.tileHeight,
                m = Math.floor(r / p),
                y = Math.floor((l - 1 + r) / p),
                f = Math.floor(a / b),
                x = Math.floor((d - 1 + a) / b),
                g = m * p - r,
                _ = f * b - a,
                v = (m + (1 << 20) * c) % c,
                S = (f + (1 << 20) * u) % u;
            for (h.strokeStyle = this.debugSettings.facingEdgeStroke, o = S, n = x - f, e = _; 0 <= n; o++, n--, e += b) {
                u <= o && (o -= u);
                var C = this.layer.data[o];
                for (i = v, s = y - m, t = g; 0 <= s; i++, s--, t += p) {
                    c <= i && (i -= c);
                    var w = C[i];
                    !w || w.index < 0 || !w.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), w.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), w.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), w.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), w.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
                }
            }
        }, Object.defineProperty(U.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(t) {
                this._wrap = t, this.dirty = !0
            }
        }), Object.defineProperty(U.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(t) {
                this._scrollX = t
            }
        }), Object.defineProperty(U.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(t) {
                this._scrollY = t
            }
        }), Object.defineProperty(U.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(t) {
                this._mc.cw = 0 | t, this.dirty = !0
            }
        }), Object.defineProperty(U.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(t) {
                this._mc.ch = 0 | t, this.dirty = !0
            }
        }), U.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(t, e, i, o, s, n) {
                if (void 0 === i && (i = 32), void 0 === o && (o = 32), void 0 === s && (s = 10), void 0 === n && (n = 10), void 0 === e) return this.getEmptyData();
                if (null === e) return this.getEmptyData(i, o, s, n);
                var r = t.cache.getTilemapData(e);
                if (r) {
                    if (r.format === U.Tilemap.CSV) return this.parseCSV(e, r.data, i, o);
                    if (!r.format || r.format === U.Tilemap.TILED_JSON) return this.parseTiledJSON(r.data)
                }
            },
            parseCSV: function(t, e, i, o) {
                for (var s = this.getEmptyData(), n = [], r = (e = e.trim()).split("\n"), a = r.length, h = 0, l = 0; l < r.length; l++) {
                    n[l] = [];
                    for (var d = r[l].split(","), c = 0; c < d.length; c++) n[l][c] = new U.Tile(s.layers[0], parseInt(d[c], 10), c, l, i, o);
                    0 === h && (h = d.length)
                }
                return s.format = U.Tilemap.CSV, s.name = t, s.width = h, s.height = a, s.tileWidth = i, s.tileHeight = o, s.widthInPixels = h * i, s.heightInPixels = a * o, s.layers[0].width = h, s.layers[0].height = a, s.layers[0].widthInPixels = s.widthInPixels, s.layers[0].heightInPixels = s.heightInPixels, s.layers[0].data = n, s
            },
            getEmptyData: function(t, e, i, o) {
                return {
                    width: null != i ? i : 0,
                    height: null != o ? o : 0,
                    tileWidth: null != t ? t : 0,
                    tileHeight: null != e ? e : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            parseTiledJSON: function(t) {
                if ("orthogonal" !== t.orientation) return null;
                for (var e = {
                        width: t.width,
                        height: t.height,
                        tileWidth: t.tilewidth,
                        tileHeight: t.tileheight,
                        orientation: t.orientation,
                        format: U.Tilemap.TILED_JSON,
                        version: t.version,
                        properties: t.properties,
                        widthInPixels: t.width * t.tilewidth,
                        heightInPixels: t.height * t.tileheight
                    }, i = [], o = 0; o < t.layers.length; o++)
                    if ("tilelayer" === t.layers[o].type) {
                        var s = t.layers[o];
                        if (!s.compression && s.encoding && "base64" === s.encoding) {
                            for (var n = window.atob(s.data), r = n.length, a = new Array(r), h = 0; h < r; h += 4) a[h / 4] = (n.charCodeAt(h) | n.charCodeAt(h + 1) << 8 | n.charCodeAt(h + 2) << 16 | n.charCodeAt(h + 3) << 24) >>> 0;
                            s.data = a, delete s.encoding
                        } else if (s.compression) continue;
                        var l = {
                            name: s.name,
                            x: s.x,
                            y: s.y,
                            width: s.width,
                            height: s.height,
                            widthInPixels: s.width * t.tilewidth,
                            heightInPixels: s.height * t.tileheight,
                            alpha: s.opacity,
                            visible: s.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        };
                        s.properties && (l.properties = s.properties);
                        var d, c, u, p = 0,
                            b = [],
                            m = [],
                            y = 0;
                        for (r = s.data.length; y < r; y++) {
                            if (c = !1, u = d = 0, 536870912 < (P = s.data[y])) switch (2147483648 < P && (P -= 2147483648, u += 4), 1073741824 < P && (P -= 1073741824, u += 2), 536870912 < P && (P -= 536870912, u += 1), u) {
                                case 5:
                                    d = Math.PI / 2;
                                    break;
                                case 6:
                                    d = Math.PI;
                                    break;
                                case 3:
                                    d = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    c = !(d = 0);
                                    break;
                                case 7:
                                    d = Math.PI / 2, c = !0;
                                    break;
                                case 2:
                                    d = Math.PI, c = !0;
                                    break;
                                case 1:
                                    d = 3 * Math.PI / 2, c = !0
                            }
                            if (0 < P)(T = new U.Tile(l, P, p, m.length, t.tilewidth, t.tileheight)).rotation = d, T.flipped = c, 0 !== u && (T.flippedVal = u), b.push(T);
                            else U.TilemapParser.INSERT_NULL ? b.push(null) : b.push(new U.Tile(l, -1, p, m.length, t.tilewidth, t.tileheight));
                            ++p === s.width && (m.push(b), p = 0, b = [])
                        }
                        l.data = m, i.push(l)
                    }
                e.layers = i;
                var f = [];
                for (o = 0; o < t.layers.length; o++)
                    if ("imagelayer" === t.layers[o].type) {
                        var x = t.layers[o],
                            g = {
                                name: x.name,
                                image: x.image,
                                x: x.x,
                                y: x.y,
                                alpha: x.opacity,
                                visible: x.visible,
                                properties: {}
                            };
                        x.properties && (g.properties = x.properties), f.push(g)
                    }
                e.images = f;
                var _ = [],
                    v = [],
                    S = null;
                for (o = 0; o < t.tilesets.length; o++) {
                    if ((F = t.tilesets[o]).image) {
                        var C = new U.Tileset(F.name, F.firstgid, F.tilewidth, F.tileheight, F.margin, F.spacing, F.properties);
                        F.tileproperties && (C.tileProperties = F.tileproperties), C.updateTileData(F.imagewidth, F.imageheight), _.push(C)
                    } else {
                        var w = new U.ImageCollection(F.name, F.firstgid, F.tilewidth, F.tileheight, F.margin, F.spacing, F.properties);
                        for (var A in F.tiles) {
                            g = F.tiles[A].image;
                            var P = F.firstgid + parseInt(A, 10);
                            w.addImage(P, g)
                        }
                        v.push(w)
                    }
                    S && (S.lastgid = F.firstgid - 1), S = F
                }
                e.tilesets = _, e.imagecollections = v;
                var T, B, M = {},
                    E = {};

                function I(t, e) {
                    var i = {};
                    for (var o in e) {
                        var s = e[o];
                        void 0 !== t[s] && (i[s] = t[s])
                    }
                    return i
                }
                for (o = 0; o < t.layers.length; o++)
                    if ("objectgroup" === t.layers[o].type) {
                        var V = t.layers[o];
                        M[V.name] = [], E[V.name] = [];
                        var R = 0;
                        for (r = V.objects.length; R < r; R++)
                            if (V.objects[R].gid) {
                                var L = {
                                    gid: V.objects[R].gid,
                                    name: V.objects[R].name,
                                    type: V.objects[R].hasOwnProperty("type") ? V.objects[R].type : "",
                                    x: V.objects[R].x,
                                    y: V.objects[R].y,
                                    visible: V.objects[R].visible,
                                    properties: V.objects[R].properties
                                };
                                V.objects[R].rotation && (L.rotation = V.objects[R].rotation), M[V.name].push(L)
                            } else if (V.objects[R].polyline) {
                            L = {
                                name: V.objects[R].name,
                                type: V.objects[R].type,
                                x: V.objects[R].x,
                                y: V.objects[R].y,
                                width: V.objects[R].width,
                                height: V.objects[R].height,
                                visible: V.objects[R].visible,
                                properties: V.objects[R].properties
                            };
                            V.objects[R].rotation && (L.rotation = V.objects[R].rotation), L.polyline = [];
                            for (var D = 0; D < V.objects[R].polyline.length; D++) L.polyline.push([V.objects[R].polyline[D].x, V.objects[R].polyline[D].y]);
                            E[V.name].push(L), M[V.name].push(L)
                        } else if (V.objects[R].polygon) {
                            (L = I(V.objects[R], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                            for (D = 0; D < V.objects[R].polygon.length; D++) L.polygon.push([V.objects[R].polygon[D].x, V.objects[R].polygon[D].y]);
                            M[V.name].push(L)
                        } else if (V.objects[R].ellipse) {
                            L = I(V.objects[R], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            M[V.name].push(L)
                        } else {
                            (L = I(V.objects[R], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, M[V.name].push(L)
                        }
                    }
                e.objects = M, e.collision = E, e.tiles = [];
                for (o = 0; o < e.tilesets.length; o++) {
                    p = (F = e.tilesets[o]).tileMargin;
                    var F, k = F.tileMargin,
                        G = 0,
                        O = 0,
                        N = 0;
                    for (y = F.firstgid; y < F.firstgid + F.total && (e.tiles[y] = [p, k, o], p += F.tileWidth + F.tileSpacing, ++G !== F.total) && (++O !== F.columns || (p = F.tileMargin, k += F.tileHeight + F.tileSpacing, O = 0, ++N !== F.rows)); y++);
                }
                for (o = 0; o < e.layers.length; o++) {
                    l = e.layers[o], F = null;
                    for (h = 0; h < l.data.length; h++) {
                        b = l.data[h];
                        for (var J = 0; J < b.length; J++) null === (T = b[J]) || T.index < 0 || (B = e.tiles[T.index][2], (F = e.tilesets[B]).tileProperties && F.tileProperties[T.index - F.firstgid] && (T.properties = U.Utils.mixin(F.tileProperties[T.index - F.firstgid], T.properties)))
                    }
                }
                return e
            }
        }, U.Tileset = function(t, e, i, o, s, n, r) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === s && (s = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | o, this.tileMargin = 0 | s, this.tileSpacing = 0 | n, this.properties = r || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, U.Tileset.prototype = {
            draw: function(t, e, i, o) {
                var s = o - this.firstgid << 1;
                0 <= s && s + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[s], this.drawCoords[s + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            setImage: function(t) {
                this.image = t, this.updateTileData(t.width, t.height)
            },
            setSpacing: function(t, e) {
                this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(t, e) {
                var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    o = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i = Math.floor(i), o = Math.floor(o), this.rows && this.rows !== i || this.columns && this.columns, this.rows = i, this.columns = o, this.total = i * o, this.drawCoords.length = 0;
                for (var s = this.tileMargin, n = this.tileMargin, r = 0; r < this.rows; r++) {
                    for (var a = 0; a < this.columns; a++) this.drawCoords.push(s), this.drawCoords.push(n), s += this.tileWidth + this.tileSpacing;
                    s = this.tileMargin, n += this.tileHeight + this.tileSpacing
                }
            }
        }, U.Tileset.prototype.constructor = U.Tileset, U.Particle = function(t, e, i, o, s) {
            U.Sprite.call(this, t, e, i, o, s), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, U.Particle.prototype = Object.create(U.Sprite.prototype), U.Particle.prototype.constructor = U.Particle, U.Particle.prototype.update = function() {
            this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, U.Particle.prototype.onEmit = function() {}, U.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, U.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, U.Particle.prototype.reset = function(t, e, i) {
            return U.Component.Reset.prototype.reset.call(this, t, e, i), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, U.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, U.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.name] = t
            },
            remove: function(t) {
                delete this.emitters[t.name]
            },
            update: function() {
                for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
            }
        }, U.Particles.prototype.constructor = U.Particles, U.Particles.Arcade = {}, U.Particles.Arcade.Emitter = function(t, e, i, o) {
            this.maxParticles = o || 50, U.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = U.EMITTER, this.physicsType = U.GROUP, this.area = new U.Rectangle(e, i, 1, 1), this.minParticleSpeed = new U.Point(-100, -100), this.maxParticleSpeed = new U.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = U.Particle, this.particleDrag = new U.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new U.Point, this.on = !1, this.particleAnchor = new U.Point(.5, .5), this.blendMode = U.blendModes.NORMAL, this.emitX = e, this.emitY = i, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new U.Point(1, 1), this._maxParticleScale = new U.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, U.Particles.Arcade.Emitter.prototype = Object.create(U.Group.prototype), U.Particles.Arcade.Emitter.prototype.constructor = U.Particles.Arcade.Emitter, U.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (0 < this._flowQuantity) {
                        for (var t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, 0 < this._quantity && this._counter >= this._quantity && (this.on = !1));
            for (t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
        }, U.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, o, s) {
            var n;
            void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === o && (o = !1), void 0 === s && (s = !1);
            var r = 0,
                a = t,
                h = e;
            for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); r < i;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), n = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(n, !1), n.body.checkCollision.none = !o || !(n.body.checkCollision.any = !0), n.body.collideWorldBounds = s, n.body.skipQuadTree = !0, n.exists = !1, n.visible = !1, n.anchor.copyFrom(this.particleAnchor), this.add(n), r++;
            return this
        }, U.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, U.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, U.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
        }, U.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, o, s) {
            return void 0 !== i && 0 !== i || (i = 1), void 0 === o && (o = -1), void 0 === s && (s = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = o, s ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
        }, U.Particles.Arcade.Emitter.prototype.start = function(t, e, i, o, s) {
            if (void 0 === t && (t = !0), void 0 === e && (e = 0), null == i && (i = 250), void 0 === o && (o = 0), void 0 === s && (s = !1), o > this.maxParticles && (o = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || s)
                for (var n = 0; n < o; n++) this.emitParticle();
            else this.on = !0, this._quantity = o, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }, U.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, o) {
            void 0 === t && (t = null), void 0 === e && (e = null);
            var s = this.getFirstExists(!1);
            if (null === s) return !1;
            var n = this.game.rnd;
            void 0 !== i && void 0 !== o ? s.loadTexture(i, o) : void 0 !== i && s.loadTexture(i);
            var r = this.emitX,
                a = this.emitY;
            null !== t ? r = t : 1 < this.width && (r = n.between(this.left, this.right)), null !== e ? a = e : 1 < this.height && (a = n.between(this.top, this.bottom)), s.reset(r, a), s.angle = 0, s.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(s) : this.particleSendToBack && this.sendToBack(s), this.autoScale ? s.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? s.scale.set(n.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || s.scale.set(n.realInRange(this._minParticleScale.x, this._maxParticleScale.x), n.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === o && (Array.isArray(this._frames) ? s.frame = this.game.rnd.pick(this._frames) : s.frame = this._frames), this.autoAlpha ? s.setAlphaData(this.alphaData) : s.alpha = n.realInRange(this.minParticleAlpha, this.maxParticleAlpha), s.blendMode = this.blendMode;
            var h = s.body;
            return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = n.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = n.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = n.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, s.onEmit(), !0
        }, U.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), U.Group.prototype.destroy.call(this, !0, !1)
        }, U.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t, this.area.height = e, this
        }, U.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
        }, U.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
        }, U.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
        }, U.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, i, o, s) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === o && (o = U.Easing.Linear.None), void 0 === s && (s = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, 0 < i && t !== e) {
                var n = {
                        v: t
                    },
                    r = this.game.make.tween(n).to({
                        v: e
                    }, i, o);
                r.yoyo(s), this.alphaData = r.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, U.Particles.Arcade.Emitter.prototype.setScale = function(t, e, i, o, s, n, r) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === o && (o = 1), void 0 === s && (s = 0), void 0 === n && (n = U.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, i), this._maxParticleScale.set(e, o), this.autoScale = !1, 0 < s && (t !== e || i !== o)) {
                var a = {
                        x: t,
                        y: i
                    },
                    h = this.game.make.tween(a).to({
                        x: e,
                        y: o
                    }, s, n);
                h.yoyo(r), this.scaleData = h.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, U.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
        }, Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(t) {
                this.area.width = t
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(t) {
                this.area.height = t
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(t) {
                this.emitX = t
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(t) {
                this.emitY = t
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(U.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), U.Weapon = function(t, e) {
            U.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new U.Rectangle(0, 0, 1, 1), this.fireAngle = U.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new U.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = U.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = U.Weapon.KILL_WORLD_BOUNDS, this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            }, this.bounds = new U.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new U.Signal, this.onKill = new U.Signal, this.onFireLimit = new U.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new U.Point, this._nextFire = 0, this._rotatedPoint = new U.Point
        }, U.Weapon.prototype = Object.create(U.Plugin.prototype), U.Weapon.prototype.constructor = U.Weapon, U.Weapon.KILL_NEVER = 0, U.Weapon.KILL_LIFESPAN = 1, U.Weapon.KILL_DISTANCE = 2, U.Weapon.KILL_WEAPON_BOUNDS = 3, U.Weapon.KILL_CAMERA_BOUNDS = 4, U.Weapon.KILL_WORLD_BOUNDS = 5, U.Weapon.KILL_STATIC_BOUNDS = 6, U.Weapon.prototype.createBullets = function(t, e, i, o) {
            return void 0 === t && (t = 1), void 0 === o && (o = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(U.Physics.ARCADE, o), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, i), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = i), this
        }, U.Weapon.prototype.forEach = function(t, e) {
            return this.bullets.forEachExists(t, e, arguments), this
        }, U.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1), this
        }, U.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0), this
        }, U.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
        }, U.Weapon.prototype.resetShots = function(t) {
            return void(this.shots = 0) !== t && (this.fireLimit = t), this
        }, U.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }, U.Weapon.prototype.update = function() {
            this._bulletKillType === U.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
        }, U.Weapon.prototype.trackSprite = function(t, e, i, o) {
            return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = o, this.trackOffset.set(e, i), this
        }, U.Weapon.prototype.trackPointer = function(t, e, i) {
            return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
        }, U.Weapon.prototype.fire = function(t, e, i) {
            if (this.game.time.now < this._nextFire || 0 < this.fireLimit && this.shots === this.fireLimit) return !1;
            var o = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (o += U.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? 1 < this.fireFrom.width ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), 1 < this.fireFrom.width ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : 1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (o += this.trackedSprite.body.speed)) : this.trackedPointer && (1 < this.fireFrom.width ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
            var s = 1 < this.fireFrom.width ? this.fireFrom.randomX : this.fireFrom.x,
                n = 1 < this.fireFrom.height ? this.fireFrom.randomY : this.fireFrom.y,
                r = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== e && void 0 !== i && (r = this.game.math.radToDeg(Math.atan2(i - n, e - s))), 0 !== this.bulletAngleVariance && (r += U.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var a = 0,
                h = 0;
            0 === r || 180 === r ? a = Math.cos(this.game.math.degToRad(r)) * o : h = (90 === r || 270 === r || (a = Math.cos(this.game.math.degToRad(r)) * o), Math.sin(this.game.math.degToRad(r)) * o);
            var l = null;
            if (this.autoExpandBulletsGroup ? (l = this.bullets.getFirstExists(!1, !0, s, n, this.bulletKey, this.bulletFrame)).data.bulletManager = this : l = this.bullets.getFirstExists(!1), l) {
                if (l.reset(s, n), l.data.fromX = s, l.data.fromY = n, l.data.killType = this.bulletKillType, l.data.killDistance = this.bulletKillDistance, l.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === U.Weapon.KILL_LIFESPAN && (l.lifespan = this.bulletLifespan), l.angle = r + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === l.animations.getAnimation(this.bulletAnimation)) {
                        var d = this.anims[this.bulletAnimation];
                        l.animations.add(d.name, d.frames, d.frameRate, d.loop, d.useNumericIndex)
                    }
                    l.animations.play(this.bulletAnimation)
                } else this.bulletFrameCycle ? (l.frame = this.bulletFrames[this.bulletFrameIndex], this.bulletFrameIndex++, this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (l.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                if (l.data.bodyDirty && (this._data.customBody && l.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), l.body.collideWorldBounds = this.bulletCollideWorldBounds, l.data.bodyDirty = !1), l.body.velocity.set(a, h), l.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                    var c = this.fireRate;
                    (c += U.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (c = 0), this._nextFire = this.game.time.now + c
                } else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(l, this, o), 0 < this.fireLimit && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return l
        }, U.Weapon.prototype.fireAtPointer = function(t) {
            return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
        }, U.Weapon.prototype.fireAtSprite = function(t) {
            return this.fire(null, t.world.x, t.world.y)
        }, U.Weapon.prototype.fireAtXY = function(t, e) {
            return this.fire(null, t, e)
        }, U.Weapon.prototype.setBulletBodyOffset = function(t, e, i, o) {
            return void 0 === i && (i = 0), void 0 === o && (o = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = o, this.bullets.callAll("body.setSize", "body", t, e, i, o), this.bullets.setAll("data.bodyDirty", !1), this
        }, U.Weapon.prototype.setBulletFrames = function(t, e, i, o) {
            return void 0 === i && (i = !0), void 0 === o && (o = !1), this.bulletFrames = U.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = i, this.bulletFrameRandom = o, this
        }, U.Weapon.prototype.addBulletAnimation = function(t, e, i, o, s) {
            return this.anims[t] = {
                name: t,
                frames: e,
                frameRate: i,
                loop: o,
                useNumericIndex: s
            }, this.bullets.callAll("animations.add", "animations", t, e, i, o, s), this.bulletAnimation = t, this
        }, U.Weapon.prototype.debug = function(t, e, i) {
            void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }, Object.defineProperty(U.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(t) {
                this._bulletClass = t, this.bullets.classType = this._bulletClass
            }
        }), Object.defineProperty(U.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(t) {
                switch (t) {
                    case U.Weapon.KILL_STATIC_BOUNDS:
                    case U.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case U.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case U.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = t
            }
        }), Object.defineProperty(U.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(t) {
                this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
            }
        }), Object.defineProperty(U.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(t) {
                this.fireFrom.x = t
            }
        }), Object.defineProperty(U.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(t) {
                this.fireFrom.y = t
            }
        }), U.Bullet = function(t, e, i, o, s) {
            U.Sprite.call(this, t, e, i, o, s), this.anchor.set(.5), this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }, U.Bullet.prototype = Object.create(U.Sprite.prototype), U.Bullet.prototype.constructor = U.Bullet, U.Bullet.prototype.kill = function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
        }, U.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > U.Weapon.KILL_LIFESPAN && (this.data.killType === U.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }, U.Video = function(t, e, i) {
            if (void 0 === e && (e = null), void 0 === i && (i = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = U.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new U.Signal, this.onChangeSource = new U.Signal, this.onComplete = new U.Signal, this.onAccess = new U.Signal, this.onError = new U.Signal, this.onTimeout = new U.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                var o = this.game.cache.getVideo(e);
                o.isBlob ? this.createVideoFromBlob(o.data) : this.video = o.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            } else i && this.createVideoFromURL(i, !1);
            this.video && !i ? this.baseTexture = new PIXI.BaseTexture(this.video) : this.baseTexture = new PIXI.BaseTexture(U.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new U.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, U.BitmapData && (this.snapshot = new U.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.chrome) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : o && (o.locked = !1)
        }, U.Video.prototype = {
            connectToMediaStream: function(t, e) {
                return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
            },
            startMediaStream: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: t,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (t) {
                    this.getUserMediaError(t)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(t) {
                clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
            },
            getUserMediaSuccess: function(t) {
                clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                var s = this;
                this.video.onloadeddata = function() {
                    var o = 10;
                    ! function t() {
                        if (0 < o)
                            if (0 < s.video.videoWidth) {
                                var e = s.video.videoWidth,
                                    i = s.video.videoHeight;
                                isNaN(s.video.videoHeight) && (i = e / (4 / 3)), s.video.play(), s.isStreaming = !0, s.baseTexture.source = s.video, s.updateTexture(null, e, i), s.onAccess.dispatch(s)
                            } else window.setTimeout(t, 500);
                        o--
                    }()
                }
            },
            createVideoFromBlob: function(t) {
                var e = this;
                return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                    e.updateTexture(t)
                }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
            },
            createVideoFromURL: function(t, e) {
                return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
            },
            updateTexture: function(t, e, i) {
                var o = !1;
                null == e && (e = this.video.videoWidth, o = !0), null == i && (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), o && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(t, e) {
                return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                    t.stop()
                }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            addToWorld: function(t, e, i, o, s, n) {
                s = s || 1, n = n || 1;
                var r = this.game.add.image(t, e, this);
                return r.anchor.set(i, o), r.scale.set(s, n), r
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0, this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
            },
            changeSource: function(t, e) {
                return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), (this._autoplay = e) || (this.paused = !0), this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? this.updateTexture() : (this.retry--, 0 < this.retry && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)))
            },
            setTouchLock: function() {
                this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                    var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1)
                }
                return !0
            },
            grab: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() {
                this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
            }
        }, Object.defineProperty(U.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(t) {
                this.video.currentTime = t
            }
        }), Object.defineProperty(U.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }), Object.defineProperty(U.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }), Object.defineProperty(U.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(U.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                if (t = t || null, !this.touchLocked)
                    if (t) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    } else {
                        if (!this._paused) return;
                        this._codePaused = !1, this.setResume()
                    }
            }
        }), Object.defineProperty(U.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(t) {
                t < 0 ? t = 0 : 1 < t && (t = 1), this.video && (this.video.volume = t)
            }
        }), Object.defineProperty(U.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(t) {
                this.video && (this.video.playbackRate = t)
            }
        }), Object.defineProperty(U.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(t) {
                t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }), Object.defineProperty(U.Video.prototype, "playing", {
            get: function() {
                return !(this.video.paused && this.video.ended)
            }
        }), U.Video.prototype.constructor = U.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = U.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = U.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = U.POLYGON, PIXI.Graphics.RECT = U.RECTANGLE, PIXI.Graphics.CIRC = U.CIRCLE, PIXI.Graphics.ELIP = U.ELLIPSE, PIXI.Graphics.RREC = U.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = U), exports.Phaser = U) : "undefined" != typeof define && define.amd ? define("Phaser", t.Phaser = U) : t.Phaser = U, U
    }.call(this),
    function() {
        function o(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function s(e, i, t) {
            if (!e) throw Error();
            if (2 < arguments.length) {
                var o = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var t = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(t, o), e.apply(i, t)
                }
            }
            return function() {
                return e.apply(i, arguments)
            }
        }

        function b(t, e, i) {
            return (b = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? o : s).apply(null, arguments)
        }
        var a = Date.now || function() {
            return +new Date
        };

        function e(t, e) {
            this.a = t, this.o = e || t, this.c = this.o.document
        }
        var h = !!window.FontFace;

        function l(t, e, i, o) {
            if (e = t.c.createElement(e), i)
                for (var s in i) i.hasOwnProperty(s) && ("style" == s ? e.style.cssText = i[s] : e.setAttribute(s, i[s]));
            return o && e.appendChild(t.c.createTextNode(o)), e
        }

        function d(t, e, i) {
            (t = t.c.getElementsByTagName(e)[0]) || (t = document.documentElement), t.insertBefore(i, t.lastChild)
        }

        function i(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function m(t, e, i) {
            e = e || [], i = i || [];
            for (var o = t.className.split(/\s+/), s = 0; s < e.length; s += 1) {
                for (var n = !1, r = 0; r < o.length; r += 1)
                    if (e[s] === o[r]) {
                        n = !0;
                        break
                    }
                n || o.push(e[s])
            }
            for (e = [], s = 0; s < o.length; s += 1) {
                for (n = !1, r = 0; r < i.length; r += 1)
                    if (o[s] === i[r]) {
                        n = !0;
                        break
                    }
                n || e.push(o[s])
            }
            t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function n(t, e) {
            for (var i = t.className.split(/\s+/), o = 0, s = i.length; o < s; o++)
                if (i[o] == e) return !0;
            return !1
        }

        function c(t, e, i) {
            function o() {
                r && s && (r(n), r = null)
            }
            e = l(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var s = !1,
                n = null,
                r = i || null;
            h ? (e.onload = function() {
                s = !0, o()
            }, e.onerror = function() {
                s = !0, n = Error("Stylesheet failed to load"), o()
            }) : setTimeout(function() {
                s = !0, o()
            }, 0), d(t, "head", e)
        }

        function u(t, e, i, o) {
            var s = t.c.getElementsByTagName("head")[0];
            if (s) {
                var n = l(t, "script", {
                        src: e
                    }),
                    r = !1;
                return n.onload = n.onreadystatechange = function() {
                    r || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (r = !0, i && i(null), n.onload = n.onreadystatechange = null, "HEAD" == n.parentNode.tagName && s.removeChild(n))
                }, s.appendChild(n), setTimeout(function() {
                    r || (r = !0, i && i(Error("Script load timeout")))
                }, o || 5e3), n
            }
            return null
        }

        function p() {
            this.a = 0, this.c = null
        }

        function y(t) {
            return t.a++,
                function() {
                    t.a--, r(t)
                }
        }

        function f(t, e) {
            t.c = e, r(t)
        }

        function r(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function x(t) {
            this.a = t || "-"
        }

        function g(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            var i = (e || "n4").match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10))
        }

        function _(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var o = t[i].replace(/['"]/g, ""); - 1 != o.indexOf(" ") || /^\d/.test(o) ? e.push("'" + o + "'") : e.push(o)
            }
            return e.join(",")
        }

        function v(t) {
            return t.a + t.f
        }

        function S(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function C(t, e) {
            this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new x("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
        }

        function w(t) {
            if (t.g) {
                var e = n(t.f, t.a.c("wf", "active")),
                    i = [],
                    o = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), m(t.f, i, o)
            }
            A(t, "inactive")
        }

        function A(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, v(i)) : t.h[e]())
        }

        function P() {
            this.c = {}
        }

        function T(t, e) {
            this.c = t, this.f = e, this.a = l(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function B(t) {
            d(t.c, "body", t.a)
        }

        function M(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + _(t.c) + ";font-style:" + S(t) + ";font-weight:" + t.f + "00;"
        }

        function E(t, e, i, o, s, n) {
            this.g = t, this.j = e, this.a = o, this.c = i, this.f = s || 3e3, this.h = n || void 0
        }

        function I(t, e, i, o, s, n, r) {
            this.v = t, this.B = e, this.c = i, this.a = o, this.s = r || "BESbswy", this.f = {}, this.w = s || 3e3, this.u = n || null, this.m = this.j = this.h = this.g = null, this.g = new T(this.c, this.s), this.h = new T(this.c, this.s), this.j = new T(this.c, this.s), this.m = new T(this.c, this.s), t = M(t = new g(this.a.c + ",serif", v(this.a))), this.g.a.style.cssText = t, t = M(t = new g(this.a.c + ",sans-serif", v(this.a))), this.h.a.style.cssText = t, t = M(t = new g("serif", v(this.a))), this.j.a.style.cssText = t, t = M(t = new g("sans-serif", v(this.a))), this.m.a.style.cssText = t, B(this.g), B(this.h), B(this.j), B(this.m)
        }
        x.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase());
            return e.join(this.a)
        }, E.prototype.start = function() {
            var s = this.c.o.document,
                n = this,
                r = a(),
                t = new Promise(function(i, o) {
                    ! function e() {
                        var t;
                        a() - r >= n.f ? o() : s.fonts.load((t = n.a, S(t) + " " + t.f + "00 300px " + _(t.c)), n.h).then(function(t) {
                            1 <= t.length ? i() : setTimeout(e, 25)
                        }, function() {
                            o()
                        })
                    }()
                }),
                i = null,
                e = new Promise(function(t, e) {
                    i = setTimeout(e, n.f)
                });
            Promise.race([e, t]).then(function() {
                i && (clearTimeout(i), i = null), n.g(n.a)
            }, function() {
                n.j(n.a)
            })
        };
        var V = {
                D: "serif",
                C: "sans-serif"
            },
            R = null;

        function L() {
            if (null === R) {
                var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                R = !!t && (parseInt(t[1], 10) < 536 || 536 === parseInt(t[1], 10) && parseInt(t[2], 10) <= 11)
            }
            return R
        }

        function D(t, e, i) {
            for (var o in V)
                if (V.hasOwnProperty(o) && e === t.f[V[o]] && i === t.f[V[o]]) return !0;
            return !1
        }

        function F(t) {
            var e, i = t.g.a.offsetWidth,
                o = t.h.a.offsetWidth;
            (e = i === t.f.serif && o === t.f["sans-serif"]) || (e = L() && D(t, i, o)), e ? a() - t.A >= t.w ? L() && D(t, i, o) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? k(t, t.v) : k(t, t.B) : setTimeout(b(function() {
                F(this)
            }, t), 50) : k(t, t.v)
        }

        function k(t, e) {
            setTimeout(b(function() {
                i(this.g.a), i(this.h.a), i(this.j.a), i(this.m.a), e(this.a)
            }, t), 0)
        }

        function G(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }
        I.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = a(), F(this)
        };
        var O = null;

        function N(t) {
            0 == --t.f && t.j && (t.m ? ((t = t.a).g && m(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), A(t, "active")) : w(t.a))
        }

        function t(t) {
            this.j = t, this.a = new P, this.h = 0, this.f = this.g = !0
        }

        function J(t, e) {
            this.c = t, this.a = e
        }

        function U(t, e) {
            this.c = t, this.a = e
        }

        function W(t, e) {
            this.c = t || "https://fonts.googleapis.com/css", this.a = [], this.f = [], this.g = e || ""
        }
        G.prototype.g = function(t) {
            var e = this.a;
            e.g && m(e.f, [e.a.c("wf", t.c, v(t).toString(), "active")], [e.a.c("wf", t.c, v(t).toString(), "loading"), e.a.c("wf", t.c, v(t).toString(), "inactive")]), A(e, "fontactive", t), this.m = !0, N(this)
        }, G.prototype.h = function(t) {
            var e = this.a;
            if (e.g) {
                var i = n(e.f, e.a.c("wf", t.c, v(t).toString(), "active")),
                    o = [],
                    s = [e.a.c("wf", t.c, v(t).toString(), "loading")];
                i || o.push(e.a.c("wf", t.c, v(t).toString(), "inactive")), m(e.f, o, s)
            }
            A(e, "fontinactive", t), N(this)
        }, t.prototype.load = function(t) {
            this.c = new e(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes,
                function(s, t, e) {
                    var i = [],
                        o = e.timeout;
                    n = t, n.g && m(n.f, [n.a.c("wf", "loading")]), A(n, "loading");
                    var n;
                    var i = function(t, e, i) {
                            var o, s = [];
                            for (o in e)
                                if (e.hasOwnProperty(o)) {
                                    var n = t.c[o];
                                    n && s.push(n(e[o], i))
                                }
                            return s
                        }(s.a, e, s.c),
                        r = new G(s.c, t, o);
                    for (s.h = i.length, t = 0, e = i.length; t < e; t++) i[t].load(function(t, e, i) {
                        var o, l, d, c, u, p;
                        l = r, d = t, c = e, u = i, p = 0 == --(o = s).h, (o.f || o.g) && setTimeout(function() {
                            var t = u || null,
                                e = c || {};
                            if (0 === d.length && p) w(l.a);
                            else {
                                l.f += d.length, p && (l.j = p);
                                var i, o = [];
                                for (i = 0; i < d.length; i++) {
                                    var s = d[i],
                                        n = e[s.c],
                                        r = l.a,
                                        a = s;
                                    if (r.g && m(r.f, [r.a.c("wf", a.c, v(a).toString(), "loading")]), A(r, "fontloading", a), (r = null) === O)
                                        if (window.FontFace) {
                                            var a = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                                h = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                            O = a ? 42 < parseInt(a[1], 10) : !h
                                        } else O = !1;
                                    r = O ? new E(b(l.g, l), b(l.h, l), l.c, s, l.s, n) : new I(b(l.g, l), b(l.h, l), l.c, s, l.s, t, n), o.push(r)
                                }
                                for (i = 0; i < o.length; i++) o[i].start()
                            }
                        }, 0)
                    })
                }(this, new C(this.c, t), t)
        }, J.prototype.load = function(r) {
            var e = this,
                a = e.a.projectId,
                t = e.a.version;
            if (a) {
                var h = e.c.o;
                u(this.c, (e.a.api || "https://fast.fonts.net/jsapi") + "/" + a + ".js" + (t ? "?v=" + t : ""), function(t) {
                    t ? r([]) : (h["__MonotypeConfiguration__" + a] = function() {
                        return e.a
                    }, function t() {
                        if (h["__mti_fntLst" + a]) {
                            var e, i = h["__mti_fntLst" + a](),
                                o = [];
                            if (i)
                                for (var s = 0; s < i.length; s++) {
                                    var n = i[s].fontfamily;
                                    null != i[s].fontStyle && null != i[s].fontWeight ? (e = i[s].fontStyle + i[s].fontWeight, o.push(new g(n, e))) : o.push(new g(n))
                                }
                            r(o)
                        } else setTimeout(function() {
                            t()
                        }, 50)
                    }())
                }).id = "__MonotypeAPIScript__" + a
            } else r([])
        }, U.prototype.load = function(t) {
            var e, i, o = this.a.urls || [],
                s = this.a.families || [],
                n = this.a.testStrings || {},
                r = new p;
            for (e = 0, i = o.length; e < i; e++) c(this.c, o[e], y(r));
            var a = [];
            for (e = 0, i = s.length; e < i; e++)
                if ((o = s[e].split(":"))[1])
                    for (var h = o[1].split(","), l = 0; l < h.length; l += 1) a.push(new g(o[0], h[l]));
                else a.push(new g(o[0]));
            f(r, function() {
                t(a, n)
            })
        };

        function X(t) {
            this.f = t, this.a = [], this.c = {}
        }
        var q = {
                latin: "BESbswy",
                "latin-ext": "",
                cyrillic: "",
                greek: "",
                khmer: "",
                Hanuman: ""
            },
            j = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            Y = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            z = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

        function H(t, e) {
            this.c = t, this.a = e
        }
        var K = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };

        function Q(t, e) {
            this.c = t, this.a = e
        }

        function Z(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        H.prototype.load = function(t) {
            var e = new p,
                i = this.c,
                o = new W(this.a.api, this.a.text),
                s = this.a.families;
            ! function(t, e) {
                for (var i = e.length, o = 0; o < i; o++) {
                    var s = e[o].split(":");
                    3 == s.length && t.f.push(s.pop());
                    var n = "";
                    2 == s.length && "" != s[1] && (n = ":"), t.a.push(s.join(n))
                }
            }(o, s);
            var n = new X(s);
            ! function(t) {
                for (var e = t.f.length, i = 0; i < e; i++) {
                    var o = t.f[i].split(":"),
                        s = o[0].replace(/\+/g, " "),
                        n = ["n4"];
                    if (2 <= o.length) {
                        var r;
                        if (r = [], a = o[1])
                            for (var a, h = (a = a.split(",")).length, l = 0; l < h; l++) {
                                var d;
                                if ((d = a[l]).match(/^[\w-]+$/))
                                    if (null == (u = z.exec(d.toLowerCase()))) d = "";
                                    else {
                                        if (d = null == (d = u[2]) || "" == d ? "n" : Y[d], null == (u = u[1]) || "" == u) u = "4";
                                        else var c = j[u],
                                            u = c || (isNaN(u) ? "4" : u.substr(0, 1));
                                        d = [d, u].join("")
                                    }
                                else d = "";
                                d && r.push(d)
                            }
                        0 < r.length && (n = r), 3 == o.length && (r = [], 0 < (o = (o = o[2]) ? o.split(",") : r).length && (o = q[o[0]]) && (t.c[s] = o))
                    }
                    for (t.c[s] || (o = q[s]) && (t.c[s] = o), o = 0; o < n.length; o += 1) t.a.push(new g(s, n[o]))
                }
            }(n), c(i, function(t) {
                if (0 == t.a.length) throw Error("No fonts to load!");
                if (-1 != t.c.indexOf("kit=")) return t.c;
                for (var e = t.a.length, i = [], o = 0; o < e; o++) i.push(t.a[o].replace(/ /g, "+"));
                return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
            }(o), y(e)), f(e, function() {
                t(n.a, n.c, K)
            })
        }, Q.prototype.load = function(r) {
            var t = this.a.id,
                a = this.c.o;
            t ? u(this.c, (this.a.api || "https://use.typekit.net") + "/" + t + ".js", function(t) {
                if (t) r([]);
                else if (a.Typekit && a.Typekit.config && a.Typekit.config.fn) {
                    t = a.Typekit.config.fn;
                    for (var e = [], i = 0; i < t.length; i += 2)
                        for (var o = t[i], s = t[i + 1], n = 0; n < s.length; n++) e.push(new g(o, s[n]));
                    try {
                        a.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    r(e)
                }
            }, 2e3) : r([])
        }, Z.prototype.load = function(l) {
            var t, e = this.f.id,
                i = this.c.o,
                d = this;
            e ? (i.__webfontfontdeckmodule__ || (i.__webfontfontdeckmodule__ = {}), i.__webfontfontdeckmodule__[e] = function(t, e) {
                for (var i = 0, o = e.fonts.length; i < o; ++i) {
                    var s = e.fonts[i];
                    d.a.push(new g(s.name, (n = "font-weight:" + s.weight + ";font-style:" + s.style, h = a = r = void 0, r = 4, a = "n", h = null, n && ((h = n.match(/(normal|oblique|italic)/i)) && h[1] && (a = h[1].substr(0, 1).toLowerCase()), (h = n.match(/([1-9]00|normal|bold)/i)) && h[1] && (/bold/i.test(h[1]) ? r = 7 : /[1-9]00/.test(h[1]) && (r = parseInt(h[1].substr(0, 1), 10)))), a + r)))
                }
                var n, r, a, h;
                l(d.a)
            }, u(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ((t = this.c).o.location.hostname || t.a.location.hostname) + "/" + e + ".js", function(t) {
                t && l([])
            })) : l([])
        };
        var $ = new t(window);
        $.a.c.custom = function(t, e) {
            return new U(e, t)
        }, $.a.c.fontdeck = function(t, e) {
            return new Z(e, t)
        }, $.a.c.monotype = function(t, e) {
            return new J(e, t)
        }, $.a.c.typekit = function(t, e) {
            return new Q(e, t)
        }, $.a.c.google = function(t, e) {
            return new H(e, t)
        };
        var tt = {
            load: b($.load, $)
        };
        "function" == typeof define && define.amd ? define(function() {
            return tt
        }) : "undefined" != typeof module && module.exports ? module.exports = tt : (window.WebFont = tt, window.WebFontConfig && $.load(window.WebFontConfig))
    }();
var COMPILED = !1,
    goog = goog || {};
goog.global = this, goog.global.CLOSURE_UNCOMPILED_DEFINES, goog.global.CLOSURE_DEFINES, goog.isDef = function(t) {
    return void 0 !== t
}, goog.exportPath_ = function(t, e, i) {
    var o, s = t.split("."),
        n = i || goog.global;
    s[0] in n || !n.execScript || n.execScript("var " + s[0]);
    for (; s.length && (o = s.shift());) !s.length && goog.isDef(e) ? n[o] = e : n = n[o] ? n[o] : n[o] = {}
}, goog.define = function(t, e) {
    var i = e;
    COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, t) ? i = goog.global.CLOSURE_UNCOMPILED_DEFINES[t] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, t) && (i = goog.global.CLOSURE_DEFINES[t])), goog.exportPath_(t, i)
}, goog.DEBUG = !0, goog.define("goog.LOCALE", "en"), goog.define("goog.TRUSTED_SITE", !0), goog.define("goog.STRICT_MODE_COMPATIBLE", !1), goog.provide = function(t) {
    if (!COMPILED) {
        if (goog.isProvided_(t)) throw Error('Namespace "' + t + '" already declared.');
        delete goog.implicitNamespaces_[t];
        for (var e = t;
            (e = e.substring(0, e.lastIndexOf("."))) && !goog.getObjectByName(e);) goog.implicitNamespaces_[e] = !0
    }
    goog.exportPath_(t)
}, goog.setTestOnly = function(t) {
    if (COMPILED && !goog.DEBUG) throw t = t || "", Error("Importing test-only code into non-debug environment" + (t ? ": " + t : "."))
}, goog.forwardDeclare = function() {}, COMPILED || (goog.isProvided_ = function(t) {
    return !goog.implicitNamespaces_[t] && goog.isDefAndNotNull(goog.getObjectByName(t))
}, goog.implicitNamespaces_ = {}), goog.getObjectByName = function(t, e) {
    for (var i, o = t.split("."), s = e || goog.global; i = o.shift();) {
        if (!goog.isDefAndNotNull(s[i])) return null;
        s = s[i]
    }
    return s
}, goog.globalize = function(t, e) {
    var i = e || goog.global;
    for (var o in t) i[o] = t[o]
}, goog.addDependency = function(t, e, i) {
    if (goog.DEPENDENCIES_ENABLED) {
        for (var o, s, n = t.replace(/\\/g, "/"), r = goog.dependencies_, a = 0; o = e[a]; a++)(r.nameToPath[o] = n) in r.pathToNames || (r.pathToNames[n] = {}), r.pathToNames[n][o] = !0;
        for (var h = 0; s = i[h]; h++) n in r.requires || (r.requires[n] = {}), r.requires[n][s] = !0
    }
}, goog.define("goog.ENABLE_DEBUG_LOADER", !0), goog.require = function(t) {
    if (!COMPILED) {
        if (goog.isProvided_(t)) return;
        if (goog.ENABLE_DEBUG_LOADER) {
            var e = goog.getPathFromDeps_(t);
            if (e) return goog.included_[e] = !0, void goog.writeScripts_()
        }
        var i = "goog.require could not find: " + t;
        throw goog.global.console && goog.global.console.error(i), Error(i)
    }
}, goog.basePath = "", goog.global.CLOSURE_BASE_PATH, goog.global.CLOSURE_NO_DEPS, goog.global.CLOSURE_IMPORT_SCRIPT, goog.nullFunction = function() {}, goog.identityFunction = function(t) {
    return t
}, goog.abstractMethod = function() {
    throw Error("unimplemented abstract method")
}, goog.addSingletonGetter = function(t) {
    t.getInstance = function() {
        return t.instance_ ? t.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = t), t.instance_ = new t)
    }
}, goog.instantiatedSingletons_ = [], goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER, goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
}, goog.inHtmlDocument_ = function() {
    var t = goog.global.document;
    return void 0 !== t && "write" in t
}, goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
        for (var t = goog.global.document.getElementsByTagName("script"), e = t.length - 1; 0 <= e; --e) {
            var i = t[e].src,
                o = i.lastIndexOf("?"),
                s = -1 == o ? i.length : o;
            if ("base.js" == i.substr(s - 7, 7)) return void(goog.basePath = i.substr(0, s - 7))
        }
}, goog.importScript_ = function(t) {
    var e = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[t] && e(t) && (goog.dependencies_.written[t] = !0)
}, goog.writeScriptTag_ = function(t) {
    if (goog.inHtmlDocument_()) {
        var e = goog.global.document;
        if ("complete" != e.readyState) return e.write('<script type="text/javascript" src="' + t + '"><\/script>'), !0;
        if (/\bdeps.js$/.test(t)) return !1;
        throw Error('Cannot write "' + t + '" after document load')
    }
    return !1
}, goog.writeScripts_ = function() {
    function i(t) {
        if (!(t in n.written)) {
            if (t in n.visited) return void(t in s || (s[t] = !0, o.push(t)));
            if (n.visited[t] = !0, t in n.requires)
                for (var e in n.requires[t])
                    if (!goog.isProvided_(e)) {
                        if (!(e in n.nameToPath)) throw Error("Undefined nameToPath for " + e);
                        i(n.nameToPath[e])
                    }
            t in s || (s[t] = !0, o.push(t))
        }
    }
    var o = [],
        s = {},
        n = goog.dependencies_;
    for (var t in goog.included_) n.written[t] || i(t);
    for (var e = 0; e < o.length; e++) {
        if (!o[e]) throw Error("Undefined script input");
        goog.importScript_(goog.basePath + o[e])
    }
}, goog.getPathFromDeps_ = function(t) {
    return t in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[t] : null
}, goog.findBasePath_()), goog.typeOf = function(t) {
    var e = typeof t;
    if ("object" == e) {
        if (!t) return "null";
        if (t instanceof Array) return "array";
        if (t instanceof Object) return e;
        var i = Object.prototype.toString.call(t);
        if ("[object Window]" == i) return "object";
        if ("[object Array]" == i || "number" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("splice")) return "array";
        if ("[object Function]" == i || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("call")) return "function"
    } else if ("function" == e && void 0 === t.call) return "object";
    return e
}, goog.isNull = function(t) {
    return null === t
}, goog.isDefAndNotNull = function(t) {
    return null != t
}, goog.isArray = function(t) {
    return "array" == goog.typeOf(t)
}, goog.isArrayLike = function(t) {
    var e = goog.typeOf(t);
    return "array" == e || "object" == e && "number" == typeof t.length
}, goog.isDateLike = function(t) {
    return goog.isObject(t) && "function" == typeof t.getFullYear
}, goog.isString = function(t) {
    return "string" == typeof t
}, goog.isBoolean = function(t) {
    return "boolean" == typeof t
}, goog.isNumber = function(t) {
    return "number" == typeof t
}, goog.isFunction = function(t) {
    return "function" == goog.typeOf(t)
}, goog.isObject = function(t) {
    var e = typeof t;
    return "object" == e && null != t || "function" == e
}, goog.getUid = function(t) {
    return t[goog.UID_PROPERTY_] || (t[goog.UID_PROPERTY_] = ++goog.uidCounter_)
}, goog.hasUid = function(t) {
    return !!t[goog.UID_PROPERTY_]
}, goog.removeUid = function(t) {
    "removeAttribute" in t && t.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete t[goog.UID_PROPERTY_]
    } catch (t) {}
}, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(t) {
    var e = goog.typeOf(t);
    if ("object" != e && "array" != e) return t;
    if (t.clone) return t.clone();
    var i = "array" == e ? [] : {};
    for (var o in t) i[o] = goog.cloneObject(t[o]);
    return i
}, goog.bindNative_ = function(t) {
    return t.call.apply(t.bind, arguments)
}, goog.bindJs_ = function(e, i) {
    if (!e) throw new Error;
    if (2 < arguments.length) {
        var o = Array.prototype.slice.call(arguments, 2);
        return function() {
            var t = Array.prototype.slice.call(arguments);
            return Array.prototype.unshift.apply(t, o), e.apply(i, t)
        }
    }
    return function() {
        return e.apply(i, arguments)
    }
}, goog.bind = function() {
    return goog.bind = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bindNative_ : goog.bindJs_, goog.bind.apply(null, arguments)
}, goog.partial = function(e) {
    var i = Array.prototype.slice.call(arguments, 1);
    return function() {
        var t = i.slice();
        return t.push.apply(t, arguments), e.apply(this, t)
    }
}, goog.mixin = function(t, e) {
    for (var i in e) t[i] = e[i]
}, goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +new Date
}, goog.globalEval = function(t) {
    if (goog.global.execScript) goog.global.execScript(t, "JavaScript");
    else {
        if (!goog.global.eval) throw Error("goog.globalEval not available");
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), void 0 !== goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) goog.global.eval(t);
        else {
            var e = goog.global.document,
                i = e.createElement("script");
            i.type = "text/javascript", i.defer = !1, i.appendChild(e.createTextNode(t)), e.body.appendChild(i), e.body.removeChild(i)
        }
    }
}, goog.evalWorksForGlobals_ = null, goog.cssNameMapping_, goog.cssNameMappingStyle_, goog.getCssName = function(t, e) {
    var i, s = function(t) {
        return goog.cssNameMapping_[t] || t
    };
    return i = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? s : function(t) {
        for (var e = t.split("-"), i = [], o = 0; o < e.length; o++) i.push(s(e[o]));
        return i.join("-")
    } : function(t) {
        return t
    }, e ? t + "-" + i(e) : i(t)
}, goog.setCssNameMapping = function(t, e) {
    goog.cssNameMapping_ = t, goog.cssNameMappingStyle_ = e
}, goog.global.CLOSURE_CSS_NAME_MAPPING, !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING), goog.getMsg = function(t, i) {
    return i && (t = t.replace(/\{\$([^}]+)}/g, function(t, e) {
        return e in i ? i[e] : t
    })), t
}, goog.getMsgWithFallback = function(t) {
    return t
}, goog.exportSymbol = function(t, e, i) {
    goog.exportPath_(t, e, i)
}, goog.exportProperty = function(t, e, i) {
    t[e] = i
}, goog.inherits = function(t, o) {
    function e() {}
    e.prototype = o.prototype, t.superClass_ = o.prototype, t.prototype = new e, (t.prototype.constructor = t).base = function(t, e) {
        var i = Array.prototype.slice.call(arguments, 2);
        return o.prototype[e].apply(t, i)
    }
}, goog.base = function(t, e) {
    var i = arguments.callee.caller;
    if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !i) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
    if (i.superClass_) return i.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1));
    for (var o = Array.prototype.slice.call(arguments, 2), s = !1, n = t.constructor; n; n = n.superClass_ && n.superClass_.constructor)
        if (n.prototype[e] === i) s = !0;
        else if (s) return n.prototype[e].apply(t, o);
    if (t[e] === i) return t.constructor.prototype[e].apply(t, o);
    throw Error("goog.base called from a method of one name to a method of a different name")
}, goog.scope = function(t) {
    t.call(goog.global)
}, COMPILED || (goog.global.COMPILED = COMPILED), goog.defineClass = function(t, e) {
    var i = e.constructor,
        o = e.statics;
    i && i != Object.prototype.constructor || (i = function() {
        throw Error("cannot instantiate an interface (no constructor defined).")
    });
    var s = goog.defineClass.createSealingConstructor_(i, t);
    return t && goog.inherits(s, t), delete e.constructor, delete e.statics, goog.defineClass.applyProperties_(s.prototype, e), null != o && (o instanceof Function ? o(s) : goog.defineClass.applyProperties_(s, o)), s
}, goog.defineClass.ClassDescriptor, goog.define("goog.defineClass.SEAL_CLASS_INSTANCES", goog.DEBUG), goog.defineClass.createSealingConstructor_ = function(e, t) {
    if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
        if (t && t.prototype && t.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) return e;
        var i = function() {
            var t = e.apply(this, arguments) || this;
            return this.constructor === i && Object.seal(t), t
        };
        return i
    }
    return e
}, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], goog.defineClass.applyProperties_ = function(t, e) {
    var i;
    for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    for (var o = 0; o < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; o++) i = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[o], Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
}, goog.tagUnsealableClass = function(t) {
    !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (t.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0)
}, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.provide("box2d.b2Settings"), Object.defineProperty || (Object.defineProperty = function(t, e, i) {
    Object.__defineGetter__ && ("get" in i ? t.__defineGetter__(e, i.get) : "value" in i && t.__defineGetter__(e, i.value)), Object.__defineSetter__ && ("set" in i ? t.__defineSetter__(e, i.set) : "value" in i && t.__defineSetter__(e, i.value))
}), box2d.DEBUG = !1, box2d.ENABLE_ASSERTS = box2d.DEBUG, box2d.b2Assert = function(t) {
    box2d.DEBUG
}, box2d.b2_maxFloat = 1e37, box2d.b2_epsilon = 1e-5, box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon, box2d.b2_pi = Math.PI, box2d.b2_maxManifoldPoints = 2, box2d.b2_maxPolygonVertices = 8, box2d.b2_aabbExtension = .1, box2d.b2_aabbMultiplier = 2, box2d.b2_linearSlop = .008, box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi, box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop, box2d.b2_maxSubSteps = 8, box2d.b2_maxTOIContacts = 32, box2d.b2_velocityThreshold = 1, box2d.b2_maxLinearCorrection = .2, box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi, box2d.b2_maxTranslation = 2, box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation, box2d.b2_maxRotation = .5 * box2d.b2_pi, box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation, box2d.b2_baumgarte = .2, box2d.b2_toiBaumgarte = .75, box2d.b2_timeToSleep = .5, box2d.b2_linearSleepTolerance = .01, box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi, box2d.b2Alloc = function() {
    return null
}, box2d.b2Free = function() {}, box2d.b2Log = function() {
    goog.global.console.log.apply(null, arguments)
}, box2d.b2Version = function(t, e, i) {
    this.major = t || 0, this.minor = e || 0, this.revision = i || 0
}, box2d.b2Version.prototype.major = 0, box2d.b2Version.prototype.minor = 0, box2d.b2Version.prototype.revision = 0, box2d.b2Version.prototype.toString = function() {
    return this.major + "." + this.minor + "." + this.revision
}, box2d.b2_version = new box2d.b2Version(2, 3, 0), box2d.b2_changelist = 278, box2d.b2ParseInt = function(t) {
    return parseInt(t, 10)
}, box2d.b2ParseUInt = function(t) {
    return box2d.b2Abs(parseInt(t, 10))
}, box2d.b2MakeArray = function(t, e) {
    void 0 === t && (t = 0);
    var i = new Array(t);
    if (void 0 !== e)
        for (var o = 0; o < t; ++o) i[o] = e(o);
    return i
}, box2d.b2MakeNumberArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return 0
    })
}, goog.provide("box2d.b2Math"), goog.require("box2d.b2Settings"), box2d.b2_pi_over_180 = box2d.b2_pi / 180, box2d.b2_180_over_pi = 180 / box2d.b2_pi, box2d.b2_two_pi = 2 * box2d.b2_pi, box2d.b2Abs = function(t) {
    return t < 0 ? -t : t
}, box2d.b2Min = function(t, e) {
    return t < e ? t : e
}, box2d.b2Max = function(t, e) {
    return e < t ? t : e
}, box2d.b2Clamp = function(t, e, i) {
    return t < e ? e : i < t ? i : t
}, box2d.b2Swap = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    var i = t[0];
    t[0] = e[0], e[0] = i
}, box2d.b2IsValid = function(t) {
    return isFinite(t)
}, box2d.b2Sq = function(t) {
    return t * t
}, box2d.b2InvSqrt = function(t) {
    return 1 / Math.sqrt(t)
}, box2d.b2Sqrt = function(t) {
    return Math.sqrt(t)
}, box2d.b2Pow = function(t, e) {
    return Math.pow(t, e)
}, box2d.b2DegToRad = function(t) {
    return t * box2d.b2_pi_over_180
}, box2d.b2RadToDeg = function(t) {
    return t * box2d.b2_180_over_pi
}, box2d.b2Cos = function(t) {
    return Math.cos(t)
}, box2d.b2Sin = function(t) {
    return Math.sin(t)
}, box2d.b2Acos = function(t) {
    return Math.acos(t)
}, box2d.b2Asin = function(t) {
    return Math.asin(t)
}, box2d.b2Atan2 = function(t, e) {
    return Math.atan2(t, e)
}, box2d.b2NextPowerOfTwo = function(t) {
    return t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1
}, box2d.b2IsPowerOfTwo = function(t) {
    return 0 < t && 0 == (t & t - 1)
}, box2d.b2Random = function() {
    return 2 * Math.random() - 1
}, box2d.b2RandomRange = function(t, e) {
    return (e - t) * Math.random() + t
}, box2d.b2Vec2 = function(t, e) {
    this.x = t || 0, this.y = e || 0
}, box2d.b2Vec2.prototype.x = 0, box2d.b2Vec2.prototype.y = 0, box2d.b2Vec2_zero = new box2d.b2Vec2, box2d.b2Vec2.ZERO = new box2d.b2Vec2, box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0), box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1), box2d.b2Vec2.s_t0 = new box2d.b2Vec2, box2d.b2Vec2.s_t1 = new box2d.b2Vec2, box2d.b2Vec2.s_t2 = new box2d.b2Vec2, box2d.b2Vec2.s_t3 = new box2d.b2Vec2, box2d.b2Vec2.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2Vec2
    })
}, box2d.b2Vec2.prototype.Clone = function() {
    return new box2d.b2Vec2(this.x, this.y)
}, box2d.b2Vec2.prototype.SetZero = function() {
    return this.x = 0, this.y = 0, this
}, box2d.b2Vec2.prototype.SetXY = function(t, e) {
    return this.x = t, this.y = e, this
}, box2d.b2Vec2.prototype.Copy = function(t) {
    return this.x = t.x, this.y = t.y, this
}, box2d.b2Vec2.prototype.SelfAdd = function(t) {
    return this.x += t.x, this.y += t.y, this
}, box2d.b2Vec2.prototype.SelfAddXY = function(t, e) {
    return this.x += t, this.y += e, this
}, box2d.b2Vec2.prototype.SelfSub = function(t) {
    return this.x -= t.x, this.y -= t.y, this
}, box2d.b2Vec2.prototype.SelfSubXY = function(t, e) {
    return this.x -= t, this.y -= e, this
}, box2d.b2Vec2.prototype.SelfMul = function(t) {
    return this.x *= t, this.y *= t, this
}, box2d.b2Vec2.prototype.SelfMulAdd = function(t, e) {
    return this.x += t * e.x, this.y += t * e.y, this
}, box2d.b2Vec2.prototype.SelfMulSub = function(t, e) {
    return this.x -= t * e.x, this.y -= t * e.y, this
}, box2d.b2Vec2.prototype.Dot = function(t) {
    return this.x * t.x + this.y * t.y
}, box2d.b2Vec2.prototype.Cross = function(t) {
    return this.x * t.y - this.y * t.x
}, box2d.b2Vec2.prototype.Length = function() {
    var t = this.x,
        e = this.y;
    return Math.sqrt(t * t + e * e)
}, box2d.b2Vec2.prototype.GetLength = box2d.b2Vec2.prototype.Length, box2d.b2Vec2.prototype.LengthSquared = function() {
    var t = this.x,
        e = this.y;
    return t * t + e * e
}, box2d.b2Vec2.prototype.GetLengthSquared = box2d.b2Vec2.prototype.LengthSquared, box2d.b2Vec2.prototype.Normalize = function() {
    var t = this.GetLength();
    if (t >= box2d.b2_epsilon) {
        var e = 1 / t;
        this.x *= e, this.y *= e
    }
    return t
}, box2d.b2Vec2.prototype.SelfNormalize = function() {
    var t = this.GetLength();
    if (t >= box2d.b2_epsilon) {
        var e = 1 / t;
        this.x *= e, this.y *= e
    }
    return this
}, box2d.b2Vec2.prototype.SelfRotate = function(t, e) {
    var i = this.x,
        o = this.y;
    return this.x = t * i - e * o, this.y = e * i + t * o, this
}, box2d.b2Vec2.prototype.SelfRotateRadians = function(t) {
    return this.SelfRotate(Math.cos(t), Math.sin(t))
}, box2d.b2Vec2.prototype.SelfRotateDegrees = function(t) {
    return this.SelfRotateRadians(box2d.b2DegToRad(t))
}, box2d.b2Vec2.prototype.IsValid = function() {
    return isFinite(this.x) && isFinite(this.y)
}, box2d.b2Vec2.prototype.SelfCrossVS = function(t) {
    var e = this.x;
    return this.x = t * this.y, this.y = -t * e, this
}, box2d.b2Vec2.prototype.SelfCrossSV = function(t) {
    var e = this.x;
    return this.x = -t * this.y, this.y = t * e, this
}, box2d.b2Vec2.prototype.SelfMinV = function(t) {
    return this.x = box2d.b2Min(this.x, t.x), this.y = box2d.b2Min(this.y, t.y), this
}, box2d.b2Vec2.prototype.SelfMaxV = function(t) {
    return this.x = box2d.b2Max(this.x, t.x), this.y = box2d.b2Max(this.y, t.y), this
}, box2d.b2Vec2.prototype.SelfAbs = function() {
    return this.x = box2d.b2Abs(this.x), this.y = box2d.b2Abs(this.y), this
}, box2d.b2Vec2.prototype.SelfNeg = function() {
    return this.x = -this.x, this.y = -this.y, this
}, box2d.b2Vec2.prototype.SelfSkew = function() {
    var t = this.x;
    return this.x = -this.y, this.y = t, this
}, box2d.b2AbsV = function(t, e) {
    return e.x = box2d.b2Abs(t.x), e.y = box2d.b2Abs(t.y), e
}, box2d.b2MinV = function(t, e, i) {
    return i.x = box2d.b2Min(t.x, e.x), i.y = box2d.b2Min(t.y, e.y), i
}, box2d.b2MaxV = function(t, e, i) {
    return i.x = box2d.b2Max(t.x, e.x), i.y = box2d.b2Max(t.y, e.y), i
}, box2d.b2ClampV = function(t, e, i, o) {
    return o.x = box2d.b2Clamp(t.x, e.x, i.x), o.y = box2d.b2Clamp(t.y, e.y, i.y), o
}, box2d.b2RotateV = function(t, e, i, o) {
    var s = t.x,
        n = t.y;
    return o.x = e * s - i * n, o.y = i * s + e * n, o
}, box2d.b2RotateRadiansV = function(t, e, i) {
    return box2d.b2RotateV(t, Math.cos(e), Math.sin(e), i)
}, box2d.b2RotateDegreesV = function(t, e, i) {
    return box2d.b2RotateRadiansV(t, box2d.b2DegToRad(e), i)
}, box2d.b2DotVV = function(t, e) {
    return t.x * e.x + t.y * e.y
}, box2d.b2CrossVV = function(t, e) {
    return t.x * e.y - t.y * e.x
}, box2d.b2CrossVS = function(t, e, i) {
    var o = t.x;
    return i.x = e * t.y, i.y = -e * o, i
}, box2d.b2CrossVOne = function(t, e) {
    var i = t.x;
    return e.x = t.y, e.y = -i, e
}, box2d.b2CrossSV = function(t, e, i) {
    var o = e.x;
    return i.x = -t * e.y, i.y = t * o, i
}, box2d.b2CrossOneV = function(t, e) {
    var i = t.x;
    return e.x = -t.y, e.y = i, e
}, box2d.b2AddVV = function(t, e, i) {
    return i.x = t.x + e.x, i.y = t.y + e.y, i
}, box2d.b2SubVV = function(t, e, i) {
    return i.x = t.x - e.x, i.y = t.y - e.y, i
}, box2d.b2MulSV = function(t, e, i) {
    return i.x = e.x * t, i.y = e.y * t, i
}, box2d.b2AddVMulSV = function(t, e, i, o) {
    return o.x = t.x + e * i.x, o.y = t.y + e * i.y, o
}, box2d.b2SubVMulSV = function(t, e, i, o) {
    return o.x = t.x - e * i.x, o.y = t.y - e * i.y, o
}, box2d.b2AddVCrossSV = function(t, e, i, o) {
    var s = i.x;
    return o.x = t.x - e * i.y, o.y = t.y + e * s, o
}, box2d.b2MidVV = function(t, e, i) {
    return i.x = .5 * (t.x + e.x), i.y = .5 * (t.y + e.y), i
}, box2d.b2ExtVV = function(t, e, i) {
    return i.x = .5 * (e.x - t.x), i.y = .5 * (e.y - t.y), i
}, box2d.b2IsEqualToV = function(t, e) {
    return t.x === e.x && t.y === e.y
}, box2d.b2DistanceVV = function(t, e) {
    var i = t.x - e.x,
        o = t.y - e.y;
    return Math.sqrt(i * i + o * o)
}, box2d.b2DistanceSquaredVV = function(t, e) {
    var i = t.x - e.x,
        o = t.y - e.y;
    return i * i + o * o
}, box2d.b2NegV = function(t, e) {
    return e.x = -t.x, e.y = -t.y, e
}, box2d.b2Vec3 = function(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0
}, box2d.b2Vec3.prototype.x = 0, box2d.b2Vec3.prototype.y = 0, box2d.b2Vec3.prototype.z = 0, box2d.b2Vec3.ZERO = new box2d.b2Vec3, box2d.b2Vec3.s_t0 = new box2d.b2Vec3, box2d.b2Vec3.prototype.Clone = function() {
    return new box2d.b2Vec3(this.x, this.y, this.z)
}, box2d.b2Vec3.prototype.SetZero = function() {
    return this.x = 0, this.y = 0, this.z = 0, this
}, box2d.b2Vec3.prototype.SetXYZ = function(t, e, i) {
    return this.x = t, this.y = e, this.z = i, this
}, box2d.b2Vec3.prototype.Copy = function(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this
}, box2d.b2Vec3.prototype.SelfNeg = function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
}, box2d.b2Vec3.prototype.SelfAdd = function(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this
}, box2d.b2Vec3.prototype.SelfAddXYZ = function(t, e, i) {
    return this.x += t, this.y += e, this.z += i, this
}, box2d.b2Vec3.prototype.SelfSub = function(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
}, box2d.b2Vec3.prototype.SelfSubXYZ = function(t, e, i) {
    return this.x -= t, this.y -= e, this.z -= i, this
}, box2d.b2Vec3.prototype.SelfMul = function(t) {
    return this.x *= t, this.y *= t, this.z *= t, this
}, box2d.b2DotV3V3 = function(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z
}, box2d.b2CrossV3V3 = function(t, e, i) {
    var o = t.x,
        s = t.y,
        n = t.z,
        r = e.x,
        a = e.y,
        h = e.z;
    return i.x = s * h - n * a, i.y = n * r - o * h, i.z = o * a - s * r, i
}, box2d.b2Mat22 = function() {
    this.ex = new box2d.b2Vec2(1, 0), this.ey = new box2d.b2Vec2(0, 1)
}, box2d.b2Mat22.prototype.ex = null, box2d.b2Mat22.prototype.ey = null, box2d.b2Mat22.IDENTITY = new box2d.b2Mat22, box2d.b2Mat22.prototype.Clone = function() {
    return (new box2d.b2Mat22).Copy(this)
}, box2d.b2Mat22.FromVV = function(t, e) {
    return (new box2d.b2Mat22).SetVV(t, e)
}, box2d.b2Mat22.FromSSSS = function(t, e, i, o) {
    return (new box2d.b2Mat22).SetSSSS(t, e, i, o)
}, box2d.b2Mat22.FromAngleRadians = function(t) {
    return (new box2d.b2Mat22).SetAngleRadians(t)
}, box2d.b2Mat22.prototype.SetSSSS = function(t, e, i, o) {
    return this.ex.SetXY(t, i), this.ey.SetXY(e, o), this
}, box2d.b2Mat22.prototype.SetVV = function(t, e) {
    return this.ex.Copy(t), this.ey.Copy(e), this
}, box2d.b2Mat22.prototype.SetAngle = function(t) {
    var e = Math.cos(t),
        i = Math.sin(t);
    return this.ex.SetXY(e, i), this.ey.SetXY(-i, e), this
}, box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle, box2d.b2Mat22.prototype.SetAngleDegrees = function(t) {
    return this.SetAngle(box2d.b2DegToRad(t))
}, box2d.b2Mat22.prototype.Copy = function(t) {
    return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this
}, box2d.b2Mat22.prototype.SetIdentity = function() {
    return this.ex.SetXY(1, 0), this.ey.SetXY(0, 1), this
}, box2d.b2Mat22.prototype.SetZero = function() {
    return this.ex.SetZero(), this.ey.SetZero(), this
}, box2d.b2Mat22.prototype.GetAngle = function() {
    return Math.atan2(this.ex.y, this.ex.x)
}, box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle, box2d.b2Mat22.prototype.GetInverse = function(t) {
    var e = this.ex.x,
        i = this.ey.x,
        o = this.ex.y,
        s = this.ey.y,
        n = e * s - i * o;
    return 0 !== n && (n = 1 / n), t.ex.x = n * s, t.ey.x = -n * i, t.ex.y = -n * o, t.ey.y = n * e, t
}, box2d.b2Mat22.prototype.Solve = function(t, e, i) {
    var o = this.ex.x,
        s = this.ey.x,
        n = this.ex.y,
        r = this.ey.y,
        a = o * r - s * n;
    return 0 !== a && (a = 1 / a), i.x = a * (r * t - s * e), i.y = a * (o * e - n * t), i
}, box2d.b2Mat22.prototype.SelfAbs = function() {
    return this.ex.SelfAbs(), this.ey.SelfAbs(), this
}, box2d.b2Mat22.prototype.SelfInv = function() {
    return this.GetInverse(this)
}, box2d.b2Mat22.prototype.SelfAddM = function(t) {
    return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this
}, box2d.b2Mat22.prototype.SelfSubM = function(t) {
    return this.ex.SelfSub(t.ex), this.ey.SelfSub(t.ey), this
}, box2d.b2AbsM = function(t, e) {
    var i = t.ex,
        o = t.ey;
    return e.ex.x = box2d.b2Abs(i.x), e.ex.y = box2d.b2Abs(i.y), e.ey.x = box2d.b2Abs(o.x), e.ey.y = box2d.b2Abs(o.y), e
}, box2d.b2MulMV = function(t, e, i) {
    var o = t.ex,
        s = t.ey,
        n = e.x,
        r = e.y;
    return i.x = o.x * n + s.x * r, i.y = o.y * n + s.y * r, i
}, box2d.b2MulTMV = function(t, e, i) {
    var o = t.ex,
        s = t.ey,
        n = e.x,
        r = e.y;
    return i.x = o.x * n + o.y * r, i.y = s.x * n + s.y * r, i
}, box2d.b2AddMM = function(t, e, i) {
    var o = t.ex,
        s = t.ey,
        n = e.ex,
        r = e.ey;
    return i.ex.x = o.x + n.x, i.ex.y = o.y + n.y, i.ey.x = s.x + r.x, i.ey.y = s.y + r.y, i
}, box2d.b2MulMM = function(t, e, i) {
    var o = t.ex.x,
        s = t.ex.y,
        n = t.ey.x,
        r = t.ey.y,
        a = e.ex.x,
        h = e.ex.y,
        l = e.ey.x,
        d = e.ey.y;
    return i.ex.x = o * a + n * h, i.ex.y = s * a + r * h, i.ey.x = o * l + n * d, i.ey.y = s * l + r * d, i
}, box2d.b2MulTMM = function(t, e, i) {
    var o = t.ex.x,
        s = t.ex.y,
        n = t.ey.x,
        r = t.ey.y,
        a = e.ex.x,
        h = e.ex.y,
        l = e.ey.x,
        d = e.ey.y;
    return i.ex.x = o * a + s * h, i.ex.y = n * a + r * h, i.ey.x = o * l + s * d, i.ey.y = n * l + r * d, i
}, box2d.b2Mat33 = function() {
    this.ex = new box2d.b2Vec3(1, 0, 0), this.ey = new box2d.b2Vec3(0, 1, 0), this.ez = new box2d.b2Vec3(0, 0, 1)
}, box2d.b2Mat33.prototype.ex = null, box2d.b2Mat33.prototype.ey = null, box2d.b2Mat33.prototype.ez = null, box2d.b2Mat33.IDENTITY = new box2d.b2Mat33, box2d.b2Mat33.prototype.Clone = function() {
    return (new box2d.b2Mat33).Copy(this)
}, box2d.b2Mat33.prototype.SetVVV = function(t, e, i) {
    return this.ex.Copy(t), this.ey.Copy(e), this.ez.Copy(i), this
}, box2d.b2Mat33.prototype.Copy = function(t) {
    return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this.ez.Copy(t.ez), this
}, box2d.b2Mat33.prototype.SetIdentity = function() {
    return this.ex.SetXYZ(1, 0, 0), this.ey.SetXYZ(0, 1, 0), this.ez.SetXYZ(0, 0, 1), this
}, box2d.b2Mat33.prototype.SetZero = function() {
    return this.ex.SetZero(), this.ey.SetZero(), this.ez.SetZero(), this
}, box2d.b2Mat33.prototype.SelfAddM = function(t) {
    return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this.ez.SelfAdd(t.ez), this
}, box2d.b2Mat33.prototype.Solve33 = function(t, e, i, o) {
    var s = this.ex.x,
        n = this.ex.y,
        r = this.ex.z,
        a = this.ey.x,
        h = this.ey.y,
        l = this.ey.z,
        d = this.ez.x,
        c = this.ez.y,
        u = this.ez.z,
        p = s * (h * u - l * c) + n * (l * d - a * u) + r * (a * c - h * d);
    return 0 !== p && (p = 1 / p), o.x = p * (t * (h * u - l * c) + e * (l * d - a * u) + i * (a * c - h * d)), o.y = p * (s * (e * u - i * c) + n * (i * d - t * u) + r * (t * c - e * d)), o.z = p * (s * (h * i - l * e) + n * (l * t - a * i) + r * (a * e - h * t)), o
}, box2d.b2Mat33.prototype.Solve22 = function(t, e, i) {
    var o = this.ex.x,
        s = this.ey.x,
        n = this.ex.y,
        r = this.ey.y,
        a = o * r - s * n;
    return 0 !== a && (a = 1 / a), i.x = a * (r * t - s * e), i.y = a * (o * e - n * t), i
}, box2d.b2Mat33.prototype.GetInverse22 = function(t) {
    var e = this.ex.x,
        i = this.ey.x,
        o = this.ex.y,
        s = this.ey.y,
        n = e * s - i * o;
    0 !== n && (n = 1 / n), t.ex.x = n * s, t.ey.x = -n * i, t.ex.z = 0, t.ex.y = -n * o, t.ey.y = n * e, t.ey.z = 0, t.ez.x = 0, t.ez.y = 0, t.ez.z = 0
}, box2d.b2Mat33.prototype.GetSymInverse33 = function(t) {
    var e = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
    0 !== e && (e = 1 / e);
    var i = this.ex.x,
        o = this.ey.x,
        s = this.ez.x,
        n = this.ey.y,
        r = this.ez.y,
        a = this.ez.z;
    t.ex.x = e * (n * a - r * r), t.ex.y = e * (s * r - o * a), t.ex.z = e * (o * r - s * n), t.ey.x = t.ex.y, t.ey.y = e * (i * a - s * s), t.ey.z = e * (s * o - i * r), t.ez.x = t.ex.z, t.ez.y = t.ey.z, t.ez.z = e * (i * n - o * o)
}, box2d.b2MulM33V3 = function(t, e, i) {
    var o = e.x,
        s = e.y,
        n = e.z;
    return i.x = t.ex.x * o + t.ey.x * s + t.ez.x * n, i.y = t.ex.y * o + t.ey.y * s + t.ez.y * n, i.z = t.ex.z * o + t.ey.z * s + t.ez.z * n, i
}, box2d.b2MulM33XYZ = function(t, e, i, o, s) {
    return s.x = t.ex.x * e + t.ey.x * i + t.ez.x * o, s.y = t.ex.y * e + t.ey.y * i + t.ez.y * o, s.z = t.ex.z * e + t.ey.z * i + t.ez.z * o, s
}, box2d.b2MulM33V2 = function(t, e, i) {
    var o = e.x,
        s = e.y;
    return i.x = t.ex.x * o + t.ey.x * s, i.y = t.ex.y * o + t.ey.y * s, i
}, box2d.b2MulM33XY = function(t, e, i, o) {
    return o.x = t.ex.x * e + t.ey.x * i, o.y = t.ex.y * e + t.ey.y * i, o
}, box2d.b2Rot = function(t) {
    t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t))
}, box2d.b2Rot.prototype.angle = 0, box2d.b2Rot.prototype.s = 0, box2d.b2Rot.prototype.c = 1, box2d.b2Rot.IDENTITY = new box2d.b2Rot, box2d.b2Rot.prototype.Clone = function() {
    return (new box2d.b2Rot).Copy(this)
}, box2d.b2Rot.prototype.Copy = function(t) {
    return this.angle = t.angle, this.s = t.s, this.c = t.c, this
}, box2d.b2Rot.prototype.SetAngle = function(t) {
    return this.angle !== t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t)), this
}, box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle, box2d.b2Rot.prototype.SetAngleDegrees = function(t) {
    return this.SetAngle(box2d.b2DegToRad(t))
}, box2d.b2Rot.prototype.SetIdentity = function() {
    return this.angle = 0, this.s = 0, this.c = 1, this
}, box2d.b2Rot.prototype.GetAngle = function() {
    return this.angle
}, box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle, box2d.b2Rot.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
}, box2d.b2Rot.prototype.GetXAxis = function(t) {
    return t.x = this.c, t.y = this.s, t
}, box2d.b2Rot.prototype.GetYAxis = function(t) {
    return t.x = -this.s, t.y = this.c, t
}, box2d.b2MulRR = function(t, e, i) {
    var o = t.c,
        s = t.s,
        n = e.c,
        r = e.s;
    for (i.s = s * n + o * r, i.c = o * n - s * r, i.angle = t.angle + e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi;
    for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi;
    return i
}, box2d.b2MulTRR = function(t, e, i) {
    var o = t.c,
        s = t.s,
        n = e.c,
        r = e.s;
    for (i.s = o * r - s * n, i.c = o * n + s * r, i.angle = t.angle - e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi;
    for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi;
    return i
}, box2d.b2MulRV = function(t, e, i) {
    var o = t.c,
        s = t.s,
        n = e.x,
        r = e.y;
    return i.x = o * n - s * r, i.y = s * n + o * r, i
}, box2d.b2MulTRV = function(t, e, i) {
    var o = t.c,
        s = t.s,
        n = e.x,
        r = e.y;
    return i.x = o * n + s * r, i.y = -s * n + o * r, i
}, box2d.b2Transform = function() {
    this.p = new box2d.b2Vec2, this.q = new box2d.b2Rot
}, box2d.b2Transform.prototype.p = null, box2d.b2Transform.prototype.q = null, box2d.b2Transform.IDENTITY = new box2d.b2Transform, box2d.b2Transform.prototype.Clone = function() {
    return (new box2d.b2Transform).Copy(this)
}, box2d.b2Transform.prototype.Copy = function(t) {
    return this.p.Copy(t.p), this.q.Copy(t.q), this
}, box2d.b2Transform.prototype.SetIdentity = function() {
    return this.p.SetZero(), this.q.SetIdentity(), this
}, box2d.b2Transform.prototype.SetPositionRotation = function(t, e) {
    return this.p.Copy(t), this.q.Copy(e), this
}, box2d.b2Transform.prototype.SetPositionAngleRadians = function(t, e) {
    return this.p.Copy(t), this.q.SetAngleRadians(e), this
}, box2d.b2Transform.prototype.SetPosition = function(t) {
    return this.p.Copy(t), this
}, box2d.b2Transform.prototype.SetPositionXY = function(t, e) {
    return this.p.SetXY(t, e), this
}, box2d.b2Transform.prototype.SetRotation = function(t) {
    return this.q.Copy(t), this
}, box2d.b2Transform.prototype.SetRotationAngleRadians = function(t) {
    return this.q.SetAngleRadians(t), this
}, box2d.b2Transform.prototype.GetPosition = function() {
    return this.p
}, box2d.b2Transform.prototype.GetRotation = function() {
    return this.q
}, box2d.b2Transform.prototype.GetRotationAngle = function() {
    return this.q.GetAngle()
}, box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle, box2d.b2Transform.prototype.GetAngle = function() {
    return this.q.GetAngle()
}, box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle, box2d.b2MulXV = function(t, e, i) {
    var o = t.q.c,
        s = t.q.s,
        n = e.x,
        r = e.y;
    return i.x = o * n - s * r + t.p.x, i.y = s * n + o * r + t.p.y, i
}, box2d.b2MulTXV = function(t, e, i) {
    var o = t.q.c,
        s = t.q.s,
        n = e.x - t.p.x,
        r = e.y - t.p.y;
    return i.x = o * n + s * r, i.y = -s * n + o * r, i
}, box2d.b2MulXX = function(t, e, i) {
    return box2d.b2MulRR(t.q, e.q, i.q), box2d.b2AddVV(box2d.b2MulRV(t.q, e.p, i.p), t.p, i.p), i
}, box2d.b2MulTXX = function(t, e, i) {
    return box2d.b2MulTRR(t.q, e.q, i.q), box2d.b2MulTRV(t.q, box2d.b2SubVV(e.p, t.p, i.p), i.p), i
}, box2d.b2Sweep = function() {
    this.localCenter = new box2d.b2Vec2, this.c0 = new box2d.b2Vec2, this.c = new box2d.b2Vec2
}, box2d.b2Sweep.prototype.localCenter = null, box2d.b2Sweep.prototype.c0 = null, box2d.b2Sweep.prototype.c = null, box2d.b2Sweep.prototype.a0 = 0, box2d.b2Sweep.prototype.a = 0, box2d.b2Sweep.prototype.alpha0 = 0, box2d.b2Sweep.prototype.Clone = function() {
    return (new box2d.b2Sweep).Copy(this)
}, box2d.b2Sweep.prototype.Copy = function(t) {
    return this.localCenter.Copy(t.localCenter), this.c0.Copy(t.c0), this.c.Copy(t.c), this.a0 = t.a0, this.a = t.a, this.alpha0 = t.alpha0, this
}, box2d.b2Sweep.prototype.GetTransform = function(t, e) {
    var i = 1 - e;
    t.p.x = i * this.c0.x + e * this.c.x, t.p.y = i * this.c0.y + e * this.c.y;
    var o = i * this.a0 + e * this.a;
    return t.q.SetAngleRadians(o), t.p.SelfSub(box2d.b2MulRV(t.q, this.localCenter, box2d.b2Vec2.s_t0)), t
}, box2d.b2Sweep.prototype.Advance = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.alpha0 < 1);
    var e = (t - this.alpha0) / (1 - this.alpha0);
    this.c0.x += e * (this.c.x - this.c0.x), this.c0.y += e * (this.c.y - this.c0.y), this.a0 += e * (this.a - this.a0), this.alpha0 = t
}, box2d.b2Sweep.prototype.Normalize = function() {
    var t = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
    this.a0 -= t, this.a -= t
}, goog.provide("box2d.b2Controller"), goog.require("box2d.b2Settings"), box2d.b2ControllerEdge = function() {}, box2d.b2ControllerEdge.prototype.controller = null, box2d.b2ControllerEdge.prototype.body = null, box2d.b2ControllerEdge.prototype.prevBody = null, box2d.b2ControllerEdge.prototype.nextBody = null, box2d.b2ControllerEdge.prototype.prevController = null, box2d.b2ControllerEdge.prototype.nextController = null, box2d.b2Controller = function() {}, box2d.b2Controller.prototype.m_world = null, box2d.b2Controller.prototype.m_bodyList = null, box2d.b2Controller.prototype.m_bodyCount = 0, box2d.b2Controller.prototype.m_prev = null, box2d.b2Controller.prototype.m_next = null, box2d.b2Controller.prototype.Step = function() {}, box2d.b2Controller.prototype.Draw = function() {}, box2d.b2Controller.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Controller.prototype.GetPrev = function() {
    return this.m_prev
}, box2d.b2Controller.prototype.GetWorld = function() {
    return this.m_world
}, box2d.b2Controller.prototype.GetBodyList = function() {
    return this.m_bodyList
}, box2d.b2Controller.prototype.AddBody = function(t) {
    var e = new box2d.b2ControllerEdge;
    e.body = t, e.controller = this, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList && (this.m_bodyList.prevBody = e), this.m_bodyList = e, ++this.m_bodyCount, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList && (t.m_controllerList.prevController = e), t.m_controllerList = e, ++t.m_controllerCount
}, box2d.b2Controller.prototype.RemoveBody = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    for (var e = this.m_bodyList; e && e.body !== t;) e = e.nextBody;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== e), e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), this.m_bodyList === e && (this.m_bodyList = e.nextBody), --this.m_bodyCount, e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), t.m_controllerList === e && (t.m_controllerList = e.nextController), --t.m_controllerCount
}, box2d.b2Controller.prototype.Clear = function() {
    for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body);
    this.m_bodyCount = 0
}, goog.provide("box2d.b2ConstantAccelController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantAccelController = function() {
    goog.base(this), this.A = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.A = null, box2d.b2ConstantAccelController.prototype.Step = function(t) {
    for (var e = box2d.b2MulSV(t.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA), i = this.m_bodyList; i; i = i.nextBody) {
        var o = i.body;
        o.IsAwake() && o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), e, box2d.b2Vec2.s_t0))
    }
}, box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2, goog.provide("box2d.b2Joint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2JointType = {
    e_unknownJoint: 0,
    e_revoluteJoint: 1,
    e_prismaticJoint: 2,
    e_distanceJoint: 3,
    e_pulleyJoint: 4,
    e_mouseJoint: 5,
    e_gearJoint: 6,
    e_wheelJoint: 7,
    e_weldJoint: 8,
    e_frictionJoint: 9,
    e_ropeJoint: 10,
    e_motorJoint: 11,
    e_areaJoint: 12
}, goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint), goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint), goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint), goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint), goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint), goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint), goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint), goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint), goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint), goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint), goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint), goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint), goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint), box2d.b2LimitState = {
    e_inactiveLimit: 0,
    e_atLowerLimit: 1,
    e_atUpperLimit: 2,
    e_equalLimits: 3
}, goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit), goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit), goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit), goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits), box2d.b2Jacobian = function() {
    this.linear = new box2d.b2Vec2
}, box2d.b2Jacobian.prototype.linear = null, box2d.b2Jacobian.prototype.angularA = 0, box2d.b2Jacobian.prototype.angularB = 0, box2d.b2Jacobian.prototype.SetZero = function() {
    return this.linear.SetZero(), this.angularA = 0, this.angularB = 0, this
}, box2d.b2Jacobian.prototype.Set = function(t, e, i) {
    return this.linear.Copy(t), this.angularA = e, this.angularB = i, this
}, box2d.b2JointEdge = function() {}, box2d.b2JointEdge.prototype.other = null, box2d.b2JointEdge.prototype.joint = null, box2d.b2JointEdge.prototype.prev = null, box2d.b2JointEdge.prototype.next = null, box2d.b2JointDef = function(t) {
    this.type = t
}, box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint, box2d.b2JointDef.prototype.userData = null, box2d.b2JointDef.prototype.bodyA = null, box2d.b2JointDef.prototype.bodyB = null, box2d.b2JointDef.prototype.collideConnected = !1, box2d.b2Joint = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(t.bodyA !== t.bodyB), this.m_type = t.type, this.m_edgeA = new box2d.b2JointEdge, this.m_edgeB = new box2d.b2JointEdge, this.m_bodyA = t.bodyA, this.m_bodyB = t.bodyB, this.m_collideConnected = t.collideConnected, this.m_userData = t.userData
}, box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint, box2d.b2Joint.prototype.m_prev = null, box2d.b2Joint.prototype.m_next = null, box2d.b2Joint.prototype.m_edgeA = null, box2d.b2Joint.prototype.m_edgeB = null, box2d.b2Joint.prototype.m_bodyA = null, box2d.b2Joint.prototype.m_bodyB = null, box2d.b2Joint.prototype.m_index = 0, box2d.b2Joint.prototype.m_islandFlag = !1, box2d.b2Joint.prototype.m_collideConnected = !1, box2d.b2Joint.prototype.m_userData = null, box2d.b2Joint.prototype.GetAnchorA = function(t) {
    return t.SetZero()
}, box2d.b2Joint.prototype.GetAnchorB = function(t) {
    return t.SetZero()
}, box2d.b2Joint.prototype.GetReactionForce = function(t, e) {
    return e.SetZero()
}, box2d.b2Joint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2Joint.prototype.InitVelocityConstraints = function() {}, box2d.b2Joint.prototype.SolveVelocityConstraints = function() {}, box2d.b2Joint.prototype.SolvePositionConstraints = function() {
    return !1
}, box2d.b2Joint.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Joint.prototype.GetBodyA = function() {
    return this.m_bodyA
}, box2d.b2Joint.prototype.GetBodyB = function() {
    return this.m_bodyB
}, box2d.b2Joint.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Joint.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Joint.prototype.SetUserData = function(t) {
    this.m_userData = t
}, box2d.b2Joint.prototype.GetCollideConnected = function() {
    return this.m_collideConnected
}, box2d.b2Joint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("// Dump is not supported for this joint type.\n")
}, box2d.b2Joint.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
}, box2d.b2Joint.prototype.ShiftOrigin = function() {}, goog.provide("box2d.b2RevoluteJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RevoluteJointDef = function() {
    goog.base(this, box2d.b2JointType.e_revoluteJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef), box2d.b2RevoluteJointDef.prototype.localAnchorA = null, box2d.b2RevoluteJointDef.prototype.localAnchorB = null, box2d.b2RevoluteJointDef.prototype.referenceAngle = 0, box2d.b2RevoluteJointDef.prototype.enableLimit = !1, box2d.b2RevoluteJointDef.prototype.lowerAngle = 0, box2d.b2RevoluteJointDef.prototype.upperAngle = 0, box2d.b2RevoluteJointDef.prototype.enableMotor = !1, box2d.b2RevoluteJointDef.prototype.motorSpeed = 0, box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0, box2d.b2RevoluteJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2RevoluteJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec3, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = box2d.b2LimitState.e_inactiveLimit
}, goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint), box2d.b2RevoluteJoint.prototype.m_localAnchorA = null, box2d.b2RevoluteJoint.prototype.m_localAnchorB = null, box2d.b2RevoluteJoint.prototype.m_impulse = null, box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0, box2d.b2RevoluteJoint.prototype.m_enableMotor = !1, box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0, box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0, box2d.b2RevoluteJoint.prototype.m_enableLimit = !1, box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0, box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0, box2d.b2RevoluteJoint.prototype.m_upperAngle = 0, box2d.b2RevoluteJoint.prototype.m_indexA = 0, box2d.b2RevoluteJoint.prototype.m_indexB = 0, box2d.b2RevoluteJoint.prototype.m_rA = null, box2d.b2RevoluteJoint.prototype.m_rB = null, box2d.b2RevoluteJoint.prototype.m_localCenterA = null, box2d.b2RevoluteJoint.prototype.m_localCenterB = null, box2d.b2RevoluteJoint.prototype.m_invMassA = 0, box2d.b2RevoluteJoint.prototype.m_invMassB = 0, box2d.b2RevoluteJoint.prototype.m_invIA = 0, box2d.b2RevoluteJoint.prototype.m_invIB = 0, box2d.b2RevoluteJoint.prototype.m_mass = null, box2d.b2RevoluteJoint.prototype.m_motorMass = 0, box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2RevoluteJoint.prototype.m_qA = null, box2d.b2RevoluteJoint.prototype.m_qB = null, box2d.b2RevoluteJoint.prototype.m_lalcA = null, box2d.b2RevoluteJoint.prototype.m_lalcB = null, box2d.b2RevoluteJoint.prototype.m_K = null, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB);
    var l = this.m_invMassA,
        d = this.m_invMassB,
        c = this.m_invIA,
        u = this.m_invIB,
        p = c + u === 0;
    if (this.m_mass.ex.x = l + d + this.m_rA.y * this.m_rA.y * c + this.m_rB.y * this.m_rB.y * u, this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * c - this.m_rB.y * this.m_rB.x * u, this.m_mass.ez.x = -this.m_rA.y * c - this.m_rB.y * u, this.m_mass.ex.y = this.m_mass.ey.x, this.m_mass.ey.y = l + d + this.m_rA.x * this.m_rA.x * c + this.m_rB.x * this.m_rB.x * u, this.m_mass.ez.y = this.m_rA.x * c + this.m_rB.x * u, this.m_mass.ex.z = this.m_mass.ez.x, this.m_mass.ey.z = this.m_mass.ez.y, this.m_mass.ez.z = c + u, this.m_motorMass = c + u, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass), (!1 === this.m_enableMotor || p) && (this.m_motorImpulse = 0), this.m_enableLimit && !1 === p) {
        var b = s - e - this.m_referenceAngle;
        box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : b <= this.m_lowerAngle ? (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : b >= this.m_upperAngle ? (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0)
    } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
    if (t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio;
        var m = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, m), o -= c * (box2d.b2CrossVV(this.m_rA, m) + this.m_motorImpulse + this.m_impulse.z), n.SelfMulAdd(d, m), r += u * (box2d.b2CrossVV(this.m_rB, m) + this.m_motorImpulse + this.m_impulse.z)
    } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = a + h === 0;
    if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits && !1 === l) {
        var d = s - i - this.m_motorSpeed,
            c = -this.m_motorMass * d,
            u = this.m_motorImpulse,
            p = t.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + c, -p, p), i -= a * (c = this.m_motorImpulse - u), s += h * c
    }
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) {
        var b = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            m = s - i;
        c = this.m_mass.Solve33(b.x, b.y, m, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg();
        if (this.m_limitState === box2d.b2LimitState.e_equalLimits) this.m_impulse.SelfAdd(c);
        else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit) {
            if (this.m_impulse.z + c.z < 0) {
                var y = -b.x + this.m_impulse.z * this.m_mass.ez.x,
                    f = -b.y + this.m_impulse.z * this.m_mass.ez.y,
                    x = this.m_mass.Solve22(y, f, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                c.x = x.x, c.y = x.y, c.z = -this.m_impulse.z, this.m_impulse.x += x.x, this.m_impulse.y += x.y, this.m_impulse.z = 0
            } else this.m_impulse.SelfAdd(c)
        } else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit) {
            if (0 < this.m_impulse.z + c.z) {
                y = -b.x + this.m_impulse.z * this.m_mass.ez.x, f = -b.y + this.m_impulse.z * this.m_mass.ez.y, x = this.m_mass.Solve22(y, f, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                c.x = x.x, c.y = x.y, c.z = -this.m_impulse.z, this.m_impulse.x += x.x, this.m_impulse.y += x.y, this.m_impulse.z = 0
            } else this.m_impulse.SelfAdd(c)
        }
        var g = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(c.x, c.y);
        e.SelfMulSub(n, g), i -= a * (box2d.b2CrossVV(this.m_rA, g) + c.z), o.SelfMulAdd(r, g), s += h * (box2d.b2CrossVV(this.m_rB, g) + c.z)
    } else {
        d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot), c = this.m_mass.Solve22(-d.x, -d.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2);
        this.m_impulse.x += c.x, this.m_impulse.y += c.y, e.SelfMulSub(n, c), i -= a * box2d.b2CrossVV(this.m_rA, c), o.SelfMulAdd(r, c), s += h * box2d.b2CrossVV(this.m_rB, c)
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(t) {
    var e, i = t.positions[this.m_indexA].c,
        o = t.positions[this.m_indexA].a,
        s = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        r = this.m_qA.SetAngleRadians(o),
        a = this.m_qB.SetAngleRadians(n),
        h = 0,
        l = this.m_invIA + this.m_invIB === 0;
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) {
        var d = n - o - this.m_referenceAngle,
            c = 0;
        if (this.m_limitState === box2d.b2LimitState.e_equalLimits) {
            var u = box2d.b2Clamp(d - this.m_lowerAngle, -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection);
            c = -this.m_motorMass * u, h = box2d.b2Abs(u)
        } else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit) {
            h = -(u = d - this.m_lowerAngle), u = box2d.b2Clamp(u + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), c = -this.m_motorMass * u
        } else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit) {
            h = u = d - this.m_upperAngle, u = box2d.b2Clamp(u - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), c = -this.m_motorMass * u
        }
        o -= this.m_invIA * c, n += this.m_invIB * c
    }
    r.SetAngleRadians(o), a.SetAngleRadians(n), box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var p = box2d.b2MulRV(r, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var b = box2d.b2MulRV(a, this.m_lalcB, this.m_rB);
    e = (u = box2d.b2SubVV(box2d.b2AddVV(s, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(i, p, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C)).GetLength();
    var m = this.m_invMassA,
        y = this.m_invMassB,
        f = this.m_invIA,
        x = this.m_invIB,
        g = this.m_K;
    g.ex.x = m + y + f * p.y * p.y + x * b.y * b.y, g.ex.y = -f * p.x * p.y - x * b.x * b.y, g.ey.x = g.ex.y, g.ey.y = m + y + f * p.x * p.x + x * b.x * b.x;
    var _ = g.Solve(u.x, u.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
    return i.SelfMulSub(m, _), o -= f * box2d.b2CrossVV(p, _), s.SelfMulAdd(y, _), n += x * box2d.b2CrossVV(b, _), t.positions[this.m_indexA].a = o, t.positions[this.m_indexB].a = n, e <= box2d.b2_linearSlop && h <= box2d.b2_angularSlop
}, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2RevoluteJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2RevoluteJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y)
}, box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.z
}, box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
}, box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
}, box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
}, box2d.b2RevoluteJoint.prototype.EnableMotor = function(t) {
    this.m_enableMotor !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t)
}, box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
}, box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(t) {
    this.m_maxMotorTorque = t
}, box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
}, box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
}, box2d.b2RevoluteJoint.prototype.EnableLimit = function(t) {
    t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0)
}, box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle
}, box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() {
    return this.m_upperAngle
}, box2d.b2RevoluteJoint.prototype.SetLimits = function(t, e) {
    (t !== this.m_lowerAngle || e !== this.m_upperAngle) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = t, this.m_upperAngle = e)
}, box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(t) {
    this.m_motorSpeed !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t)
}, box2d.b2RevoluteJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false"), box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle), box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2PrismaticJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2PrismaticJointDef = function() {
    goog.base(this, box2d.b2JointType.e_prismaticJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2, this.localAxisA = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef), box2d.b2PrismaticJointDef.prototype.localAnchorA = null, box2d.b2PrismaticJointDef.prototype.localAnchorB = null, box2d.b2PrismaticJointDef.prototype.localAxisA = null, box2d.b2PrismaticJointDef.prototype.referenceAngle = 0, box2d.b2PrismaticJointDef.prototype.enableLimit = !1, box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0, box2d.b2PrismaticJointDef.prototype.upperTranslation = 0, box2d.b2PrismaticJointDef.prototype.enableMotor = !1, box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0, box2d.b2PrismaticJointDef.prototype.motorSpeed = 0, box2d.b2PrismaticJointDef.prototype.Initialize = function(t, e, i, o) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2PrismaticJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone().SelfNormalize(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2(0, 0), this.m_perp = new box2d.b2Vec2(0, 0), this.m_K = new box2d.b2Mat33, this.m_K3 = new box2d.b2Mat33, this.m_K2 = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2
}, goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint), box2d.b2PrismaticJoint.prototype.m_localAnchorA = null, box2d.b2PrismaticJoint.prototype.m_localAnchorB = null, box2d.b2PrismaticJoint.prototype.m_localXAxisA = null, box2d.b2PrismaticJoint.prototype.m_localYAxisA = null, box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0, box2d.b2PrismaticJoint.prototype.m_impulse = null, box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0, box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0, box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0, box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0, box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0, box2d.b2PrismaticJoint.prototype.m_enableLimit = !1, box2d.b2PrismaticJoint.prototype.m_enableMotor = !1, box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2PrismaticJoint.prototype.m_indexA = 0, box2d.b2PrismaticJoint.prototype.m_indexB = 0, box2d.b2PrismaticJoint.prototype.m_localCenterA = null, box2d.b2PrismaticJoint.prototype.m_localCenterB = null, box2d.b2PrismaticJoint.prototype.m_invMassA = 0, box2d.b2PrismaticJoint.prototype.m_invMassB = 0, box2d.b2PrismaticJoint.prototype.m_invIA = 0, box2d.b2PrismaticJoint.prototype.m_invIB = 0, box2d.b2PrismaticJoint.prototype.m_axis = null, box2d.b2PrismaticJoint.prototype.m_perp = null, box2d.b2PrismaticJoint.prototype.m_s1 = 0, box2d.b2PrismaticJoint.prototype.m_s2 = 0, box2d.b2PrismaticJoint.prototype.m_a1 = 0, box2d.b2PrismaticJoint.prototype.m_a2 = 0, box2d.b2PrismaticJoint.prototype.m_K = null, box2d.b2PrismaticJoint.prototype.m_K3 = null, box2d.b2PrismaticJoint.prototype.m_K2 = null, box2d.b2PrismaticJoint.prototype.m_motorMass = 0, box2d.b2PrismaticJoint.prototype.m_qA = null, box2d.b2PrismaticJoint.prototype.m_qB = null, box2d.b2PrismaticJoint.prototype.m_lalcA = null, box2d.b2PrismaticJoint.prototype.m_lalcB = null, box2d.b2PrismaticJoint.prototype.m_rA = null, box2d.b2PrismaticJoint.prototype.m_rB = null, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var c = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var u = box2d.b2MulRV(d, this.m_lalcB, this.m_rB),
        p = box2d.b2AddVV(box2d.b2SubVV(n, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(u, c, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d),
        b = this.m_invMassA,
        m = this.m_invMassB,
        y = this.m_invIA,
        f = this.m_invIB;
    if (box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis), this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(p, c, box2d.b2Vec2.s_t0), this.m_axis), this.m_a2 = box2d.b2CrossVV(u, this.m_axis), this.m_motorMass = b + m + y * this.m_a1 * this.m_a1 + f * this.m_a2 * this.m_a2, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass), box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp), this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(p, c, box2d.b2Vec2.s_t0), this.m_perp), this.m_s2 = box2d.b2CrossVV(u, this.m_perp), this.m_K.ex.x = b + m + y * this.m_s1 * this.m_s1 + f * this.m_s2 * this.m_s2, this.m_K.ex.y = y * this.m_s1 + f * this.m_s2, this.m_K.ex.z = y * this.m_s1 * this.m_a1 + f * this.m_s2 * this.m_a2, this.m_K.ey.x = this.m_K.ex.y, this.m_K.ey.y = y + f, 0 === this.m_K.ey.y && (this.m_K.ey.y = 1), this.m_K.ey.z = y * this.m_a1 + f * this.m_a2, this.m_K.ez.x = this.m_K.ex.z, this.m_K.ez.y = this.m_K.ey.z, this.m_K.ez.z = b + m + y * this.m_a1 * this.m_a1 + f * this.m_a2 * this.m_a2, this.m_enableLimit) {
        var x = box2d.b2DotVV(this.m_axis, p);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : x <= this.m_lowerTranslation ? this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : x >= this.m_upperTranslation ? this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0)
    } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0;
    if (!1 === this.m_enableMotor && (this.m_motorImpulse = 0), t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio;
        var g = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P),
            _ = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
            v = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
        o.SelfMulSub(b, g), s -= y * _, a.SelfMulAdd(m, g), h += f * v
    } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB;
    if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits) {
        var l = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * s - this.m_a1 * i,
            d = this.m_motorMass * (this.m_motorSpeed - l),
            c = this.m_motorImpulse,
            u = t.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + d, -u, u), d = this.m_motorImpulse - c;
        var p = box2d.b2MulSV(d, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            b = d * this.m_a1,
            m = d * this.m_a2;
        e.SelfMulSub(n, p), i -= a * b, o.SelfMulAdd(r, p), s += h * m
    }
    var y = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_s2 * s - this.m_s1 * i,
        f = s - i;
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit) {
        var x = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * s - this.m_a1 * i,
            g = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse),
            _ = this.m_K.Solve33(-y, -f, -x, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3);
        this.m_impulse.SelfAdd(_), this.m_limitState === box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState === box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0));
        var v = -y - (this.m_impulse.z - g.z) * this.m_K.ez.x,
            S = -f - (this.m_impulse.z - g.z) * this.m_K.ez.y,
            C = this.m_K.Solve22(v, S, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r);
        C.x += g.x, C.y += g.y, this.m_impulse.x = C.x, this.m_impulse.y = C.y, _.x = this.m_impulse.x - g.x, _.y = this.m_impulse.y - g.y, _.z = this.m_impulse.z - g.z;
        p = box2d.b2AddVV(box2d.b2MulSV(_.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(_.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), b = _.x * this.m_s1 + _.y + _.z * this.m_a1, m = _.x * this.m_s2 + _.y + _.z * this.m_a2;
        e.SelfMulSub(n, p), i -= a * b, o.SelfMulAdd(r, p), s += h * m
    } else {
        _ = this.m_K.Solve22(-y, -f, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2);
        this.m_impulse.x += _.x, this.m_impulse.y += _.y;
        p = box2d.b2MulSV(_.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), b = _.x * this.m_s1 + _.y, m = _.x * this.m_s2 + _.y;
        e.SelfMulSub(n, p), i -= a * b, o.SelfMulAdd(r, p), s += h * m
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        d = this.m_invIB,
        c = box2d.b2MulRV(n, this.m_lalcA, this.m_rA),
        u = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        p = box2d.b2SubVV(box2d.b2AddVV(o, u, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
        b = box2d.b2MulRV(n, this.m_localXAxisA, this.m_axis),
        m = box2d.b2CrossVV(box2d.b2AddVV(p, c, box2d.b2Vec2.s_t0), b),
        y = box2d.b2CrossVV(u, b),
        f = box2d.b2MulRV(n, this.m_localYAxisA, this.m_perp),
        x = box2d.b2CrossVV(box2d.b2AddVV(p, c, box2d.b2Vec2.s_t0), f),
        g = box2d.b2CrossVV(u, f),
        _ = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse,
        v = box2d.b2DotVV(f, p),
        S = s - i - this.m_referenceAngle,
        C = box2d.b2Abs(v),
        w = box2d.b2Abs(S),
        A = !1,
        P = 0;
    if (this.m_enableLimit) {
        var T = box2d.b2DotVV(b, p);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (P = box2d.b2Clamp(T, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, box2d.b2Abs(T)), A = !0) : T <= this.m_lowerTranslation ? (P = box2d.b2Clamp(T - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), C = box2d.b2Max(C, this.m_lowerTranslation - T), A = !0) : T >= this.m_upperTranslation && (P = box2d.b2Clamp(T - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, T - this.m_upperTranslation), A = !0)
    }
    if (A) {
        var B = a + h + l * x * x + d * g * g,
            M = l * x + d * g,
            E = l * x * m + d * g * y;
        0 === (L = l + d) && (L = 1);
        var I = l * m + d * y,
            V = a + h + l * m * m + d * y * y,
            R = this.m_K3;
        R.ex.SetXYZ(B, M, E), R.ey.SetXYZ(M, L, I), R.ez.SetXYZ(E, I, V), _ = R.Solve33(-v, -S, -P, _)
    } else {
        var L;
        B = a + h + l * x * x + d * g * g, M = l * x + d * g;
        0 === (L = l + d) && (L = 1);
        var D = this.m_K2;
        D.ex.SetXY(B, M), D.ey.SetXY(M, L);
        var F = D.Solve(-v, -S, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1);
        _.x = F.x, _.y = F.y, _.z = 0
    }
    var k = box2d.b2AddVV(box2d.b2MulSV(_.x, f, box2d.b2Vec2.s_t0), box2d.b2MulSV(_.z, b, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P),
        G = _.x * x + _.y + _.z * m,
        O = _.x * g + _.y + _.z * y;
    return e.SelfMulSub(a, k), i -= l * G, o.SelfMulAdd(h, k), s += d * O, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, C <= box2d.b2_linearSlop && w <= box2d.b2_angularSlop
}, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2PrismaticJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2PrismaticJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
}, box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.y
}, box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(t) {
    return t.Copy(this.m_localXAxisA)
}, box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() {
    var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA),
        e = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB),
        i = box2d.b2SubVV(e, t, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d),
        o = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);
    return box2d.b2DotVV(i, o)
}, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() {
    var t = this.m_bodyA,
        e = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, t.m_sweep.localCenter, this.m_lalcA);
    var i = box2d.b2MulRV(t.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, e.m_sweep.localCenter, this.m_lalcB);
    var o = box2d.b2MulRV(e.m_xf.q, this.m_lalcB, this.m_rB),
        s = box2d.b2AddVV(t.m_sweep.c, i, box2d.b2Vec2.s_t0),
        n = box2d.b2AddVV(e.m_sweep.c, o, box2d.b2Vec2.s_t1),
        r = box2d.b2SubVV(n, s, box2d.b2Vec2.s_t2),
        a = t.GetWorldVector(this.m_localXAxisA, this.m_axis),
        h = t.m_linearVelocity,
        l = e.m_linearVelocity,
        d = t.m_angularVelocity,
        c = e.m_angularVelocity;
    return box2d.b2DotVV(r, box2d.b2CrossSV(d, a, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(a, box2d.b2SubVV(box2d.b2AddVCrossSV(l, c, o, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(h, d, i, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))
}, box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
}, box2d.b2PrismaticJoint.prototype.EnableLimit = function(t) {
    t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0)
}, box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation
}, box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation
}, box2d.b2PrismaticJoint.prototype.SetLimits = function(t, e) {
    (t !== this.m_lowerTranslation || e !== this.m_upperTranslation) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e, this.m_impulse.z = 0)
}, box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
}, box2d.b2PrismaticJoint.prototype.EnableMotor = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
}, box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
}, box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
}, box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
}, box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce
}, box2d.b2PrismaticJoint.prototype.GetMotorForce = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2PrismaticJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false"), box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation), box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2GearJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2PrismaticJoint"), box2d.b2GearJointDef = function() {
    goog.base(this, box2d.b2JointType.e_gearJoint)
}, goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef), box2d.b2GearJointDef.prototype.joint1 = null, box2d.b2GearJointDef.prototype.joint2 = null, box2d.b2GearJointDef.prototype.ratio = 1, box2d.b2GearJoint = function(t) {
    var e, i;
    goog.base(this, t), this.m_joint1 = t.joint1, this.m_joint2 = t.joint2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_localAnchorC = new box2d.b2Vec2, this.m_localAnchorD = new box2d.b2Vec2, this.m_localAxisC = new box2d.b2Vec2, this.m_localAxisD = new box2d.b2Vec2, this.m_lcA = new box2d.b2Vec2, this.m_lcB = new box2d.b2Vec2, this.m_lcC = new box2d.b2Vec2, this.m_lcD = new box2d.b2Vec2, this.m_JvAC = new box2d.b2Vec2, this.m_JvBD = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_qC = new box2d.b2Rot, this.m_qD = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_lalcC = new box2d.b2Vec2, this.m_lalcD = new box2d.b2Vec2, this.m_typeA = this.m_joint1.GetType(), this.m_typeB = this.m_joint2.GetType(), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeA === box2d.b2JointType.e_revoluteJoint || this.m_typeA === box2d.b2JointType.e_prismaticJoint), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeB === box2d.b2JointType.e_revoluteJoint || this.m_typeB === box2d.b2JointType.e_prismaticJoint), this.m_bodyC = this.m_joint1.GetBodyA(), this.m_bodyA = this.m_joint1.GetBodyB();
    var o = this.m_bodyA.m_xf,
        s = this.m_bodyA.m_sweep.a,
        n = this.m_bodyC.m_xf,
        r = this.m_bodyC.m_sweep.a;
    if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) {
        var a = t.joint1;
        this.m_localAnchorC.Copy(a.m_localAnchorA), this.m_localAnchorA.Copy(a.m_localAnchorB), this.m_referenceAngleA = a.m_referenceAngle, this.m_localAxisC.SetZero(), e = s - r - this.m_referenceAngleA
    } else {
        var h = t.joint1;
        this.m_localAnchorC.Copy(h.m_localAnchorA), this.m_localAnchorA.Copy(h.m_localAnchorB), this.m_referenceAngleA = h.m_referenceAngle, this.m_localAxisC.Copy(h.m_localXAxisA);
        var l = this.m_localAnchorC,
            d = box2d.b2MulTRV(n.q, box2d.b2AddVV(box2d.b2MulRV(o.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(o.p, n.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    this.m_bodyD = this.m_joint2.GetBodyA(), this.m_bodyB = this.m_joint2.GetBodyB();
    var c = this.m_bodyB.m_xf,
        u = this.m_bodyB.m_sweep.a,
        p = this.m_bodyD.m_xf,
        b = this.m_bodyD.m_sweep.a;
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) {
        a = t.joint2;
        this.m_localAnchorD.Copy(a.m_localAnchorA), this.m_localAnchorB.Copy(a.m_localAnchorB), this.m_referenceAngleB = a.m_referenceAngle, this.m_localAxisD.SetZero(), i = u - b - this.m_referenceAngleB
    } else {
        h = t.joint2;
        this.m_localAnchorD.Copy(h.m_localAnchorA), this.m_localAnchorB.Copy(h.m_localAnchorB), this.m_referenceAngleB = h.m_referenceAngle, this.m_localAxisD.Copy(h.m_localXAxisA);
        var m = this.m_localAnchorD,
            y = box2d.b2MulTRV(p.q, box2d.b2AddVV(box2d.b2MulRV(c.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(c.p, p.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(y, m, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    this.m_ratio = t.ratio, this.m_constant = e + this.m_ratio * i, this.m_impulse = 0
}, goog.inherits(box2d.b2GearJoint, box2d.b2Joint), box2d.b2GearJoint.prototype.m_joint1 = null, box2d.b2GearJoint.prototype.m_joint2 = null, box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_bodyC = null, box2d.b2GearJoint.prototype.m_bodyD = null, box2d.b2GearJoint.prototype.m_localAnchorA = null, box2d.b2GearJoint.prototype.m_localAnchorB = null, box2d.b2GearJoint.prototype.m_localAnchorC = null, box2d.b2GearJoint.prototype.m_localAnchorD = null, box2d.b2GearJoint.prototype.m_localAxisC = null, box2d.b2GearJoint.prototype.m_localAxisD = null, box2d.b2GearJoint.prototype.m_referenceAngleA = 0, box2d.b2GearJoint.prototype.m_referenceAngleB = 0, box2d.b2GearJoint.prototype.m_constant = 0, box2d.b2GearJoint.prototype.m_ratio = 0, box2d.b2GearJoint.prototype.m_impulse = 0, box2d.b2GearJoint.prototype.m_indexA = 0, box2d.b2GearJoint.prototype.m_indexB = 0, box2d.b2GearJoint.prototype.m_indexC = 0, box2d.b2GearJoint.prototype.m_indexD = 0, box2d.b2GearJoint.prototype.m_lcA = null, box2d.b2GearJoint.prototype.m_lcB = null, box2d.b2GearJoint.prototype.m_lcC = null, box2d.b2GearJoint.prototype.m_lcD = null, box2d.b2GearJoint.prototype.m_mA = 0, box2d.b2GearJoint.prototype.m_mB = 0, box2d.b2GearJoint.prototype.m_mC = 0, box2d.b2GearJoint.prototype.m_mD = 0, box2d.b2GearJoint.prototype.m_iA = 0, box2d.b2GearJoint.prototype.m_iB = 0, box2d.b2GearJoint.prototype.m_iC = 0, box2d.b2GearJoint.prototype.m_iD = 0, box2d.b2GearJoint.prototype.m_JvAC = null, box2d.b2GearJoint.prototype.m_JvBD = null, box2d.b2GearJoint.prototype.m_JwA = 0, box2d.b2GearJoint.prototype.m_JwB = 0, box2d.b2GearJoint.prototype.m_JwC = 0, box2d.b2GearJoint.prototype.m_JwD = 0, box2d.b2GearJoint.prototype.m_mass = 0, box2d.b2GearJoint.prototype.m_qA = null, box2d.b2GearJoint.prototype.m_qB = null, box2d.b2GearJoint.prototype.m_qC = null, box2d.b2GearJoint.prototype.m_qD = null, box2d.b2GearJoint.prototype.m_lalcA = null, box2d.b2GearJoint.prototype.m_lalcB = null, box2d.b2GearJoint.prototype.m_lalcC = null, box2d.b2GearJoint.prototype.m_lalcD = null, box2d.b2GearJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_indexC = this.m_bodyC.m_islandIndex, this.m_indexD = this.m_bodyD.m_islandIndex, this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter), this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter), this.m_mA = this.m_bodyA.m_invMass, this.m_mB = this.m_bodyB.m_invMass, this.m_mC = this.m_bodyC.m_invMass, this.m_mD = this.m_bodyD.m_invMass, this.m_iA = this.m_bodyA.m_invI, this.m_iB = this.m_bodyB.m_invI, this.m_iC = this.m_bodyC.m_invI, this.m_iD = this.m_bodyD.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = t.positions[this.m_indexC].a,
        h = t.velocities[this.m_indexC].v,
        l = t.velocities[this.m_indexC].w,
        d = t.positions[this.m_indexD].a,
        c = t.velocities[this.m_indexD].v,
        u = t.velocities[this.m_indexD].w,
        p = this.m_qA.SetAngleRadians(e),
        b = this.m_qB.SetAngleRadians(s),
        m = this.m_qC.SetAngleRadians(a),
        y = this.m_qD.SetAngleRadians(d);
    if (this.m_mass = 0, this.m_typeA === box2d.b2JointType.e_revoluteJoint) this.m_JvAC.SetZero(), this.m_JwA = 1, this.m_JwC = 1, this.m_mass += this.m_iA + this.m_iC;
    else {
        var f = box2d.b2MulRV(m, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);
        var x = box2d.b2MulRV(m, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC);
        box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);
        var g = box2d.b2MulRV(p, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA);
        this.m_JvAC.Copy(f), this.m_JwC = box2d.b2CrossVV(x, f), this.m_JwA = box2d.b2CrossVV(g, f), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA
    }
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) this.m_JvBD.SetZero(), this.m_JwB = this.m_ratio, this.m_JwD = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
    else {
        f = box2d.b2MulRV(y, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);
        var _ = box2d.b2MulRV(y, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD);
        box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);
        var v = box2d.b2MulRV(b, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, f, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(_, f), this.m_JwB = this.m_ratio * box2d.b2CrossVV(v, f), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB
    }
    this.m_mass = 0 < this.m_mass ? 1 / this.m_mass : 0, t.step.warmStarting ? (i.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), o += this.m_iA * this.m_impulse * this.m_JwA, n.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), r += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, c.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD), u -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0, t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r, t.velocities[this.m_indexC].w = l, t.velocities[this.m_indexD].w = u
}, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = t.velocities[this.m_indexC].v,
        r = t.velocities[this.m_indexC].w,
        a = t.velocities[this.m_indexD].v,
        h = t.velocities[this.m_indexD].w,
        l = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(e, n, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(o, a, box2d.b2Vec2.s_t0));
    l += this.m_JwA * i - this.m_JwC * r + (this.m_JwB * s - this.m_JwD * h);
    var d = -this.m_mass * l;
    this.m_impulse += d, e.SelfMulAdd(this.m_mA * d, this.m_JvAC), i += this.m_iA * d * this.m_JwA, o.SelfMulAdd(this.m_mB * d, this.m_JvBD), s += this.m_iB * d * this.m_JwB, n.SelfMulSub(this.m_mC * d, this.m_JvAC), r -= this.m_iC * d * this.m_JwC, a.SelfMulSub(this.m_mD * d, this.m_JvBD), h -= this.m_iD * d * this.m_JwD, t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s, t.velocities[this.m_indexC].w = r, t.velocities[this.m_indexD].w = h
}, box2d.b2GearJoint.prototype.SolvePositionConstraints = function(t) {
    var e, i, o, s, n, r, a = t.positions[this.m_indexA].c,
        h = t.positions[this.m_indexA].a,
        l = t.positions[this.m_indexB].c,
        d = t.positions[this.m_indexB].a,
        c = t.positions[this.m_indexC].c,
        u = t.positions[this.m_indexC].a,
        p = t.positions[this.m_indexD].c,
        b = t.positions[this.m_indexD].a,
        m = this.m_qA.SetAngleRadians(h),
        y = this.m_qB.SetAngleRadians(d),
        f = this.m_qC.SetAngleRadians(u),
        x = this.m_qD.SetAngleRadians(b),
        g = this.m_JvAC,
        _ = this.m_JvBD,
        v = 0;
    if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) g.SetZero(), n = o = 1, v += this.m_iA + this.m_iC, e = h - u - this.m_referenceAngleA;
    else {
        var S = box2d.b2MulRV(f, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u),
            C = box2d.b2MulRV(f, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC),
            w = box2d.b2MulRV(m, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        g.Copy(S), n = box2d.b2CrossVV(C, S), o = box2d.b2CrossVV(w, S), v += this.m_mC + this.m_mA + this.m_iC * n * n + this.m_iA * o * o;
        var A = this.m_lalcC,
            P = box2d.b2MulTRV(f, box2d.b2AddVV(w, box2d.b2SubVV(a, c, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(P, A, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) _.SetZero(), s = this.m_ratio, r = this.m_ratio, v += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), i = d - b - this.m_referenceAngleB;
    else {
        S = box2d.b2MulRV(x, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        var T = box2d.b2MulRV(x, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD),
            B = box2d.b2MulRV(y, this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, S, _), r = this.m_ratio * box2d.b2CrossVV(T, S), s = this.m_ratio * box2d.b2CrossVV(B, S), v += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * r * r + this.m_iB * s * s;
        var M = this.m_lalcD,
            E = box2d.b2MulTRV(x, box2d.b2AddVV(B, box2d.b2SubVV(l, p, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(E, M, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    var I = e + this.m_ratio * i - this.m_constant,
        V = 0;
    return 0 < v && (V = -I / v), a.SelfMulAdd(this.m_mA * V, g), h += this.m_iA * V * o, l.SelfMulAdd(this.m_mB * V, _), d += this.m_iB * V * s, c.SelfMulSub(this.m_mC * V, g), u -= this.m_iC * V * n, p.SelfMulSub(this.m_mD * V, _), b -= this.m_iD * V * r, t.positions[this.m_indexA].a = h, t.positions[this.m_indexB].a = d, t.positions[this.m_indexC].a = u, t.positions[this.m_indexD].a = b, 0 < box2d.b2_linearSlop
}, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2GearJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2GearJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t * this.m_impulse, this.m_JvAC, e)
}, box2d.b2GearJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse * this.m_JwA
}, box2d.b2GearJoint.prototype.GetJoint1 = function() {
    return this.m_joint1
}, box2d.b2GearJoint.prototype.GetJoint2 = function() {
    return this.m_joint2
}, box2d.b2GearJoint.prototype.GetRatio = function() {
    return this.m_ratio
}, box2d.b2GearJoint.prototype.SetRatio = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t)), this.m_ratio = t
}, box2d.b2GearJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex,
            i = this.m_joint1.m_index,
            o = this.m_joint2.m_index;
        box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.joint1 = joints[%d];\n", i), box2d.b2Log("  jd.joint2 = joints[%d];\n", o), box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2Distance"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2DistanceProxy = function() {
    this.m_buffer = box2d.b2Vec2.MakeArray(2)
}, box2d.b2DistanceProxy.prototype.m_buffer = null, box2d.b2DistanceProxy.prototype.m_vertices = null, box2d.b2DistanceProxy.prototype.m_count = 0, box2d.b2DistanceProxy.prototype.m_radius = 0, box2d.b2DistanceProxy.prototype.Reset = function() {
    return this.m_vertices = null, this.m_count = 0, this.m_radius = 0, this
}, box2d.b2DistanceProxy.prototype.SetShape = function(t, e) {
    t.SetupDistanceProxy(this, e)
}, box2d.b2DistanceProxy.prototype.GetSupport = function(t) {
    for (var e = 0, i = box2d.b2DotVV(this.m_vertices[0], t), o = 1; o < this.m_count; ++o) {
        var s = box2d.b2DotVV(this.m_vertices[o], t);
        i < s && (e = o, i = s)
    }
    return e
}, box2d.b2DistanceProxy.prototype.GetSupportVertex = function(t, e) {
    for (var i = 0, o = box2d.b2DotVV(this.m_vertices[0], t), s = 1; s < this.m_count; ++s) {
        var n = box2d.b2DotVV(this.m_vertices[s], t);
        o < n && (i = s, o = n)
    }
    return e.Copy(this.m_vertices[i])
}, box2d.b2DistanceProxy.prototype.GetVertexCount = function() {
    return this.m_count
}, box2d.b2DistanceProxy.prototype.GetVertex = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= t && t < this.m_count), this.m_vertices[t]
}, box2d.b2SimplexCache = function() {
    this.indexA = box2d.b2MakeNumberArray(3), this.indexB = box2d.b2MakeNumberArray(3)
}, box2d.b2SimplexCache.prototype.metric = 0, box2d.b2SimplexCache.prototype.count = 0, box2d.b2SimplexCache.prototype.indexA = null, box2d.b2SimplexCache.prototype.indexB = null, box2d.b2SimplexCache.prototype.Reset = function() {
    return this.metric = 0, this.count = 0, this
}, box2d.b2DistanceInput = function() {
    this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.transformA = new box2d.b2Transform, this.transformB = new box2d.b2Transform
}, box2d.b2DistanceInput.prototype.proxyA = null, box2d.b2DistanceInput.prototype.proxyB = null, box2d.b2DistanceInput.prototype.transformA = null, box2d.b2DistanceInput.prototype.transformB = null, box2d.b2DistanceInput.prototype.useRadii = !1, box2d.b2DistanceInput.prototype.Reset = function() {
    return this.proxyA.Reset(), this.proxyB.Reset(), this.transformA.SetIdentity(), this.transformB.SetIdentity(), this.useRadii = !1, this
}, box2d.b2DistanceOutput = function() {
    this.pointA = new box2d.b2Vec2, this.pointB = new box2d.b2Vec2
}, box2d.b2DistanceOutput.prototype.pointA = null, box2d.b2DistanceOutput.prototype.pointB = null, box2d.b2DistanceOutput.prototype.distance = 0, box2d.b2DistanceOutput.prototype.iterations = 0, box2d.b2DistanceOutput.prototype.Reset = function() {
    return this.pointA.SetZero(), this.pointB.SetZero(), this.distance = 0, this.iterations = 0, this
}, box2d.b2_gjkCalls = 0, box2d.b2_gjkIters = 0, box2d.b2_gjkMaxIters = 0, box2d.b2SimplexVertex = function() {
    this.wA = new box2d.b2Vec2, this.wB = new box2d.b2Vec2, this.w = new box2d.b2Vec2
}, box2d.b2SimplexVertex.prototype.wA = null, box2d.b2SimplexVertex.prototype.wB = null, box2d.b2SimplexVertex.prototype.w = null, box2d.b2SimplexVertex.prototype.a = 0, box2d.b2SimplexVertex.prototype.indexA = 0, box2d.b2SimplexVertex.prototype.indexB = 0, box2d.b2SimplexVertex.prototype.Copy = function(t) {
    return this.wA.Copy(t.wA), this.wB.Copy(t.wB), this.w.Copy(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB, this
}, box2d.b2Simplex = function() {
    this.m_v1 = new box2d.b2SimplexVertex, this.m_v2 = new box2d.b2SimplexVertex, this.m_v3 = new box2d.b2SimplexVertex, this.m_vertices = new Array(3), this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
}, box2d.b2Simplex.prototype.m_v1 = null, box2d.b2Simplex.prototype.m_v2 = null, box2d.b2Simplex.prototype.m_v3 = null, box2d.b2Simplex.prototype.m_vertices = null, box2d.b2Simplex.prototype.m_count = 0, box2d.b2Simplex.prototype.ReadCache = function(t, e, i, o, s) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count;
    for (var n = this.m_vertices, r = 0; r < this.m_count; ++r) {
        (c = n[r]).indexA = t.indexA[r], c.indexB = t.indexB[r];
        var a = e.GetVertex(c.indexA),
            h = o.GetVertex(c.indexB);
        box2d.b2MulXV(i, a, c.wA), box2d.b2MulXV(s, h, c.wB), box2d.b2SubVV(c.wB, c.wA, c.w), c.a = 0
    }
    if (1 < this.m_count) {
        var l = t.metric,
            d = this.GetMetric();
        (d < .5 * l || 2 * l < d || d < box2d.b2_epsilon) && (this.m_count = 0)
    }
    if (0 === this.m_count) {
        var c;
        (c = n[0]).indexA = 0, c.indexB = 0;
        a = e.GetVertex(0), h = o.GetVertex(0);
        box2d.b2MulXV(i, a, c.wA), box2d.b2MulXV(s, h, c.wB), box2d.b2SubVV(c.wB, c.wA, c.w), c.a = 1, this.m_count = 1
    }
}, box2d.b2Simplex.prototype.WriteCache = function(t) {
    t.metric = this.GetMetric(), t.count = this.m_count;
    for (var e = this.m_vertices, i = 0; i < this.m_count; ++i) t.indexA[i] = e[i].indexA, t.indexB[i] = e[i].indexB
}, box2d.b2Simplex.prototype.GetSearchDirection = function(t) {
    switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, t);
        case 2:
            var e = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, t);
            return 0 < box2d.b2CrossVV(e, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) ? box2d.b2CrossOneV(e, t) : box2d.b2CrossVOne(e, t);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero()
    }
}, box2d.b2Simplex.prototype.GetClosestPoint = function(t) {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero();
        case 1:
            return t.Copy(this.m_v1.w);
        case 2:
            return t.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
            return t.SetZero();
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero()
    }
}, box2d.b2Simplex.prototype.GetWitnessPoints = function(t, e) {
    switch (this.m_count) {
        case 0:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
            break;
        case 1:
            t.Copy(this.m_v1.wA), e.Copy(this.m_v1.wB);
            break;
        case 2:
            t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;
        case 3:
            e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
    }
}, box2d.b2Simplex.prototype.GetMetric = function() {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0;
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
    }
}, box2d.b2Simplex.prototype.Solve2 = function() {
    var t = this.m_v1.w,
        e = this.m_v2.w,
        i = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        o = -box2d.b2DotVV(t, i);
    if (o <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
    var s = box2d.b2DotVV(e, i);
    if (s <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2);
    var n = 1 / (s + o);
    this.m_v1.a = s * n, this.m_v2.a = o * n, this.m_count = 2
}, box2d.b2Simplex.prototype.Solve3 = function() {
    var t = this.m_v1.w,
        e = this.m_v2.w,
        i = this.m_v3.w,
        o = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        s = box2d.b2DotVV(t, o),
        n = box2d.b2DotVV(e, o),
        r = -s,
        a = box2d.b2SubVV(i, t, box2d.b2Simplex.s_e13),
        h = box2d.b2DotVV(t, a),
        l = box2d.b2DotVV(i, a),
        d = -h,
        c = box2d.b2SubVV(i, e, box2d.b2Simplex.s_e23),
        u = box2d.b2DotVV(e, c),
        p = box2d.b2DotVV(i, c),
        b = -u,
        m = box2d.b2CrossVV(o, a),
        y = m * box2d.b2CrossVV(e, i),
        f = m * box2d.b2CrossVV(i, t),
        x = m * box2d.b2CrossVV(t, e);
    if (r <= 0 && d <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
    if (0 < n && 0 < r && x <= 0) {
        var g = 1 / (n + r);
        return this.m_v1.a = n * g, this.m_v2.a = r * g, void(this.m_count = 2)
    }
    if (0 < l && 0 < d && f <= 0) {
        var _ = 1 / (l + d);
        return this.m_v1.a = l * _, this.m_v3.a = d * _, this.m_count = 2, void this.m_v2.Copy(this.m_v3)
    }
    if (n <= 0 && b <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2);
    if (l <= 0 && p <= 0) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v3);
    if (0 < p && 0 < b && y <= 0) {
        var v = 1 / (p + b);
        return this.m_v2.a = p * v, this.m_v3.a = b * v, this.m_count = 2, void this.m_v1.Copy(this.m_v3)
    }
    var S = 1 / (y + f + x);
    this.m_v1.a = y * S, this.m_v2.a = f * S, this.m_v3.a = x * S, this.m_count = 3
}, box2d.b2Simplex.s_e12 = new box2d.b2Vec2, box2d.b2Simplex.s_e13 = new box2d.b2Vec2, box2d.b2Simplex.s_e23 = new box2d.b2Vec2, box2d.b2Distance = function(t, e, i) {
    ++box2d.b2_gjkCalls;
    var o = i.proxyA,
        s = i.proxyB,
        n = i.transformA,
        r = i.transformB,
        a = box2d.b2Distance.s_simplex;
    a.ReadCache(e, o, n, s, r);
    for (var h = a.m_vertices, l = box2d.b2Distance.s_saveA, d = box2d.b2Distance.s_saveB, c = 0, u = (box2d.b2_maxFloat, 0); u < 20;) {
        c = a.m_count;
        for (var p = 0; p < c; ++p) l[p] = h[p].indexA, d[p] = h[p].indexB;
        switch (a.m_count) {
            case 1:
                break;
            case 2:
                a.Solve2();
                break;
            case 3:
                a.Solve3();
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        if (3 === a.m_count) break;
        (_ = a.GetClosestPoint(box2d.b2Distance.s_p)).GetLengthSquared();
        var b = a.GetSearchDirection(box2d.b2Distance.s_d);
        if (b.GetLengthSquared() < box2d.b2_epsilon_sq) break;
        var m = h[a.m_count];
        m.indexA = o.GetSupport(box2d.b2MulTRV(n.q, box2d.b2NegV(b, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA)), box2d.b2MulXV(n, o.GetVertex(m.indexA), m.wA), m.indexB = s.GetSupport(box2d.b2MulTRV(r.q, b, box2d.b2Distance.s_supportB)), box2d.b2MulXV(r, s.GetVertex(m.indexB), m.wB), box2d.b2SubVV(m.wB, m.wA, m.w), ++u, ++box2d.b2_gjkIters;
        var y = !1;
        for (p = 0; p < c; ++p)
            if (m.indexA === l[p] && m.indexB === d[p]) {
                y = !0;
                break
            }
        if (y) break;
        ++a.m_count
    }
    if (box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, u), a.GetWitnessPoints(t.pointA, t.pointB), t.distance = box2d.b2DistanceVV(t.pointA, t.pointB), t.iterations = u, a.WriteCache(e), i.useRadii) {
        var f = o.m_radius,
            x = s.m_radius;
        if (t.distance > f + x && t.distance > box2d.b2_epsilon) {
            t.distance -= f + x;
            var g = box2d.b2SubVV(t.pointB, t.pointA, box2d.b2Distance.s_normal);
            g.Normalize(), t.pointA.SelfMulAdd(f, g), t.pointB.SelfMulSub(x, g)
        } else {
            var _ = box2d.b2MidVV(t.pointA, t.pointB, box2d.b2Distance.s_p);
            t.pointA.Copy(_), t.pointB.Copy(_), t.distance = 0
        }
    }
}, box2d.b2Distance.s_simplex = new box2d.b2Simplex, box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_p = new box2d.b2Vec2, box2d.b2Distance.s_d = new box2d.b2Vec2, box2d.b2Distance.s_normal = new box2d.b2Vec2, box2d.b2Distance.s_supportA = new box2d.b2Vec2, box2d.b2Distance.s_supportB = new box2d.b2Vec2, goog.provide("box2d.b2WeldJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2WeldJointDef = function() {
    goog.base(this, box2d.b2JointType.e_weldJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef), box2d.b2WeldJointDef.prototype.localAnchorA = null, box2d.b2WeldJointDef.prototype.localAnchorB = null, box2d.b2WeldJointDef.prototype.referenceAngle = 0, box2d.b2WeldJointDef.prototype.frequencyHz = 0, box2d.b2WeldJointDef.prototype.dampingRatio = 0, box2d.b2WeldJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2WeldJoint = function(t) {
    goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat33
}, goog.inherits(box2d.b2WeldJoint, box2d.b2Joint), box2d.b2WeldJoint.prototype.m_frequencyHz = 0, box2d.b2WeldJoint.prototype.m_dampingRatio = 0, box2d.b2WeldJoint.prototype.m_bias = 0, box2d.b2WeldJoint.prototype.m_localAnchorA = null, box2d.b2WeldJoint.prototype.m_localAnchorB = null, box2d.b2WeldJoint.prototype.m_referenceAngle = 0, box2d.b2WeldJoint.prototype.m_gamma = 0, box2d.b2WeldJoint.prototype.m_impulse = null, box2d.b2WeldJoint.prototype.m_indexA = 0, box2d.b2WeldJoint.prototype.m_indexB = 0, box2d.b2WeldJoint.prototype.m_rA = null, box2d.b2WeldJoint.prototype.m_rB = null, box2d.b2WeldJoint.prototype.m_localCenterA = null, box2d.b2WeldJoint.prototype.m_localCenterB = null, box2d.b2WeldJoint.prototype.m_invMassA = 0, box2d.b2WeldJoint.prototype.m_invMassB = 0, box2d.b2WeldJoint.prototype.m_invIA = 0, box2d.b2WeldJoint.prototype.m_invIB = 0, box2d.b2WeldJoint.prototype.m_mass = null, box2d.b2WeldJoint.prototype.m_qA = null, box2d.b2WeldJoint.prototype.m_qB = null, box2d.b2WeldJoint.prototype.m_lalcA = null, box2d.b2WeldJoint.prototype.m_lalcB = null, box2d.b2WeldJoint.prototype.m_K = null, box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB);
    var l = this.m_invMassA,
        d = this.m_invMassB,
        c = this.m_invIA,
        u = this.m_invIB,
        p = this.m_K;
    if (p.ex.x = l + d + this.m_rA.y * this.m_rA.y * c + this.m_rB.y * this.m_rB.y * u, p.ey.x = -this.m_rA.y * this.m_rA.x * c - this.m_rB.y * this.m_rB.x * u, p.ez.x = -this.m_rA.y * c - this.m_rB.y * u, p.ex.y = p.ey.x, p.ey.y = l + d + this.m_rA.x * this.m_rA.x * c + this.m_rB.x * this.m_rB.x * u, p.ez.y = this.m_rA.x * c + this.m_rB.x * u, p.ex.z = p.ez.x, p.ey.z = p.ez.y, p.ez.z = c + u, 0 < this.m_frequencyHz) {
        p.GetInverse22(this.m_mass);
        var b = c + u,
            m = 0 < b ? 1 / b : 0,
            y = s - e - this.m_referenceAngle,
            f = 2 * box2d.b2_pi * this.m_frequencyHz,
            x = 2 * m * this.m_dampingRatio * f,
            g = m * f * f,
            _ = t.step.dt;
        this.m_gamma = _ * (x + _ * g), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = y * _ * g * this.m_gamma, b += this.m_gamma, this.m_mass.ez.z = 0 !== b ? 1 / b : 0
    } else p.GetSymInverse33(this.m_mass), this.m_gamma = 0, this.m_bias = 0;
    if (t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio);
        var v = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, v), o -= c * (box2d.b2CrossVV(this.m_rA, v) + this.m_impulse.z), n.SelfMulAdd(d, v), r += u * (box2d.b2CrossVV(this.m_rB, v) + this.m_impulse.z)
    } else this.m_impulse.SetZero();
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB;
    if (0 < this.m_frequencyHz) {
        var l = s - i,
            d = -this.m_mass.ez.z * (l + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += d, i -= a * d, s += h * d;
        var c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            u = box2d.b2MulM33XY(this.m_mass, c.x, c.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += u.x, this.m_impulse.y += u.y;
        var p = u;
        e.SelfMulSub(n, p), i -= a * box2d.b2CrossVV(this.m_rA, p), o.SelfMulAdd(r, p), s += h * box2d.b2CrossVV(this.m_rB, p)
    } else {
        c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1), l = s - i;
        var b = box2d.b2MulM33XYZ(this.m_mass, c.x, c.y, l, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(b);
        p = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(b.x, b.y);
        e.SelfMulSub(n, p), i -= a * (box2d.b2CrossVV(this.m_rA, p) + b.z), o.SelfMulAdd(r, p), s += h * (box2d.b2CrossVV(this.m_rB, p) + b.z)
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        d = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var c = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var u, p, b = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        m = this.m_K;
    if (m.ex.x = a + h + c.y * c.y * l + b.y * b.y * d, m.ey.x = -c.y * c.x * l - b.y * b.x * d, m.ez.x = -c.y * l - b.y * d, m.ex.y = m.ey.x, m.ey.y = a + h + c.x * c.x * l + b.x * b.x * d, m.ez.y = c.x * l + b.x * d, m.ex.z = m.ez.x, m.ey.z = m.ez.y, m.ez.z = l + d, 0 < this.m_frequencyHz) {
        u = (f = box2d.b2SubVV(box2d.b2AddVV(o, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1)).GetLength(), p = 0;
        var y = m.Solve22(f.x, f.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        e.SelfMulSub(a, y), i -= l * box2d.b2CrossVV(c, y), o.SelfMulAdd(h, y), s += d * box2d.b2CrossVV(b, y)
    } else {
        var f = box2d.b2SubVV(box2d.b2AddVV(o, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1),
            x = s - i - this.m_referenceAngle;
        u = f.GetLength(), p = box2d.b2Abs(x);
        var g = m.Solve33(f.x, f.y, x, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
        y = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(g.x, g.y);
        e.SelfMulSub(a, y), i -= l * (box2d.b2CrossVV(this.m_rA, y) + g.z), o.SelfMulAdd(h, y), s += d * (box2d.b2CrossVV(this.m_rB, y) + g.z)
    }
    return t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, u <= box2d.b2_linearSlop && p <= box2d.b2_angularSlop
}, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2WeldJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2WeldJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y)
}, box2d.b2WeldJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.z
}, box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2WeldJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2WeldJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2WeldJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2WeldJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2WeldJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2WeldJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2RopeJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RopeJointDef = function() {
    goog.base(this, box2d.b2JointType.e_ropeJoint), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef), box2d.b2RopeJointDef.prototype.localAnchorA = null, box2d.b2RopeJointDef.prototype.localAnchorB = null, box2d.b2RopeJointDef.prototype.maxLength = 0, box2d.b2RopeJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_maxLength = t.maxLength, this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2
}, goog.inherits(box2d.b2RopeJoint, box2d.b2Joint), box2d.b2RopeJoint.prototype.m_localAnchorA = null, box2d.b2RopeJoint.prototype.m_localAnchorB = null, box2d.b2RopeJoint.prototype.m_maxLength = 0, box2d.b2RopeJoint.prototype.m_length = 0, box2d.b2RopeJoint.prototype.m_impulse = 0, box2d.b2RopeJoint.prototype.m_indexA = 0, box2d.b2RopeJoint.prototype.m_indexB = 0, box2d.b2RopeJoint.prototype.m_u = null, box2d.b2RopeJoint.prototype.m_rA = null, box2d.b2RopeJoint.prototype.m_rB = null, box2d.b2RopeJoint.prototype.m_localCenterA = null, box2d.b2RopeJoint.prototype.m_localCenterB = null, box2d.b2RopeJoint.prototype.m_invMassA = 0, box2d.b2RopeJoint.prototype.m_invMassB = 0, box2d.b2RopeJoint.prototype.m_invIA = 0, box2d.b2RopeJoint.prototype.m_invIB = 0, box2d.b2RopeJoint.prototype.m_mass = 0, box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit, box2d.b2RopeJoint.prototype.m_qA = null, box2d.b2RopeJoint.prototype.m_qB = null, box2d.b2RopeJoint.prototype.m_lalcA = null, box2d.b2RopeJoint.prototype.m_lalcB = null, box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_u.Copy(n).SelfAdd(this.m_rB).SelfSub(e).SelfSub(this.m_rA), this.m_length = this.m_u.GetLength();
    var c = this.m_length - this.m_maxLength;
    if (this.m_state = 0 < c ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit, !(this.m_length > box2d.b2_linearSlop)) return this.m_u.SetZero(), this.m_mass = 0, void(this.m_impulse = 0);
    this.m_u.SelfMul(1 / this.m_length);
    var u = box2d.b2CrossVV(this.m_rA, this.m_u),
        p = box2d.b2CrossVV(this.m_rB, this.m_u),
        b = this.m_invMassA + this.m_invIA * u * u + this.m_invMassB + this.m_invIB * p * p;
    if (this.m_mass = 0 !== b ? 1 / b : 0, t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var m = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, m), s -= this.m_invIA * box2d.b2CrossVV(this.m_rA, m), a.SelfMulAdd(this.m_invMassB, m), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, m)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = this.m_length - this.m_maxLength,
        h = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0));
    a < 0 && (h += t.step.inv_dt * a);
    var l = -this.m_mass * h,
        d = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + l), l = this.m_impulse - d;
    var c = box2d.b2MulSV(l, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, c), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, c), o.SelfMulAdd(this.m_invMassB, c), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, c), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        l = this.m_u.Copy(o).SelfAdd(h).SelfSub(e).SelfSub(a),
        d = l.Normalize(),
        c = d - this.m_maxLength;
    c = box2d.b2Clamp(c, 0, box2d.b2_maxLinearCorrection);
    var u = -this.m_mass * c,
        p = box2d.b2MulSV(u, l, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);
    return e.SelfMulSub(this.m_invMassA, p), i -= this.m_invIA * box2d.b2CrossVV(a, p), o.SelfMulAdd(this.m_invMassB, p), s += this.m_invIB * box2d.b2CrossVV(h, p), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, d - this.m_maxLength < box2d.b2_linearSlop
}, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2RopeJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2RopeJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t * this.m_impulse, this.m_u, e)
}, box2d.b2RopeJoint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2RopeJoint.prototype.SetMaxLength = function(t) {
    this.m_maxLength = t
}, box2d.b2RopeJoint.prototype.GetMaxLength = function() {
    return this.m_maxLength
}, box2d.b2RopeJoint.prototype.GetLimitState = function() {
    return this.m_state
}, box2d.b2RopeJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2GravityController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2GravityController = function() {
    goog.base(this)
}, goog.inherits(box2d.b2GravityController, box2d.b2Controller), box2d.b2GravityController.prototype.G = 1, box2d.b2GravityController.prototype.invSqr = !0, box2d.b2GravityController.prototype.Step = function() {
    if (this.invSqr)
        for (var t = this.m_bodyList; t; t = t.nextBody)
            for (var e = (r = t.body).GetWorldCenter(), i = r.GetMass(), o = this.m_bodyList; o !== t; o = o.nextBody) {
                var s = (a = o.body).GetWorldCenter(),
                    n = a.GetMass();
                if (!((d = (h = s.x - e.x) * h + (l = s.y - e.y) * l) < box2d.b2_epsilon))(c = box2d.b2GravityController.prototype.Step.s_f.SetXY(h, l)).SelfMul(this.G / d / box2d.b2Sqrt(d) * i * n), r.IsAwake() && r.ApplyForce(c, e), a.IsAwake() && a.ApplyForce(c.SelfMul(-1), s)
            } else
                for (t = this.m_bodyList; t; t = t.nextBody) {
                    var r;
                    for (e = (r = t.body).GetWorldCenter(), i = r.GetMass(), o = this.m_bodyList; o !== t; o = o.nextBody) {
                        var a, h, l, d, c;
                        s = (a = o.body).GetWorldCenter(), n = a.GetMass();
                        if (!((d = (h = s.x - e.x) * h + (l = s.y - e.y) * l) < box2d.b2_epsilon))(c = box2d.b2GravityController.prototype.Step.s_f.SetXY(h, l)).SelfMul(this.G / d * i * n), r.IsAwake() && r.ApplyForce(c, e), a.IsAwake() && a.ApplyForce(c.SelfMul(-1), s)
                    }
                }
}, box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2, goog.provide("box2d.b2TimeStep"), goog.require("box2d.b2Settings"), box2d.b2Profile = function() {}, box2d.b2Profile.prototype.step = 0, box2d.b2Profile.prototype.collide = 0, box2d.b2Profile.prototype.solve = 0, box2d.b2Profile.prototype.solveInit = 0, box2d.b2Profile.prototype.solveVelocity = 0, box2d.b2Profile.prototype.solvePosition = 0, box2d.b2Profile.prototype.broadphase = 0, box2d.b2Profile.prototype.solveTOI = 0, box2d.b2Profile.prototype.Reset = function() {
    return this.step = 0, this.collide = 0, this.solve = 0, this.solveInit = 0, this.solveVelocity = 0, this.solvePosition = 0, this.broadphase = 0, this.solveTOI = 0, this
}, box2d.b2TimeStep = function() {}, box2d.b2TimeStep.prototype.dt = 0, box2d.b2TimeStep.prototype.inv_dt = 0, box2d.b2TimeStep.prototype.dtRatio = 0, box2d.b2TimeStep.prototype.velocityIterations = 0, box2d.b2TimeStep.prototype.positionIterations = 0, box2d.b2TimeStep.prototype.warmStarting = !1, box2d.b2TimeStep.prototype.Copy = function(t) {
    return this.dt = t.dt, this.inv_dt = t.inv_dt, this.dtRatio = t.dtRatio, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting, this
}, box2d.b2Position = function() {
    this.c = new box2d.b2Vec2
}, box2d.b2Position.prototype.c = null, box2d.b2Position.prototype.a = 0, box2d.b2Position.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2Position
    })
}, box2d.b2Velocity = function() {
    this.v = new box2d.b2Vec2
}, box2d.b2Velocity.prototype.v = null, box2d.b2Velocity.prototype.w = 0, box2d.b2Velocity.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2Velocity
    })
}, box2d.b2SolverData = function() {
    this.step = new box2d.b2TimeStep
}, box2d.b2SolverData.prototype.step = null, box2d.b2SolverData.prototype.positions = null, box2d.b2SolverData.prototype.velocities = null, goog.provide("box2d.b2Collision"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2ContactFeatureType = {
    e_vertex: 0,
    e_face: 1
}, goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex), goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face), box2d.b2ContactFeature = function(t) {
    this._id = t
}, box2d.b2ContactFeature.prototype._id = null, box2d.b2ContactFeature.prototype._indexA = 0, box2d.b2ContactFeature.prototype._indexB = 0, box2d.b2ContactFeature.prototype._typeA = 0, box2d.b2ContactFeature.prototype._typeB = 0, Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._indexA
    },
    set: function(t) {
        this._indexA = t, this._id._key = 4294967040 & this._id._key | 255 & this._indexA
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._indexB
    },
    set: function(t) {
        this._indexB = t, this._id._key = 4294902015 & this._id._key | this._indexB << 8 & 65280
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._typeA
    },
    set: function(t) {
        this._typeA = t, this._id._key = 4278255615 & this._id._key | this._typeA << 16 & 16711680
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._typeB
    },
    set: function(t) {
        this._typeB = t, this._id._key = 16777215 & this._id._key | this._typeB << 24 & 4278190080
    }
}), box2d.b2ContactID = function() {
    this.cf = new box2d.b2ContactFeature(this)
}, box2d.b2ContactID.prototype.cf = null, box2d.b2ContactID.prototype.key = 0, box2d.b2ContactID.prototype.Copy = function(t) {
    return this.key = t.key, this
}, box2d.b2ContactID.prototype.Clone = function() {
    return (new box2d.b2ContactID).Copy(this)
}, Object.defineProperty(box2d.b2ContactID.prototype, "key", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._key
    },
    set: function(t) {
        this._key = t, this.cf._indexA = 255 & this._key, this.cf._indexB = this._key >> 8 & 255, this.cf._typeA = this._key >> 16 & 255, this.cf._typeB = this._key >> 24 & 255
    }
}), box2d.b2ManifoldPoint = function() {
    this.localPoint = new box2d.b2Vec2, this.id = new box2d.b2ContactID
}, box2d.b2ManifoldPoint.prototype.localPoint = null, box2d.b2ManifoldPoint.prototype.normalImpulse = 0, box2d.b2ManifoldPoint.prototype.tangentImpulse = 0, box2d.b2ManifoldPoint.prototype.id = null, box2d.b2ManifoldPoint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2ManifoldPoint
    })
}, box2d.b2ManifoldPoint.prototype.Reset = function() {
    this.localPoint.SetZero(), this.normalImpulse = 0, this.tangentImpulse = 0, this.id.key = 0
}, box2d.b2ManifoldPoint.prototype.Copy = function(t) {
    return this.localPoint.Copy(t.localPoint), this.normalImpulse = t.normalImpulse, this.tangentImpulse = t.tangentImpulse, this.id.Copy(t.id), this
}, box2d.b2ManifoldType = {
    e_unknown: -1,
    e_circles: 0,
    e_faceA: 1,
    e_faceB: 2
}, goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown), goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles), goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA), goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB), box2d.b2Manifold = function() {
    this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0
}, box2d.b2Manifold.prototype.points = null, box2d.b2Manifold.prototype.localNormal = null, box2d.b2Manifold.prototype.localPoint = null, box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2Manifold.prototype.pointCount = 0, box2d.b2Manifold.prototype.Reset = function() {
    for (var t = 0, e = box2d.b2_maxManifoldPoints; t < e; ++t) this.points[t].Reset();
    this.localNormal.SetZero(), this.localPoint.SetZero(), this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0
}, box2d.b2Manifold.prototype.Copy = function(t) {
    this.pointCount = t.pointCount;
    for (var e = 0, i = box2d.b2_maxManifoldPoints; e < i; ++e) this.points[e].Copy(t.points[e]);
    return this.localNormal.Copy(t.localNormal), this.localPoint.Copy(t.localPoint), this.type = t.type, this
}, box2d.b2Manifold.prototype.Clone = function() {
    return (new box2d.b2Manifold).Copy(this)
}, box2d.b2WorldManifold = function() {
    this.normal = new box2d.b2Vec2, this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.separations = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
}, box2d.b2WorldManifold.prototype.normal = null, box2d.b2WorldManifold.prototype.points = null, box2d.b2WorldManifold.prototype.separations = null, box2d.b2WorldManifold.prototype.Initialize = function(t, e, i, o, s) {
    if (0 !== t.pointCount) switch (t.type) {
        case box2d.b2ManifoldType.e_circles:
            this.normal.SetXY(1, 0);
            var n = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA),
                r = box2d.b2MulXV(o, t.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
            box2d.b2DistanceSquaredVV(n, r) > box2d.b2_epsilon_sq && box2d.b2SubVV(r, n, this.normal).SelfNormalize();
            var a = box2d.b2AddVMulSV(n, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                h = box2d.b2SubVMulSV(r, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
            box2d.b2MidVV(a, h, this.points[0]), this.separations[0] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal);
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal);
            for (var l = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), d = 0, c = t.pointCount; d < c; ++d) {
                var u = box2d.b2MulXV(o, t.points[d].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint),
                    p = i - box2d.b2DotVV(box2d.b2SubVV(u, l, box2d.b2Vec2.s_t0), this.normal);
                a = box2d.b2AddVMulSV(u, p, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), h = box2d.b2SubVMulSV(u, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(a, h, this.points[d]), this.separations[d] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal)
            }
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(o.q, t.localNormal, this.normal);
            for (l = box2d.b2MulXV(o, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), d = 0, c = t.pointCount; d < c; ++d) {
                u = box2d.b2MulXV(e, t.points[d].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), p = s - box2d.b2DotVV(box2d.b2SubVV(u, l, box2d.b2Vec2.s_t0), this.normal), h = box2d.b2AddVMulSV(u, p, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB), a = box2d.b2SubVMulSV(u, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
                box2d.b2MidVV(a, h, this.points[d]), this.separations[d] = box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), this.normal)
            }
            this.normal.SelfNeg()
    }
}, box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2PointState = {
    b2_nullState: 0,
    b2_addState: 1,
    b2_persistState: 2,
    b2_removeState: 3
}, goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState), goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState), goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState), goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState), box2d.b2GetPointStates = function(t, e, i, o) {
    for (var s = 0, n = i.pointCount; s < n; ++s) {
        var r = i.points[s].id.key;
        t[s] = box2d.b2PointState.b2_removeState;
        for (var a = 0, h = o.pointCount; a < h; ++a)
            if (o.points[a].id.key === r) {
                t[s] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (n = box2d.b2_maxManifoldPoints; s < n; ++s) t[s] = box2d.b2PointState.b2_nullState;
    for (s = 0, n = o.pointCount; s < n; ++s) {
        r = o.points[s].id.key;
        e[s] = box2d.b2PointState.b2_addState;
        for (a = 0, h = i.pointCount; a < h; ++a)
            if (i.points[a].id.key === r) {
                e[s] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (n = box2d.b2_maxManifoldPoints; s < n; ++s) e[s] = box2d.b2PointState.b2_nullState
}, box2d.b2ClipVertex = function() {
    this.v = new box2d.b2Vec2, this.id = new box2d.b2ContactID
}, box2d.b2ClipVertex.prototype.v = null, box2d.b2ClipVertex.prototype.id = null, box2d.b2ClipVertex.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2ClipVertex
    })
}, box2d.b2ClipVertex.prototype.Copy = function(t) {
    return this.v.Copy(t.v), this.id.Copy(t.id), this
}, box2d.b2RayCastInput = function() {
    this.p1 = new box2d.b2Vec2, this.p2 = new box2d.b2Vec2, this.maxFraction = 1
}, box2d.b2RayCastInput.prototype.p1 = null, box2d.b2RayCastInput.prototype.p2 = null, box2d.b2RayCastInput.prototype.maxFraction = 1, box2d.b2RayCastInput.prototype.Copy = function(t) {
    return this.p1.Copy(t.p1), this.p2.Copy(t.p2), this.maxFraction = t.maxFraction, this
}, box2d.b2RayCastOutput = function() {
    this.normal = new box2d.b2Vec2, this.fraction = 0
}, box2d.b2RayCastOutput.prototype.normal = null, box2d.b2RayCastOutput.prototype.fraction = 0, box2d.b2RayCastOutput.prototype.Copy = function(t) {
    return this.normal.Copy(t.normal), this.fraction = t.fraction, this
}, box2d.b2AABB = function() {
    this.lowerBound = new box2d.b2Vec2, this.upperBound = new box2d.b2Vec2, this.m_out_center = new box2d.b2Vec2, this.m_out_extent = new box2d.b2Vec2
}, box2d.b2AABB.prototype.lowerBound = null, box2d.b2AABB.prototype.upperBound = null, box2d.b2AABB.prototype.m_out_center = null, box2d.b2AABB.prototype.m_out_extent = null, box2d.b2AABB.prototype.Copy = function(t) {
    return this.lowerBound.Copy(t.lowerBound), this.upperBound.Copy(t.upperBound), this
}, box2d.b2AABB.prototype.IsValid = function() {
    var t = this.upperBound.x - this.lowerBound.x,
        e = this.upperBound.y - this.lowerBound.y,
        i = 0 <= t && 0 <= e;
    return i && this.lowerBound.IsValid() && this.upperBound.IsValid()
}, box2d.b2AABB.prototype.GetCenter = function() {
    return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center)
}, box2d.b2AABB.prototype.GetExtents = function() {
    return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent)
}, box2d.b2AABB.prototype.GetPerimeter = function() {
    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y))
}, box2d.b2AABB.prototype.Combine1 = function(t) {
    return this.lowerBound.x = box2d.b2Min(this.lowerBound.x, t.lowerBound.x), this.lowerBound.y = box2d.b2Min(this.lowerBound.y, t.lowerBound.y), this.upperBound.x = box2d.b2Max(this.upperBound.x, t.upperBound.x), this.upperBound.y = box2d.b2Max(this.upperBound.y, t.upperBound.y), this
}, box2d.b2AABB.prototype.Combine2 = function(t, e) {
    return this.lowerBound.x = box2d.b2Min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = box2d.b2Min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = box2d.b2Max(t.upperBound.x, e.upperBound.x), this.upperBound.y = box2d.b2Max(t.upperBound.y, e.upperBound.y), this
}, box2d.b2AABB.Combine = function(t, e, i) {
    return i.Combine2(t, e), i
}, box2d.b2AABB.prototype.Contains = function(t) {
    var e = !0;
    return (e = (e = (e = e && this.lowerBound.x <= t.lowerBound.x) && this.lowerBound.y <= t.lowerBound.y) && t.upperBound.x <= this.upperBound.x) && t.upperBound.y <= this.upperBound.y
}, box2d.b2AABB.prototype.RayCast = function(t, e) {
    var i = -box2d.b2_maxFloat,
        o = box2d.b2_maxFloat,
        s = e.p1.x,
        n = e.p1.y,
        r = e.p2.x - e.p1.x,
        a = e.p2.y - e.p1.y,
        h = box2d.b2Abs(r),
        l = box2d.b2Abs(a),
        d = t.normal;
    if (h < box2d.b2_epsilon) {
        if (s < this.lowerBound.x || this.upperBound.x < s) return !1
    } else {
        var c = 1 / r,
            u = (this.lowerBound.x - s) * c,
            p = -1;
        if ((m = (this.upperBound.x - s) * c) < u) {
            var b = u;
            u = m, m = b, p = 1
        }
        if (i < u && (d.x = p, d.y = 0, i = u), (o = box2d.b2Min(o, m)) < i) return !1
    }
    if (l < box2d.b2_epsilon) {
        if (n < this.lowerBound.y || this.upperBound.y < n) return !1
    } else {
        var m;
        c = 1 / a, u = (this.lowerBound.y - n) * c, p = -1;
        if ((m = (this.upperBound.y - n) * c) < u) {
            b = u;
            u = m, m = b, p = 1
        }
        if (i < u && (d.x = 0, d.y = p, i = u), (o = box2d.b2Min(o, m)) < i) return !1
    }
    return !(i < 0 || e.maxFraction < i) && (t.fraction = i, !0)
}, box2d.b2AABB.prototype.TestOverlap = function(t) {
    var e = t.lowerBound.x - this.upperBound.x,
        i = t.lowerBound.y - this.upperBound.y,
        o = this.lowerBound.x - t.upperBound.x,
        s = this.lowerBound.y - t.upperBound.y;
    return !(0 < e || 0 < i) && !(0 < o || 0 < s)
}, box2d.b2TestOverlapAABB = function(t, e) {
    var i = e.lowerBound.x - t.upperBound.x,
        o = e.lowerBound.y - t.upperBound.y,
        s = t.lowerBound.x - e.upperBound.x,
        n = t.lowerBound.y - e.upperBound.y;
    return !(0 < i || 0 < o) && !(0 < s || 0 < n)
}, box2d.b2ClipSegmentToLine = function(t, e, i, o, s) {
    var n = 0,
        r = e[0],
        a = e[1],
        h = box2d.b2DotVV(i, r.v) - o,
        l = box2d.b2DotVV(i, a.v) - o;
    if (h <= 0 && t[n++].Copy(r), l <= 0 && t[n++].Copy(a), h * l < 0) {
        var d = h / (h - l),
            c = t[n].v;
        c.x = r.v.x + d * (a.v.x - r.v.x), c.y = r.v.y + d * (a.v.y - r.v.y);
        var u = t[n].id;
        u.cf.indexA = s, u.cf.indexB = r.id.cf.indexB, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, u.cf.typeB = box2d.b2ContactFeatureType.e_face, ++n
    }
    return n
}, box2d.b2TestOverlapShape = function(t, e, i, o, s, n) {
    var r = box2d.b2TestOverlapShape.s_input.Reset();
    r.proxyA.SetShape(t, e), r.proxyB.SetShape(i, o), r.transformA.Copy(s), r.transformB.Copy(n), r.useRadii = !0;
    var a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0;
    var h = box2d.b2TestOverlapShape.s_output.Reset();
    return box2d.b2Distance(h, a, r), h.distance < 10 * box2d.b2_epsilon
}, box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput, box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache, box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput, goog.provide("box2d.b2Timer"), goog.require("box2d.b2Settings"), box2d.b2Timer = function() {
    this.m_start = (new Date).getTime()
}, box2d.b2Timer.prototype.m_start = 0, box2d.b2Timer.prototype.Reset = function() {
    return this.m_start = (new Date).getTime(), this
}, box2d.b2Timer.prototype.GetMilliseconds = function() {
    return (new Date).getTime() - this.m_start
}, box2d.b2Counter = function() {}, box2d.b2Counter.prototype.m_count = 0, box2d.b2Counter.prototype.m_min_count = 0, box2d.b2Counter.prototype.m_max_count = 0, box2d.b2Counter.prototype.GetCount = function() {
    return this.m_count
}, box2d.b2Counter.prototype.GetMinCount = function() {
    return this.m_min_count
}, box2d.b2Counter.prototype.GetMaxCount = function() {
    return this.m_max_count
}, box2d.b2Counter.prototype.ResetCount = function() {
    var t = this.m_count;
    return this.m_count = 0, t
}, box2d.b2Counter.prototype.ResetMinCount = function() {
    this.m_min_count = 0
}, box2d.b2Counter.prototype.ResetMaxCount = function() {
    this.m_max_count = 0
}, box2d.b2Counter.prototype.Increment = function() {
    this.m_count++, this.m_max_count < this.m_count && (this.m_max_count = this.m_count)
}, box2d.b2Counter.prototype.Decrement = function() {
    this.m_count--, this.m_min_count > this.m_count && (this.m_min_count = this.m_count)
}, goog.provide("box2d.b2TimeOfImpact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Distance"), goog.require("box2d.b2Math"), goog.require("box2d.b2Timer"), box2d.b2_toiTime = 0, box2d.b2_toiMaxTime = 0, box2d.b2_toiCalls = 0, box2d.b2_toiIters = 0, box2d.b2_toiMaxIters = 0, box2d.b2_toiRootIters = 0, box2d.b2_toiMaxRootIters = 0, box2d.b2TOIInput = function() {
    this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.sweepA = new box2d.b2Sweep, this.sweepB = new box2d.b2Sweep
}, box2d.b2TOIInput.prototype.proxyA = null, box2d.b2TOIInput.prototype.proxyB = null, box2d.b2TOIInput.prototype.sweepA = null, box2d.b2TOIInput.prototype.sweepB = null, box2d.b2TOIInput.prototype.tMax = 0, box2d.b2TOIOutputState = {
    e_unknown: 0,
    e_failed: 1,
    e_overlapped: 2,
    e_touching: 3,
    e_separated: 4
}, goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown), goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed), goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped), goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching), goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated), box2d.b2TOIOutput = function() {}, box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown, box2d.b2TOIOutput.prototype.t = 0, box2d.b2SeparationFunctionType = {
    e_unknown: -1,
    e_points: 0,
    e_faceA: 1,
    e_faceB: 2
}, goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown), goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB), box2d.b2SeparationFunction = function() {
    this.m_sweepA = new box2d.b2Sweep, this.m_sweepB = new box2d.b2Sweep, this.m_localPoint = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2
}, box2d.b2SeparationFunction.prototype.m_proxyA = null, box2d.b2SeparationFunction.prototype.m_proxyB = null, box2d.b2SeparationFunction.prototype.m_sweepA = null, box2d.b2SeparationFunction.prototype.m_sweepB = null, box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown, box2d.b2SeparationFunction.prototype.m_localPoint = null, box2d.b2SeparationFunction.prototype.m_axis = null, box2d.b2SeparationFunction.prototype.Initialize = function(t, e, i, o, s, n) {
    this.m_proxyA = e, this.m_proxyB = o;
    var r = t.count;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < r && r < 3), this.m_sweepA.Copy(i), this.m_sweepB.Copy(s);
    var a = box2d.b2TimeOfImpact.s_xfA,
        h = box2d.b2TimeOfImpact.s_xfB;
    if (this.m_sweepA.GetTransform(a, n), this.m_sweepB.GetTransform(h, n), 1 === r) {
        this.m_type = box2d.b2SeparationFunctionType.e_points;
        var l = this.m_proxyA.GetVertex(t.indexA[0]),
            d = this.m_proxyB.GetVertex(t.indexB[0]),
            c = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA),
            u = box2d.b2MulXV(h, d, box2d.b2TimeOfImpact.s_pointB);
        return box2d.b2SubVV(u, c, this.m_axis), x = this.m_axis.Normalize()
    }
    if (t.indexA[0] === t.indexA[1]) {
        this.m_type = box2d.b2SeparationFunctionType.e_faceB;
        var p = this.m_proxyB.GetVertex(t.indexB[0]),
            b = this.m_proxyB.GetVertex(t.indexB[1]);
        box2d.b2CrossVOne(box2d.b2SubVV(b, p, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
        var m = box2d.b2MulRV(h.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
        box2d.b2MidVV(p, b, this.m_localPoint);
        u = box2d.b2MulXV(h, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), l = this.m_proxyA.GetVertex(t.indexA[0]), c = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA);
        return (x = box2d.b2DotVV(box2d.b2SubVV(c, u, box2d.b2Vec2.s_t0), m)) < 0 && (this.m_axis.SelfNeg(), x = -x), x
    }
    this.m_type = box2d.b2SeparationFunctionType.e_faceA;
    var y = this.m_proxyA.GetVertex(t.indexA[0]),
        f = this.m_proxyA.GetVertex(t.indexA[1]);
    box2d.b2CrossVOne(box2d.b2SubVV(f, y, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
    m = box2d.b2MulRV(a.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
    box2d.b2MidVV(y, f, this.m_localPoint);
    var x;
    c = box2d.b2MulXV(a, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), d = this.m_proxyB.GetVertex(t.indexB[0]), u = box2d.b2MulXV(h, d, box2d.b2TimeOfImpact.s_pointB);
    return (x = box2d.b2DotVV(box2d.b2SubVV(u, c, box2d.b2Vec2.s_t0), m)) < 0 && (this.m_axis.SelfNeg(), x = -x), x
}, box2d.b2SeparationFunction.prototype.FindMinSeparation = function(t, e, i) {
    var o = box2d.b2TimeOfImpact.s_xfA,
        s = box2d.b2TimeOfImpact.s_xfB;
    switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(s, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var n = box2d.b2MulTRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA),
                r = box2d.b2MulTRV(s.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = this.m_proxyA.GetSupport(n), e[0] = this.m_proxyB.GetSupport(r);
            var a = this.m_proxyA.GetVertex(t[0]),
                h = this.m_proxyB.GetVertex(e[0]),
                l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA),
                d = box2d.b2MulXV(s, h, box2d.b2TimeOfImpact.s_pointB);
            return box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            var c = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
            l = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), r = box2d.b2MulTRV(s.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = -1, e[0] = this.m_proxyB.GetSupport(r);
            h = this.m_proxyB.GetVertex(e[0]), d = box2d.b2MulXV(s, h, box2d.b2TimeOfImpact.s_pointB);
            return box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            c = box2d.b2MulRV(s.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(s, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), n = box2d.b2MulTRV(o.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA);
            e[0] = -1, t[0] = this.m_proxyA.GetSupport(n);
            a = this.m_proxyA.GetVertex(t[0]), l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA);
            return box2d.b2DotVV(box2d.b2SubVV(l, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t[0] = -1, e[0] = -1, 0
    }
}, box2d.b2SeparationFunction.prototype.Evaluate = function(t, e, i) {
    var o = box2d.b2TimeOfImpact.s_xfA,
        s = box2d.b2TimeOfImpact.s_xfB;
    switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(s, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var n = this.m_proxyA.GetVertex(t),
                r = this.m_proxyB.GetVertex(e),
                a = box2d.b2MulXV(o, n, box2d.b2TimeOfImpact.s_pointA),
                h = box2d.b2MulXV(s, r, box2d.b2TimeOfImpact.s_pointB);
            return box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            var l = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
            a = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), r = this.m_proxyB.GetVertex(e), h = box2d.b2MulXV(s, r, box2d.b2TimeOfImpact.s_pointB);
            return box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), l);
        case box2d.b2SeparationFunctionType.e_faceB:
            l = box2d.b2MulRV(s.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), h = box2d.b2MulXV(s, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), n = this.m_proxyA.GetVertex(t), a = box2d.b2MulXV(o, n, box2d.b2TimeOfImpact.s_pointA);
            return box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), l);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
    }
}, box2d.b2TimeOfImpact = function(t, e) {
    var i = box2d.b2TimeOfImpact.s_timer.Reset();
    ++box2d.b2_toiCalls, t.state = box2d.b2TOIOutputState.e_unknown, t.t = e.tMax;
    var o = e.proxyA,
        s = e.proxyB,
        n = box2d.b2TimeOfImpact.s_sweepA.Copy(e.sweepA),
        r = box2d.b2TimeOfImpact.s_sweepB.Copy(e.sweepB);
    n.Normalize(), r.Normalize();
    var a = e.tMax,
        h = o.m_radius + s.m_radius,
        l = box2d.b2Max(box2d.b2_linearSlop, h - 3 * box2d.b2_linearSlop),
        d = .25 * box2d.b2_linearSlop;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d < l);
    var c = 0,
        u = 0,
        p = box2d.b2TimeOfImpact.s_cache;
    p.count = 0;
    var b = box2d.b2TimeOfImpact.s_distanceInput;
    for (b.proxyA = e.proxyA, b.proxyB = e.proxyB, b.useRadii = !1;;) {
        var m = box2d.b2TimeOfImpact.s_xfA,
            y = box2d.b2TimeOfImpact.s_xfB;
        n.GetTransform(m, c), r.GetTransform(y, c), b.transformA.Copy(m), b.transformB.Copy(y);
        var f = box2d.b2TimeOfImpact.s_distanceOutput;
        if (box2d.b2Distance(f, p, b), f.distance <= 0) {
            t.state = box2d.b2TOIOutputState.e_overlapped, t.t = 0;
            break
        }
        if (f.distance < l + d) {
            t.state = box2d.b2TOIOutputState.e_touching, t.t = c;
            break
        }
        var x = box2d.b2TimeOfImpact.s_fcn;
        x.Initialize(p, o, n, s, r, c);
        for (var g = !1, _ = a, v = 0;;) {
            var S = box2d.b2TimeOfImpact.s_indexA,
                C = box2d.b2TimeOfImpact.s_indexB,
                w = x.FindMinSeparation(S, C, _);
            if (l + d < w) {
                t.state = box2d.b2TOIOutputState.e_separated, t.t = a, g = !0;
                break
            }
            if (l - d < w) {
                c = _;
                break
            }
            var A = x.Evaluate(S[0], C[0], c);
            if (A < l - d) {
                t.state = box2d.b2TOIOutputState.e_failed, t.t = c, g = !0;
                break
            }
            if (A <= l + d) {
                t.state = box2d.b2TOIOutputState.e_touching, t.t = c, g = !0;
                break
            }
            for (var P = 0, T = c, B = _;;) {
                var M;
                M = 1 & P ? T + (l - A) * (B - T) / (w - A) : .5 * (T + B), ++P, ++box2d.b2_toiRootIters;
                var E = x.Evaluate(S[0], C[0], M);
                if (box2d.b2Abs(E - l) < d) {
                    _ = M;
                    break
                }
                if (l < E ? (T = M, A = E) : (B = M, w = E), 50 === P) break
            }
            if (box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, P), ++v === box2d.b2_maxPolygonVertices) break
        }
        if (++u, ++box2d.b2_toiIters, g) break;
        if (20 === u) {
            t.state = box2d.b2TOIOutputState.e_failed, t.t = c;
            break
        }
    }
    box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, u);
    var I = i.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, I), box2d.b2_toiTime += I
}, box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer, box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache, box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput, box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput, box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform, box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform, box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction, box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2, goog.provide("box2d.b2Contact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeOfImpact"), box2d.b2MixFriction = function(t, e) {
    return box2d.b2Sqrt(t * e)
}, box2d.b2MixRestitution = function(t, e) {
    return e < t ? t : e
}, box2d.b2ContactEdge = function() {}, box2d.b2ContactEdge.prototype.other = null, box2d.b2ContactEdge.prototype.contact = null, box2d.b2ContactEdge.prototype.prev = null, box2d.b2ContactEdge.prototype.next = null, box2d.b2ContactFlag = {
    e_none: 0,
    e_islandFlag: 1,
    e_touchingFlag: 2,
    e_enabledFlag: 4,
    e_filterFlag: 8,
    e_bulletHitFlag: 16,
    e_toiFlag: 32
}, goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none), goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag), goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag), goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag), goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag), goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag), goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag), box2d.b2Contact = function() {
    this.m_nodeA = new box2d.b2ContactEdge, this.m_nodeB = new box2d.b2ContactEdge, this.m_manifold = new box2d.b2Manifold, this.m_oldManifold = new box2d.b2Manifold
}, box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none, box2d.b2Contact.prototype.m_prev = null, box2d.b2Contact.prototype.m_next = null, box2d.b2Contact.prototype.m_nodeA = null, box2d.b2Contact.prototype.m_nodeB = null, box2d.b2Contact.prototype.m_fixtureA = null, box2d.b2Contact.prototype.m_fixtureB = null, box2d.b2Contact.prototype.m_indexA = 0, box2d.b2Contact.prototype.m_indexB = 0, box2d.b2Contact.prototype.m_manifold = null, box2d.b2Contact.prototype.m_toiCount = 0, box2d.b2Contact.prototype.m_toi = 0, box2d.b2Contact.prototype.m_friction = 0, box2d.b2Contact.prototype.m_restitution = 0, box2d.b2Contact.prototype.m_tangentSpeed = 0, box2d.b2Contact.prototype.m_oldManifold = null, box2d.b2Contact.prototype.GetManifold = function() {
    return this.m_manifold
}, box2d.b2Contact.prototype.GetWorldManifold = function(t) {
    var e = this.m_fixtureA.GetBody(),
        i = this.m_fixtureB.GetBody(),
        o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    t.Initialize(this.m_manifold, e.GetTransform(), o.m_radius, i.GetTransform(), s.m_radius)
}, box2d.b2Contact.prototype.IsTouching = function() {
    return (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag
}, box2d.b2Contact.prototype.SetEnabled = function(t) {
    t ? this.m_flags |= box2d.b2ContactFlag.e_enabledFlag : this.m_flags &= ~box2d.b2ContactFlag.e_enabledFlag
}, box2d.b2Contact.prototype.IsEnabled = function() {
    return (this.m_flags & box2d.b2ContactFlag.e_enabledFlag) === box2d.b2ContactFlag.e_enabledFlag
}, box2d.b2Contact.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Contact.prototype.GetFixtureA = function() {
    return this.m_fixtureA
}, box2d.b2Contact.prototype.GetChildIndexA = function() {
    return this.m_indexA
}, box2d.b2Contact.prototype.GetFixtureB = function() {
    return this.m_fixtureB
}, box2d.b2Contact.prototype.GetChildIndexB = function() {
    return this.m_indexB
}, box2d.b2Contact.prototype.Evaluate = function() {}, box2d.b2Contact.prototype.FlagForFiltering = function() {
    this.m_flags |= box2d.b2ContactFlag.e_filterFlag
}, box2d.b2Contact.prototype.SetFriction = function(t) {
    this.m_friction = t
}, box2d.b2Contact.prototype.GetFriction = function() {
    return this.m_friction
}, box2d.b2Contact.prototype.ResetFriction = function() {
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction)
}, box2d.b2Contact.prototype.SetRestitution = function(t) {
    this.m_restitution = t
}, box2d.b2Contact.prototype.GetRestitution = function() {
    return this.m_restitution
}, box2d.b2Contact.prototype.ResetRestitution = function() {
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
}, box2d.b2Contact.prototype.SetTangentSpeed = function(t) {
    this.m_tangentSpeed = t
}, box2d.b2Contact.prototype.GetTangentSpeed = function() {
    return this.m_tangentSpeed
}, box2d.b2Contact.prototype.Reset = function(t, e, i, o) {
    this.m_flags = box2d.b2ContactFlag.e_enabledFlag, this.m_fixtureA = t, this.m_fixtureB = i, this.m_indexA = e, this.m_indexB = o, this.m_manifold.pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null, this.m_toiCount = 0, this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction), this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
}, box2d.b2Contact.prototype.Update = function(t) {
    var e = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
    var i = !1,
        o = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag,
        s = this.m_fixtureA.IsSensor(),
        n = this.m_fixtureB.IsSensor(),
        r = s || n,
        a = this.m_fixtureA.GetBody(),
        h = this.m_fixtureB.GetBody(),
        l = a.GetTransform(),
        d = h.GetTransform();
    if (r) {
        var c = this.m_fixtureA.GetShape(),
            u = this.m_fixtureB.GetShape();
        i = box2d.b2TestOverlapShape(c, this.m_indexA, u, this.m_indexB, l, d), this.m_manifold.pointCount = 0
    } else {
        this.Evaluate(this.m_manifold, l, d), i = 0 < this.m_manifold.pointCount;
        for (var p = 0; p < this.m_manifold.pointCount; ++p) {
            var b = this.m_manifold.points[p];
            b.normalImpulse = 0, b.tangentImpulse = 0;
            for (var m = b.id, y = 0; y < this.m_oldManifold.pointCount; ++y) {
                var f = this.m_oldManifold.points[y];
                if (f.id.key === m.key) {
                    b.normalImpulse = f.normalImpulse, b.tangentImpulse = f.tangentImpulse;
                    break
                }
            }
        }
        i !== o && (a.SetAwake(!0), h.SetAwake(!0))
    }
    i ? this.m_flags |= box2d.b2ContactFlag.e_touchingFlag : this.m_flags &= ~box2d.b2ContactFlag.e_touchingFlag, !1 === o && !0 === i && t && t.BeginContact(this), !0 === o && !1 === i && t && t.EndContact(this), !1 === r && i && t && t.PreSolve(this, this.m_oldManifold)
}, box2d.b2Contact.prototype.ComputeTOI = function(t, e) {
    var i = box2d.b2Contact.prototype.ComputeTOI.s_input;
    i.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA), i.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB), i.sweepA.Copy(t), i.sweepB.Copy(e), i.tMax = box2d.b2_linearSlop;
    var o = box2d.b2Contact.prototype.ComputeTOI.s_output;
    return box2d.b2TimeOfImpact(o, i), o.t
}, box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput, box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput, goog.provide("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2PolygonAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact), box2d.b2PolygonAndCircleContact.Create = function() {
    return new box2d.b2PolygonAndCircleContact
}, box2d.b2PolygonAndCircleContact.Destroy = function() {}, box2d.b2PolygonAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_polygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape)
}, box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2PolygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2CircleShape), box2d.b2CollidePolygonAndCircle(t, o instanceof box2d.b2PolygonShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2EdgeAndPolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact), box2d.b2EdgeAndPolygonContact.Create = function() {
    return new box2d.b2EdgeAndPolygonContact
}, box2d.b2EdgeAndPolygonContact.Destroy = function() {}, box2d.b2EdgeAndPolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_edgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_polygonShape)
}, box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2EdgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2PolygonShape), box2d.b2CollideEdgeAndPolygon(t, o instanceof box2d.b2EdgeShape ? o : null, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, goog.provide("box2d.b2Shape"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2MassData = function() {
    this.center = new box2d.b2Vec2(0, 0)
}, box2d.b2MassData.prototype.mass = 0, box2d.b2MassData.prototype.center = null, box2d.b2MassData.prototype.I = 0, box2d.b2ShapeType = {
    e_unknown: -1,
    e_circleShape: 0,
    e_edgeShape: 1,
    e_polygonShape: 2,
    e_chainShape: 3,
    e_shapeTypeCount: 4
}, goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown), goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape), goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape), goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape), goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape), goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount), box2d.b2Shape = function(t, e) {
    this.m_type = t, this.m_radius = e
}, box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown, box2d.b2Shape.prototype.m_radius = 0, box2d.b2Shape.prototype.Clone = function() {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), null
}, box2d.b2Shape.prototype.Copy = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type === t.m_type), this.m_radius = t.m_radius, this
}, box2d.b2Shape.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Shape.prototype.GetChildCount = function() {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), 0
}, box2d.b2Shape.prototype.TestPoint = function() {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), !1
}, box2d.b2Shape.prototype.RayCast = function() {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), !1
}, box2d.b2Shape.prototype.ComputeAABB = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
}, box2d.b2Shape.prototype.ComputeMass = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
}, box2d.b2Shape.prototype.SetupDistanceProxy = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
}, box2d.b2Shape.prototype.ComputeSubmergedArea = function() {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), 0
}, box2d.b2Shape.prototype.Dump = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
}, goog.provide("box2d.b2PolygonShape"), goog.require("box2d.b2Shape"), box2d.b2PolygonShape = function() {
    goog.base(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius), this.m_centroid = new box2d.b2Vec2(0, 0), this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices)
}, goog.inherits(box2d.b2PolygonShape, box2d.b2Shape), box2d.b2PolygonShape.prototype.m_centroid = null, box2d.b2PolygonShape.prototype.m_vertices = null, box2d.b2PolygonShape.prototype.m_normals = null, box2d.b2PolygonShape.prototype.m_count = 0, box2d.b2PolygonShape.prototype.Clone = function() {
    return (new box2d.b2PolygonShape).Copy(this)
}, box2d.b2PolygonShape.prototype.Copy = function(t) {
    goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2PolygonShape), this.m_centroid.Copy(t.m_centroid), this.m_count = t.m_count;
    for (var e = 0, i = this.m_count; e < i; ++e) this.m_vertices[e].Copy(t.m_vertices[e]), this.m_normals[e].Copy(t.m_normals[e]);
    return this
}, box2d.b2PolygonShape.prototype.SetAsBox = function(t, e) {
    return this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.SetZero(), this
}, box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(t, e, i, o) {
    this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.Copy(i);
    var s = new box2d.b2Transform;
    s.SetPosition(i), s.SetRotationAngleRadians(o);
    for (var n = 0, r = this.m_count; n < r; ++n) box2d.b2MulXV(s, this.m_vertices[n], this.m_vertices[n]), box2d.b2MulRV(s.q, this.m_normals[n], this.m_normals[n]);
    return this
}, box2d.b2PolygonShape.prototype.Set = function(t, e) {
    if (void 0 === e && (e = t.length), box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= e && e <= box2d.b2_maxPolygonVertices), e < 3) return this.SetAsBox(1, 1);
    for (var i = box2d.b2Min(e, box2d.b2_maxPolygonVertices), o = box2d.b2PolygonShape.prototype.Set.s_ps, s = 0, n = 0; n < i; ++n) {
        for (var r = t[n], a = !0, h = 0; h < s; ++h)
            if (box2d.b2DistanceSquaredVV(r, o[h]) < .5 * box2d.b2_linearSlop) {
                a = !1;
                break
            }
        a && o[s++].Copy(r)
    }
    if ((i = s) < 3) return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), this.SetAsBox(1, 1);
    var l = 0,
        d = o[0].x;
    for (n = 1; n < i; ++n) {
        var c = o[n].x;
        (d < c || c === d && o[n].y < o[l].y) && (l = n, d = c)
    }
    for (var u = box2d.b2PolygonShape.prototype.Set.s_hull, p = 0, b = l;;) {
        u[p] = b;
        var m = 0;
        for (h = 1; h < i; ++h)
            if (m !== b) {
                var y = box2d.b2SubVV(o[m], o[u[p]], box2d.b2PolygonShape.prototype.Set.s_r),
                    f = (r = box2d.b2SubVV(o[h], o[u[p]], box2d.b2PolygonShape.prototype.Set.s_v), box2d.b2CrossVV(y, r));
                f < 0 && (m = h), 0 === f && r.GetLengthSquared() > y.GetLengthSquared() && (m = h)
            } else m = h;
        if (++p, (b = m) === l) break
    }
    this.m_count = p;
    for (n = 0; n < p; ++n) this.m_vertices[n].Copy(o[u[n]]);
    n = 0;
    for (var x = p; n < x; ++n) {
        var g = this.m_vertices[n],
            _ = this.m_vertices[(n + 1) % x],
            v = box2d.b2SubVV(_, g, box2d.b2Vec2.s_t0);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(v.GetLengthSquared() > box2d.b2_epsilon_sq), box2d.b2CrossVOne(v, this.m_normals[n]).SelfNormalize()
    }
    return box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, p, this.m_centroid), this
}, box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetAsVector = function(t, e) {
    return this.Set(t, e), this
}, box2d.b2PolygonShape.prototype.SetAsArray = function(t, e) {
    return this.Set(t, e), this
}, box2d.b2PolygonShape.prototype.GetChildCount = function() {
    return 1
}, box2d.b2PolygonShape.prototype.TestPoint = function(t, e) {
    for (var i = box2d.b2MulTXV(t, e, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), o = 0, s = this.m_count; o < s; ++o) {
        if (0 < box2d.b2DotVV(this.m_normals[o], box2d.b2SubVV(i, this.m_vertices[o], box2d.b2Vec2.s_t0))) return !1
    }
    return !0
}, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast = function(t, e, i) {
    for (var o = box2d.b2MulTXV(i, e.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1), s = box2d.b2MulTXV(i, e.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), n = box2d.b2SubVV(s, o, box2d.b2PolygonShape.prototype.RayCast.s_d), r = 0, a = e.maxFraction, h = -1, l = 0, d = this.m_count; l < d; ++l) {
        var c = box2d.b2DotVV(this.m_normals[l], box2d.b2SubVV(this.m_vertices[l], o, box2d.b2Vec2.s_t0)),
            u = box2d.b2DotVV(this.m_normals[l], n);
        if (0 === u) {
            if (c < 0) return !1
        } else u < 0 && c < r * u ? (r = c / u, h = l) : 0 < u && c < a * u && (a = c / u);
        if (a < r) return !1
    }
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= r && r <= e.maxFraction), 0 <= h && (t.fraction = r, box2d.b2MulRV(i.q, this.m_normals[h], t.normal), !0)
}, box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeAABB = function(t, e) {
    for (var i = box2d.b2MulXV(e, this.m_vertices[0], t.lowerBound), o = t.upperBound.Copy(i), s = 0, n = this.m_count; s < n; ++s) {
        var r = box2d.b2MulXV(e, this.m_vertices[s], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(r, i, i), box2d.b2MaxV(r, o, o)
    }
    var a = this.m_radius;
    i.SelfSubXY(a, a), o.SelfAddXY(a, a)
}, box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= this.m_count);
    for (var i = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), o = 0, s = 0, n = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), r = 0, a = this.m_count; r < a; ++r) n.SelfAdd(this.m_vertices[r]);
    n.SelfMul(1 / this.m_count);
    for (r = 0, a = this.m_count; r < a; ++r) {
        var h = box2d.b2SubVV(this.m_vertices[r], n, box2d.b2PolygonShape.prototype.ComputeMass.s_e1),
            l = box2d.b2SubVV(this.m_vertices[(r + 1) % a], n, box2d.b2PolygonShape.prototype.ComputeMass.s_e2),
            d = box2d.b2CrossVV(h, l),
            c = .5 * d;
        o += c, i.SelfAdd(box2d.b2MulSV(c * (1 / 3), box2d.b2AddVV(h, l, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
        var u = h.x,
            p = h.y,
            b = l.x,
            m = l.y;
        s += 1 / 3 * .25 * d * (u * u + b * u + b * b + (p * p + m * p + m * m))
    }
    t.mass = e * o, box2d.ENABLE_ASSERTS && box2d.b2Assert(o > box2d.b2_epsilon), i.SelfMul(1 / o), box2d.b2AddVV(i, n, t.center), t.I = e * s, t.I += t.mass * (box2d.b2DotVV(t.center, t.center) - box2d.b2DotVV(i, i))
}, box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate = function() {
    for (var t = 0; t < this.m_count; ++t)
        for (var e = t, i = (t + 1) % this.m_count, o = this.m_vertices[e], s = box2d.b2SubVV(this.m_vertices[i], o, box2d.b2PolygonShape.prototype.Validate.s_e), n = 0; n < this.m_count; ++n)
            if (n !== e && n !== i) {
                var r = box2d.b2SubVV(this.m_vertices[n], o, box2d.b2PolygonShape.prototype.Validate.s_v);
                if (box2d.b2CrossVV(s, r) < 0) return !1
            }
    return !0
}, box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(t) {
    t.m_vertices = this.m_vertices, t.m_count = this.m_count, t.m_radius = this.m_radius
}, box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    for (var s = box2d.b2MulTRV(i.q, t, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), n = e - box2d.b2DotVV(t, i.p), r = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, a = 0, h = -1, l = -1, d = !1, c = 0, u = this.m_count; c < u; ++c) {
        r[c] = box2d.b2DotVV(s, this.m_vertices[c]) - n;
        var p = r[c] < -box2d.b2_epsilon;
        0 < c && (p ? d || (h = c - 1, a++) : d && (l = c - 1, a++)), d = p
    }
    switch (a) {
        case 0:
            if (d) {
                var b = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md;
                return this.ComputeMass(b, 1), box2d.b2MulXV(i, b.center, o), b.mass
            }
            return 0;
        case 1:
            -1 === h ? h = this.m_count - 1 : l = this.m_count - 1
    }
    var m = (h + 1) % this.m_count,
        y = (l + 1) % this.m_count,
        f = (0 - r[h]) / (r[m] - r[h]),
        x = (0 - r[l]) / (r[y] - r[l]),
        g = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[h].x * (1 - f) + this.m_vertices[m].x * f, this.m_vertices[h].y * (1 - f) + this.m_vertices[m].y * f),
        _ = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[l].x * (1 - x) + this.m_vertices[y].x * x, this.m_vertices[l].y * (1 - x) + this.m_vertices[y].y * x),
        v = 0,
        S = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero(),
        C = this.m_vertices[m],
        w = null;
    for (c = m; c !== y;) {
        w = (c = (c + 1) % this.m_count) === y ? _ : this.m_vertices[c];
        var A = .5 * ((C.x - g.x) * (w.y - g.y) - (C.y - g.y) * (w.x - g.x));
        v += A, S.x += A * (g.x + C.x + w.x) / 3, S.y += A * (g.y + C.y + w.y) / 3, C = w
    }
    return S.SelfMul(1 / v), box2d.b2MulXV(i, S, o), v
}, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count)
}, box2d.b2PolygonShape.ComputeCentroid = function(t, e, i) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= e);
    var o = i;
    o.SetZero();
    for (var s = 0, n = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), r = 0; r < e; ++r) {
        var a = n,
            h = t[r],
            l = t[(r + 1) % e],
            d = box2d.b2SubVV(h, a, box2d.b2PolygonShape.ComputeCentroid.s_e1),
            c = box2d.b2SubVV(l, a, box2d.b2PolygonShape.ComputeCentroid.s_e2),
            u = .5 * box2d.b2CrossVV(d, c);
        s += u, o.x += u * (1 / 3) * (a.x + h.x + l.x), o.y += u * (1 / 3) * (a.y + h.y + l.y)
    }
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(s > box2d.b2_epsilon), o.SelfMul(1 / s), o
}, box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2, goog.provide("box2d.b2CollideEdge"), goog.require("box2d.b2Collision"), box2d.b2CollideEdgeAndCircle = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = box2d.b2MulTXV(i, box2d.b2MulXV(s, o.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q),
        r = e.m_vertex1,
        a = e.m_vertex2,
        h = box2d.b2SubVV(a, r, box2d.b2CollideEdgeAndCircle.s_e),
        l = box2d.b2DotVV(h, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)),
        d = box2d.b2DotVV(h, box2d.b2SubVV(n, r, box2d.b2Vec2.s_t0)),
        c = e.m_radius + o.m_radius,
        u = box2d.b2CollideEdgeAndCircle.s_id;
    if (u.cf.indexB = 0, u.cf.typeB = box2d.b2ContactFeatureType.e_vertex, d <= 0) {
        var p = r,
            b = box2d.b2SubVV(n, p, box2d.b2CollideEdgeAndCircle.s_d);
        if (c * c < box2d.b2DotVV(b, b)) return;
        if (e.m_hasVertex0) {
            var m = e.m_vertex0,
                y = r,
                f = box2d.b2SubVV(y, m, box2d.b2CollideEdgeAndCircle.s_e1);
            if (0 < box2d.b2DotVV(f, box2d.b2SubVV(y, n, box2d.b2Vec2.s_t0))) return
        }
        return u.cf.indexA = 0, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(p), t.points[0].id.Copy(u), void t.points[0].localPoint.Copy(o.m_p)
    }
    if (l <= 0) {
        p = a, b = box2d.b2SubVV(n, p, box2d.b2CollideEdgeAndCircle.s_d);
        if (c * c < box2d.b2DotVV(b, b)) return;
        if (e.m_hasVertex3) {
            var x = e.m_vertex3,
                g = a,
                _ = box2d.b2SubVV(x, g, box2d.b2CollideEdgeAndCircle.s_e2);
            if (0 < box2d.b2DotVV(_, box2d.b2SubVV(n, g, box2d.b2Vec2.s_t0))) return
        }
        return u.cf.indexA = 1, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(p), t.points[0].id.Copy(u), void t.points[0].localPoint.Copy(o.m_p)
    }
    var v = box2d.b2DotVV(h, h);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < v), (p = box2d.b2CollideEdgeAndCircle.s_P).x = 1 / v * (l * r.x + d * a.x), p.y = 1 / v * (l * r.y + d * a.y);
    b = box2d.b2SubVV(n, p, box2d.b2CollideEdgeAndCircle.s_d);
    if (!(c * c < box2d.b2DotVV(b, b))) {
        var S = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x);
        box2d.b2DotVV(S, box2d.b2SubVV(n, r, box2d.b2Vec2.s_t0)) < 0 && S.SetXY(-S.x, -S.y), S.Normalize(), u.cf.indexA = 0, u.cf.typeA = box2d.b2ContactFeatureType.e_face, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(S), t.localPoint.Copy(r), t.points[0].id.Copy(u), t.points[0].localPoint.Copy(o.m_p)
    }
}, box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID, box2d.b2EPAxisType = {
    e_unknown: 0,
    e_edgeA: 1,
    e_edgeB: 2
}, goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown), goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA), goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB), box2d.b2EPAxis = function() {}, box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown, box2d.b2EPAxis.prototype.index = 0, box2d.b2EPAxis.prototype.separation = 0, box2d.b2TempPolygon = function() {
    this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.count = 0
}, box2d.b2TempPolygon.prototype.vertices = null, box2d.b2TempPolygon.prototype.normals = null, box2d.b2TempPolygon.prototype.count = 0, box2d.b2ReferenceFace = function() {
    this.i1 = 0, this.i2 = 0, this.v1 = new box2d.b2Vec2, this.v2 = new box2d.b2Vec2, this.normal = new box2d.b2Vec2, this.sideNormal1 = new box2d.b2Vec2, this.sideOffset1 = 0, this.sideNormal2 = new box2d.b2Vec2, this.sideOffset2 = 0
}, box2d.b2ReferenceFace.prototype.i1 = 0, box2d.b2ReferenceFace.prototype.i2 = 0, box2d.b2ReferenceFace.prototype.v1 = null, box2d.b2ReferenceFace.prototype.v2 = null, box2d.b2ReferenceFace.prototype.normal = null, box2d.b2ReferenceFace.prototype.sideNormal1 = null, box2d.b2ReferenceFace.prototype.sideOffset1 = 0, box2d.b2ReferenceFace.prototype.sideNormal2 = null, box2d.b2ReferenceFace.prototype.sideOffset2 = 0, box2d.b2EPColliderVertexType = {
    e_isolated: 0,
    e_concave: 1,
    e_convex: 2
}, goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated), goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave), goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex), box2d.b2EPCollider = function() {
    this.m_polygonB = new box2d.b2TempPolygon, this.m_xf = new box2d.b2Transform, this.m_centroidB = new box2d.b2Vec2, this.m_v0 = new box2d.b2Vec2, this.m_v1 = new box2d.b2Vec2, this.m_v2 = new box2d.b2Vec2, this.m_v3 = new box2d.b2Vec2, this.m_normal0 = new box2d.b2Vec2, this.m_normal1 = new box2d.b2Vec2, this.m_normal2 = new box2d.b2Vec2, this.m_normal = new box2d.b2Vec2, this.m_type1 = box2d.b2EPColliderVertexType.e_isolated, this.m_type2 = box2d.b2EPColliderVertexType.e_isolated, this.m_lowerLimit = new box2d.b2Vec2, this.m_upperLimit = new box2d.b2Vec2, this.m_radius = 0, this.m_front = !1
}, box2d.b2EPCollider.prototype.m_polygonB = null, box2d.b2EPCollider.prototype.m_xf = null, box2d.b2EPCollider.prototype.m_centroidB = null, box2d.b2EPCollider.prototype.m_v0 = null, box2d.b2EPCollider.prototype.m_v1 = null, box2d.b2EPCollider.prototype.m_v2 = null, box2d.b2EPCollider.prototype.m_v3 = null, box2d.b2EPCollider.prototype.m_normal0 = null, box2d.b2EPCollider.prototype.m_normal1 = null, box2d.b2EPCollider.prototype.m_normal2 = null, box2d.b2EPCollider.prototype.m_normal = null, box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_lowerLimit = null, box2d.b2EPCollider.prototype.m_upperLimit = null, box2d.b2EPCollider.prototype.m_radius = 0, box2d.b2EPCollider.prototype.m_front = !1, box2d.b2EPCollider.prototype.Collide = function(t, e, i, o, s) {
    box2d.b2MulTXX(i, s, this.m_xf), box2d.b2MulXV(this.m_xf, o.m_centroid, this.m_centroidB), this.m_v0.Copy(e.m_vertex0), this.m_v1.Copy(e.m_vertex1), this.m_v2.Copy(e.m_vertex2), this.m_v3.Copy(e.m_vertex3);
    var n = e.m_hasVertex0,
        r = e.m_hasVertex3,
        a = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    a.Normalize(), this.m_normal1.SetXY(a.y, -a.x);
    var h = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)),
        l = 0,
        d = 0,
        c = !1,
        u = !1;
    if (n) {
        var p = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0);
        p.Normalize(), this.m_normal0.SetXY(p.y, -p.x), c = 0 <= box2d.b2CrossVV(p, a), l = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0))
    }
    if (r) {
        var b = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2);
        b.Normalize(), this.m_normal2.SetXY(b.y, -b.x), u = 0 < box2d.b2CrossVV(a, b), d = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0))
    }
    n && r ? c && u ? (this.m_front = 0 <= l || 0 <= h || 0 <= d, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : c ? (this.m_front = 0 <= l || 0 <= h && 0 <= d, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : u ? (this.m_front = 0 <= d || 0 <= l && 0 <= h, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : (this.m_front = 0 <= l && 0 <= h && 0 <= d, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : n ? c ? (this.m_front = 0 <= l || 0 <= h, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1)), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_front = 0 <= l && 0 <= h, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : r ? u ? (this.m_front = 0 <= h || 0 <= d, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1))) : (this.m_front = 0 <= h && 0 <= d, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg()), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_front = 0 <= h, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1))), this.m_polygonB.count = o.m_count;
    for (var m = 0, y = o.m_count; m < y; ++m) box2d.b2MulXV(this.m_xf, o.m_vertices[m], this.m_polygonB.vertices[m]), box2d.b2MulRV(this.m_xf.q, o.m_normals[m], this.m_polygonB.normals[m]);
    this.m_radius = 2 * box2d.b2_polygonRadius, t.pointCount = 0;
    var f = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
    if (f.type !== box2d.b2EPAxisType.e_unknown && !(f.separation > this.m_radius)) {
        var x = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis);
        if (!(x.type !== box2d.b2EPAxisType.e_unknown && x.separation > this.m_radius)) {
            var g;
            g = x.type === box2d.b2EPAxisType.e_unknown ? f : x.separation > .98 * f.separation + .001 ? x : f;
            var _ = box2d.b2EPCollider.s_ie,
                v = box2d.b2EPCollider.s_rf;
            if (g.type === box2d.b2EPAxisType.e_edgeA) {
                t.type = box2d.b2ManifoldType.e_faceA;
                var S = 0,
                    C = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);
                for (m = 1, y = this.m_polygonB.count; m < y; ++m) {
                    var w = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[m]);
                    w < C && (C = w, S = m)
                }
                var A = S,
                    P = (A + 1) % this.m_polygonB.count;
                (T = _[0]).v.Copy(this.m_polygonB.vertices[A]), T.id.cf.indexA = 0, T.id.cf.indexB = A, T.id.cf.typeA = box2d.b2ContactFeatureType.e_face, T.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex, (B = _[1]).v.Copy(this.m_polygonB.vertices[P]), B.id.cf.indexA = 0, B.id.cf.indexB = P, B.id.cf.typeA = box2d.b2ContactFeatureType.e_face, B.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex, this.m_front ? (v.i1 = 0, v.i2 = 1, v.v1.Copy(this.m_v1), v.v2.Copy(this.m_v2), v.normal.Copy(this.m_normal1)) : (v.i1 = 1, v.i2 = 0, v.v1.Copy(this.m_v2), v.v2.Copy(this.m_v1), v.normal.Copy(this.m_normal1).SelfNeg())
            } else {
                var T, B;
                t.type = box2d.b2ManifoldType.e_faceB, (T = _[0]).v.Copy(this.m_v1), T.id.cf.indexA = 0, T.id.cf.indexB = g.index, T.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, T.id.cf.typeB = box2d.b2ContactFeatureType.e_face, (B = _[1]).v.Copy(this.m_v2), B.id.cf.indexA = 0, B.id.cf.indexB = g.index, B.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, B.id.cf.typeB = box2d.b2ContactFeatureType.e_face, v.i1 = g.index, v.i2 = (v.i1 + 1) % this.m_polygonB.count, v.v1.Copy(this.m_polygonB.vertices[v.i1]), v.v2.Copy(this.m_polygonB.vertices[v.i2]), v.normal.Copy(this.m_polygonB.normals[v.i1])
            }
            v.sideNormal1.SetXY(v.normal.y, -v.normal.x), v.sideNormal2.Copy(v.sideNormal1).SelfNeg(), v.sideOffset1 = box2d.b2DotVV(v.sideNormal1, v.v1), v.sideOffset2 = box2d.b2DotVV(v.sideNormal2, v.v2);
            var M = box2d.b2EPCollider.s_clipPoints1,
                E = box2d.b2EPCollider.s_clipPoints2;
            if (!(box2d.b2ClipSegmentToLine(M, _, v.sideNormal1, v.sideOffset1, v.i1) < box2d.b2_maxManifoldPoints || box2d.b2ClipSegmentToLine(E, M, v.sideNormal2, v.sideOffset2, v.i2) < box2d.b2_maxManifoldPoints)) {
                g.type === box2d.b2EPAxisType.e_edgeA ? (t.localNormal.Copy(v.normal), t.localPoint.Copy(v.v1)) : (t.localNormal.Copy(o.m_normals[v.i1]), t.localPoint.Copy(o.m_vertices[v.i1]));
                var I = 0;
                for (m = 0, y = box2d.b2_maxManifoldPoints; m < y; ++m) {
                    if (box2d.b2DotVV(v.normal, box2d.b2SubVV(E[m].v, v.v1, box2d.b2Vec2.s_t0)) <= this.m_radius) {
                        var V = t.points[I];
                        g.type === box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, E[m].v, V.localPoint), V.id = E[m].id) : (V.localPoint.Copy(E[m].v), V.id.cf.typeA = E[m].id.cf.typeB, V.id.cf.typeB = E[m].id.cf.typeA, V.id.cf.indexA = E[m].id.cf.indexB, V.id.cf.indexB = E[m].id.cf.indexA), ++I
                    }
                }
                t.pointCount = I
            }
        }
    }
}, box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2, box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace, box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis, box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis, box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(t) {
    var e = t;
    e.type = box2d.b2EPAxisType.e_edgeA, e.index = this.m_front ? 0 : 1, e.separation = box2d.b2_maxFloat;
    for (var i = 0, o = this.m_polygonB.count; i < o; ++i) {
        var s = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));
        s < e.separation && (e.separation = s)
    }
    return e
}, box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(t) {
    var e = t;
    e.type = box2d.b2EPAxisType.e_unknown, e.index = -1, e.separation = -box2d.b2_maxFloat;
    for (var i = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), o = 0, s = this.m_polygonB.count; o < s; ++o) {
        var n = box2d.b2NegV(this.m_polygonB.normals[o], box2d.b2EPCollider.s_n),
            r = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v1, box2d.b2Vec2.s_t0)),
            a = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v2, box2d.b2Vec2.s_t0)),
            h = box2d.b2Min(r, a);
        if (h > this.m_radius) return e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h, e;
        if (0 <= box2d.b2DotVV(n, i)) {
            if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue
        } else if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue;
        h > e.separation && (e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h)
    }
    return e
}, box2d.b2EPCollider.s_n = new box2d.b2Vec2, box2d.b2EPCollider.s_perp = new box2d.b2Vec2, box2d.b2CollideEdgeAndPolygon = function(t, e, i, o, s) {
    box2d.b2CollideEdgeAndPolygon.s_collider.Collide(t, e, i, o, s)
}, box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider, goog.provide("box2d.b2EdgeShape"), goog.require("box2d.b2Shape"), box2d.b2EdgeShape = function() {
    goog.base(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius), this.m_vertex1 = new box2d.b2Vec2, this.m_vertex2 = new box2d.b2Vec2, this.m_vertex0 = new box2d.b2Vec2, this.m_vertex3 = new box2d.b2Vec2
}, goog.inherits(box2d.b2EdgeShape, box2d.b2Shape), box2d.b2EdgeShape.prototype.m_vertex1 = null, box2d.b2EdgeShape.prototype.m_vertex2 = null, box2d.b2EdgeShape.prototype.m_vertex0 = null, box2d.b2EdgeShape.prototype.m_vertex3 = null, box2d.b2EdgeShape.prototype.m_hasVertex0 = !1, box2d.b2EdgeShape.prototype.m_hasVertex3 = !1, box2d.b2EdgeShape.prototype.Set = function(t, e) {
    return this.m_vertex1.Copy(t), this.m_vertex2.Copy(e), this.m_hasVertex0 = !1, this.m_hasVertex3 = !1, this
}, box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set, box2d.b2EdgeShape.prototype.Clone = function() {
    return (new box2d.b2EdgeShape).Copy(this)
}, box2d.b2EdgeShape.prototype.Copy = function(t) {
    return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2EdgeShape), this.m_vertex1.Copy(t.m_vertex1), this.m_vertex2.Copy(t.m_vertex2), this.m_vertex0.Copy(t.m_vertex0), this.m_vertex3.Copy(t.m_vertex3), this.m_hasVertex0 = t.m_hasVertex0, this.m_hasVertex3 = t.m_hasVertex3, this
}, box2d.b2EdgeShape.prototype.GetChildCount = function() {
    return 1
}, box2d.b2EdgeShape.prototype.TestPoint = function() {
    return !1
}, box2d.b2EdgeShape.prototype.RayCast = function(t, e, i) {
    var o = box2d.b2MulTXV(i, e.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1),
        s = box2d.b2MulTXV(i, e.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2),
        n = box2d.b2SubVV(s, o, box2d.b2EdgeShape.prototype.RayCast.s_d),
        r = this.m_vertex1,
        a = this.m_vertex2,
        h = box2d.b2SubVV(a, r, box2d.b2EdgeShape.prototype.RayCast.s_e),
        l = t.normal.SetXY(h.y, -h.x).SelfNormalize(),
        d = box2d.b2DotVV(l, box2d.b2SubVV(r, o, box2d.b2Vec2.s_t0)),
        c = box2d.b2DotVV(l, n);
    if (0 === c) return !1;
    var u = d / c;
    if (u < 0 || e.maxFraction < u) return !1;
    var p = box2d.b2AddVMulSV(o, u, n, box2d.b2EdgeShape.prototype.RayCast.s_q),
        b = box2d.b2SubVV(a, r, box2d.b2EdgeShape.prototype.RayCast.s_r),
        m = box2d.b2DotVV(b, b);
    if (0 === m) return !1;
    var y = box2d.b2DotVV(box2d.b2SubVV(p, r, box2d.b2Vec2.s_t0), b) / m;
    return !(y < 0 || 1 < y) && (t.fraction = u, box2d.b2MulRV(i.q, t.normal, t.normal), 0 < d && t.normal.SelfNeg(), !0)
}, box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB = function(t, e) {
    var i = box2d.b2MulXV(e, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1),
        o = box2d.b2MulXV(e, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(i, o, t.lowerBound), box2d.b2MaxV(i, o, t.upperBound);
    var s = this.m_radius;
    t.lowerBound.SelfSubXY(s, s), t.upperBound.SelfAddXY(s, s)
}, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeMass = function(t) {
    t.mass = 0, box2d.b2MidVV(this.m_vertex1, this.m_vertex2, t.center), t.I = 0
}, box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(t) {
    t.m_vertices = new Array(2), t.m_vertices[0] = this.m_vertex1, t.m_vertices[1] = this.m_vertex2, t.m_count = 2, t.m_radius = this.m_radius
}, box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    return o.SetZero(), 0
}, box2d.b2EdgeShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y), box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y), box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y), box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y), box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0), box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3)
}, goog.provide("box2d.b2ChainShape"), goog.require("box2d.b2Shape"), goog.require("box2d.b2EdgeShape"), box2d.b2ChainShape = function() {
    goog.base(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius), this.m_prevVertex = new box2d.b2Vec2, this.m_nextVertex = new box2d.b2Vec2
}, goog.inherits(box2d.b2ChainShape, box2d.b2Shape), box2d.b2ChainShape.prototype.m_vertices = null, box2d.b2ChainShape.prototype.m_count = 0, box2d.b2ChainShape.prototype.m_prevVertex = null, box2d.b2ChainShape.prototype.m_nextVertex = null, box2d.b2ChainShape.prototype.m_hasPrevVertex = !1, box2d.b2ChainShape.prototype.m_hasNextVertex = !1, box2d.b2ChainShape.prototype.CreateLoop = function(t, e) {
    if (e = e || t.length, box2d.ENABLE_ASSERTS && box2d.b2Assert(null === this.m_vertices && 0 === this.m_count), box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= e), box2d.ENABLE_ASSERTS)
        for (var i = 1; i < e; ++i) {
            var o = t[i - 1],
                s = t[i];
            box2d.b2Assert(box2d.b2DistanceSquaredVV(o, s) > box2d.b2_linearSlop * box2d.b2_linearSlop)
        }
    this.m_count = e + 1, this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
    for (i = 0; i < e; ++i) this.m_vertices[i].Copy(t[i]);
    return this.m_vertices[e].Copy(this.m_vertices[0]), this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]), this.m_nextVertex.Copy(this.m_vertices[1]), this.m_hasPrevVertex = !0, this.m_hasNextVertex = !0, this
}, box2d.b2ChainShape.prototype.CreateChain = function(t, e) {
    if (e = e || t.length, box2d.ENABLE_ASSERTS && box2d.b2Assert(null === this.m_vertices && 0 === this.m_count), box2d.ENABLE_ASSERTS && box2d.b2Assert(2 <= e), box2d.ENABLE_ASSERTS)
        for (var i = 1; i < e; ++i) {
            var o = t[i - 1],
                s = t[i];
            box2d.b2Assert(box2d.b2DistanceSquaredVV(o, s) > box2d.b2_linearSlop * box2d.b2_linearSlop)
        }
    this.m_count = e, this.m_vertices = box2d.b2Vec2.MakeArray(e);
    for (i = 0; i < e; ++i) this.m_vertices[i].Copy(t[i]);
    return this.m_hasPrevVertex = !1, this.m_hasNextVertex = !1, this.m_prevVertex.SetZero(), this.m_nextVertex.SetZero(), this
}, box2d.b2ChainShape.prototype.SetPrevVertex = function(t) {
    return this.m_prevVertex.Copy(t), this.m_hasPrevVertex = !0, this
}, box2d.b2ChainShape.prototype.SetNextVertex = function(t) {
    return this.m_nextVertex.Copy(t), this.m_hasNextVertex = !0, this
}, box2d.b2ChainShape.prototype.Clone = function() {
    return (new box2d.b2ChainShape).Copy(this)
}, box2d.b2ChainShape.prototype.Copy = function(t) {
    return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2ChainShape), this.CreateChain(t.m_vertices, t.m_count), this.m_prevVertex.Copy(t.m_prevVertex), this.m_nextVertex.Copy(t.m_nextVertex), this.m_hasPrevVertex = t.m_hasPrevVertex, this.m_hasNextVertex = t.m_hasNextVertex, this
}, box2d.b2ChainShape.prototype.GetChildCount = function() {
    return this.m_count - 1
}, box2d.b2ChainShape.prototype.GetChildEdge = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= e && e < this.m_count - 1), t.m_type = box2d.b2ShapeType.e_edgeShape, t.m_radius = this.m_radius, t.m_vertex1.Copy(this.m_vertices[e]), t.m_vertex2.Copy(this.m_vertices[e + 1]), t.m_hasVertex0 = 0 < e ? (t.m_vertex0.Copy(this.m_vertices[e - 1]), !0) : (t.m_vertex0.Copy(this.m_prevVertex), this.m_hasPrevVertex), e < this.m_count - 2 ? (t.m_vertex3.Copy(this.m_vertices[e + 2]), t.m_hasVertex3 = !0) : (t.m_vertex3.Copy(this.m_nextVertex), t.m_hasVertex3 = this.m_hasNextVertex)
}, box2d.b2ChainShape.prototype.TestPoint = function() {
    return !1
}, box2d.b2ChainShape.prototype.RayCast = function(t, e, i, o) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o < this.m_count);
    var s = box2d.b2ChainShape.s_edgeShape;
    return s.m_vertex1.Copy(this.m_vertices[o]), s.m_vertex2.Copy(this.m_vertices[(o + 1) % this.m_count]), s.RayCast(t, e, i, 0)
}, box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape, box2d.b2ChainShape.prototype.ComputeAABB = function(t, e, i) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(i < this.m_count);
    var o = this.m_vertices[i],
        s = this.m_vertices[(i + 1) % this.m_count],
        n = box2d.b2MulXV(e, o, box2d.b2ChainShape.prototype.ComputeAABB.s_v1),
        r = box2d.b2MulXV(e, s, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(n, r, t.lowerBound), box2d.b2MaxV(n, r, t.upperBound)
}, box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeMass = function(t) {
    t.mass = 0, t.center.SetZero(), t.I = 0
}, box2d.b2ChainShape.prototype.SetupDistanceProxy = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= e && e < this.m_count), t.m_buffer[0].Copy(this.m_vertices[e]), t.m_buffer[1].Copy(e + 1 < this.m_count ? this.m_vertices[e + 1] : this.m_vertices[0]), t.m_vertices = t.m_buffer, t.m_count = 2, t.m_radius = this.m_radius
}, box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    return o.SetZero(), 0
}, box2d.b2ChainShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count), box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y), box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y), box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false"), box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false")
}, goog.provide("box2d.b2ChainAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), box2d.b2ChainAndPolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact), box2d.b2ChainAndPolygonContact.Create = function() {
    return new box2d.b2ChainAndPolygonContact
}, box2d.b2ChainAndPolygonContact.Destroy = function() {}, box2d.b2ChainAndPolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_chainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_polygonShape)
}, box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2ChainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2PolygonShape);
    var n = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    n.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndPolygon(t, r, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2CollidePolygon"), goog.require("box2d.b2Collision"), box2d.b2FindMaxSeparation = function(t, e, i, o, s) {
    for (var n = e.m_count, r = o.m_count, a = e.m_normals, h = e.m_vertices, l = o.m_vertices, d = box2d.b2MulTXX(s, i, box2d.b2FindMaxSeparation.s_xf), c = 0, u = -box2d.b2_maxFloat, p = 0; p < n; ++p) {
        for (var b = box2d.b2MulRV(d.q, a[p], box2d.b2FindMaxSeparation.s_n), m = box2d.b2MulXV(d, h[p], box2d.b2FindMaxSeparation.s_v1), y = box2d.b2_maxFloat, f = 0; f < r; ++f) {
            var x = box2d.b2DotVV(b, box2d.b2SubVV(l[f], m, box2d.b2Vec2.s_t0));
            x < y && (y = x)
        }
        u < y && (u = y, c = p)
    }
    return t[0] = c, u
}, box2d.b2FindMaxSeparation.s_xf = new box2d.b2Transform, box2d.b2FindMaxSeparation.s_n = new box2d.b2Vec2, box2d.b2FindMaxSeparation.s_v1 = new box2d.b2Vec2, box2d.b2FindIncidentEdge = function(t, e, i, o, s, n) {
    var r = e.m_count,
        a = e.m_normals,
        h = s.m_count,
        l = s.m_vertices,
        d = s.m_normals;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= o && o < r);
    for (var c = box2d.b2MulTRV(n.q, box2d.b2MulRV(i.q, a[o], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1), u = 0, p = box2d.b2_maxFloat, b = 0; b < h; ++b) {
        var m = box2d.b2DotVV(c, d[b]);
        m < p && (p = m, u = b)
    }
    var y = u,
        f = (y + 1) % h,
        x = t[0];
    box2d.b2MulXV(n, l[y], x.v);
    var g = x.id.cf;
    g.indexA = o, g.indexB = y, g.typeA = box2d.b2ContactFeatureType.e_face, g.typeB = box2d.b2ContactFeatureType.e_vertex;
    var _ = t[1];
    box2d.b2MulXV(n, l[f], _.v);
    var v = _.id.cf;
    v.indexA = o, v.indexB = f, v.typeA = box2d.b2ContactFeatureType.e_face, v.typeB = box2d.b2ContactFeatureType.e_vertex
}, box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2, box2d.b2CollidePolygons = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = e.m_radius + o.m_radius,
        r = box2d.b2CollidePolygons.s_edgeA;
    r[0] = 0;
    var a = box2d.b2FindMaxSeparation(r, e, i, o, s);
    if (!(n < a)) {
        var h = box2d.b2CollidePolygons.s_edgeB;
        h[0] = 0;
        var l = box2d.b2FindMaxSeparation(h, o, s, e, i);
        if (!(n < l)) {
            var d, c, u, p, b = 0,
                m = 0;
            m = .98 * a + .001 < l ? (d = o, c = e, u = s, p = i, b = h[0], t.type = box2d.b2ManifoldType.e_faceB, 1) : (d = e, c = o, u = i, p = s, b = r[0], t.type = box2d.b2ManifoldType.e_faceA, 0);
            var y = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(y, d, u, b, c, p);
            var f = d.m_count,
                x = d.m_vertices,
                g = b,
                _ = (b + 1) % f,
                v = x[g],
                S = x[_],
                C = box2d.b2SubVV(S, v, box2d.b2CollidePolygons.s_localTangent);
            C.Normalize();
            var w = box2d.b2CrossVOne(C, box2d.b2CollidePolygons.s_localNormal),
                A = box2d.b2MidVV(v, S, box2d.b2CollidePolygons.s_planePoint),
                P = box2d.b2MulRV(u.q, C, box2d.b2CollidePolygons.s_tangent),
                T = box2d.b2CrossVOne(P, box2d.b2CollidePolygons.s_normal),
                B = box2d.b2MulXV(u, v, box2d.b2CollidePolygons.s_v11),
                M = box2d.b2MulXV(u, S, box2d.b2CollidePolygons.s_v12),
                E = box2d.b2DotVV(T, B),
                I = -box2d.b2DotVV(P, B) + n,
                V = box2d.b2DotVV(P, M) + n,
                R = box2d.b2CollidePolygons.s_clipPoints1,
                L = box2d.b2CollidePolygons.s_clipPoints2,
                D = box2d.b2NegV(P, box2d.b2CollidePolygons.s_ntangent);
            if (!(box2d.b2ClipSegmentToLine(R, y, D, I, g) < 2 || box2d.b2ClipSegmentToLine(L, R, P, V, _) < 2)) {
                t.localNormal.Copy(w), t.localPoint.Copy(A);
                for (var F = 0, k = 0; k < box2d.b2_maxManifoldPoints; ++k) {
                    var G = L[k];
                    if (box2d.b2DotVV(T, G.v) - E <= n) {
                        var O = t.points[F];
                        if (box2d.b2MulTXV(p, G.v, O.localPoint), O.id.Copy(G.id), m) {
                            var N = O.id.cf;
                            O.id.cf.indexA = N.indexB, O.id.cf.indexB = N.indexA, O.id.cf.typeA = N.typeB, O.id.cf.typeB = N.typeA
                        }++F
                    }
                }
                t.pointCount = F
            }
        }
    }
}, box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2, box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2, goog.provide("box2d.b2PolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollidePolygon"), box2d.b2PolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2PolygonContact, box2d.b2Contact), box2d.b2PolygonContact.Create = function() {
    return new box2d.b2PolygonContact
}, box2d.b2PolygonContact.Destroy = function() {}, box2d.b2PolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2PolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2PolygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2PolygonShape), box2d.b2CollidePolygons(t, o instanceof box2d.b2PolygonShape ? o : null, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, goog.provide("box2d.b2CollideCircle"), goog.require("box2d.b2Collision"), box2d.b2CollideCircles = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = box2d.b2MulXV(i, e.m_p, box2d.b2CollideCircles.s_pA),
        r = box2d.b2MulXV(s, o.m_p, box2d.b2CollideCircles.s_pB),
        a = box2d.b2DistanceSquaredVV(n, r),
        h = e.m_radius + o.m_radius;
    h * h < a || (t.type = box2d.b2ManifoldType.e_circles, t.localPoint.Copy(e.m_p), t.localNormal.SetZero(), t.pointCount = 1, t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0)
}, box2d.b2CollideCircles.s_pA = new box2d.b2Vec2, box2d.b2CollideCircles.s_pB = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle = function(t, e, i, o, s) {
    t.pointCount = 0;
    for (var n = box2d.b2MulXV(s, o.m_p, box2d.b2CollidePolygonAndCircle.s_c), r = box2d.b2MulTXV(i, n, box2d.b2CollidePolygonAndCircle.s_cLocal), a = 0, h = -box2d.b2_maxFloat, l = e.m_radius + o.m_radius, d = e.m_count, c = e.m_vertices, u = e.m_normals, p = 0; p < d; ++p) {
        var b = box2d.b2DotVV(u[p], box2d.b2SubVV(r, c[p], box2d.b2Vec2.s_t0));
        if (l < b) return;
        h < b && (h = b, a = p)
    }
    var m = a,
        y = (m + 1) % d,
        f = c[m],
        x = c[y];
    if (h < box2d.b2_epsilon) return t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(u[a]), box2d.b2MidVV(f, x, t.localPoint), t.points[0].localPoint.Copy(o.m_p), void(t.points[0].id.key = 0);
    var g = box2d.b2DotVV(box2d.b2SubVV(r, f, box2d.b2Vec2.s_t0), box2d.b2SubVV(x, f, box2d.b2Vec2.s_t1)),
        _ = box2d.b2DotVV(box2d.b2SubVV(r, x, box2d.b2Vec2.s_t0), box2d.b2SubVV(f, x, box2d.b2Vec2.s_t1));
    if (g <= 0) {
        if (box2d.b2DistanceSquaredVV(r, f) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, f, t.localNormal).SelfNormalize(), t.localPoint.Copy(f), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    } else if (_ <= 0) {
        if (box2d.b2DistanceSquaredVV(r, x) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, x, t.localNormal).SelfNormalize(), t.localPoint.Copy(x), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    } else {
        var v = box2d.b2MidVV(f, x, box2d.b2CollidePolygonAndCircle.s_faceCenter);
        if (l < (h = box2d.b2DotVV(box2d.b2SubVV(r, v, box2d.b2Vec2.s_t1), u[m]))) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(u[m]).SelfNormalize(), t.localPoint.Copy(v), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    }
}, box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2, goog.provide("box2d.b2CircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideCircle"), box2d.b2CircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2CircleContact, box2d.b2Contact), box2d.b2CircleContact.Create = function() {
    return new box2d.b2CircleContact
}, box2d.b2CircleContact.Destroy = function() {}, box2d.b2CircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2CircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2CircleShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2CircleShape), box2d.b2CollideCircles(t, o instanceof box2d.b2CircleShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2ChainAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact), box2d.b2ChainAndCircleContact.Create = function() {
    return new box2d.b2ChainAndCircleContact
}, box2d.b2ChainAndCircleContact.Destroy = function() {}, box2d.b2ChainAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_chainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape)
}, box2d.b2ChainAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2ChainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2CircleShape);
    var n = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    n.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndCircle(t, r, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2EdgeAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact), box2d.b2EdgeAndCircleContact.Create = function() {
    return new box2d.b2EdgeAndCircleContact
}, box2d.b2EdgeAndCircleContact.Destroy = function() {}, box2d.b2EdgeAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_edgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape)
}, box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2EdgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2CircleShape), box2d.b2CollideEdgeAndCircle(t, o instanceof box2d.b2EdgeShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2ContactSolver"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2CircleContact"), goog.require("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2PolygonContact"), goog.require("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2ChainAndPolygonContact"), box2d.b2VelocityConstraintPoint = function() {
    this.rA = new box2d.b2Vec2, this.rB = new box2d.b2Vec2
}, box2d.b2VelocityConstraintPoint.prototype.rA = null, box2d.b2VelocityConstraintPoint.prototype.rB = null, box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.normalMass = 0, box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0, box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0, box2d.b2VelocityConstraintPoint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2VelocityConstraintPoint
    })
}, box2d.b2ContactVelocityConstraint = function() {
    this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints), this.normal = new box2d.b2Vec2, this.tangent = new box2d.b2Vec2, this.normalMass = new box2d.b2Mat22, this.K = new box2d.b2Mat22
}, box2d.b2ContactVelocityConstraint.prototype.points = null, box2d.b2ContactVelocityConstraint.prototype.normal = null, box2d.b2ContactVelocityConstraint.prototype.tangent = null, box2d.b2ContactVelocityConstraint.prototype.normalMass = null, box2d.b2ContactVelocityConstraint.prototype.K = null, box2d.b2ContactVelocityConstraint.prototype.indexA = 0, box2d.b2ContactVelocityConstraint.prototype.indexB = 0, box2d.b2ContactVelocityConstraint.prototype.invMassA = 0, box2d.b2ContactVelocityConstraint.prototype.invMassB = 0, box2d.b2ContactVelocityConstraint.prototype.invIA = 0, box2d.b2ContactVelocityConstraint.prototype.invIB = 0, box2d.b2ContactVelocityConstraint.prototype.friction = 0, box2d.b2ContactVelocityConstraint.prototype.restitution = 0, box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0, box2d.b2ContactVelocityConstraint.prototype.pointCount = 0, box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0, box2d.b2ContactVelocityConstraint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2ContactVelocityConstraint
    })
}, box2d.b2ContactPositionConstraint = function() {
    this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.localCenterA = new box2d.b2Vec2, this.localCenterB = new box2d.b2Vec2
}, box2d.b2ContactPositionConstraint.prototype.localPoints = null, box2d.b2ContactPositionConstraint.prototype.localNormal = null, box2d.b2ContactPositionConstraint.prototype.localPoint = null, box2d.b2ContactPositionConstraint.prototype.indexA = 0, box2d.b2ContactPositionConstraint.prototype.indexB = 0, box2d.b2ContactPositionConstraint.prototype.invMassA = 0, box2d.b2ContactPositionConstraint.prototype.invMassB = 0, box2d.b2ContactPositionConstraint.prototype.localCenterA = null, box2d.b2ContactPositionConstraint.prototype.localCenterB = null, box2d.b2ContactPositionConstraint.prototype.invIA = 0, box2d.b2ContactPositionConstraint.prototype.invIB = 0, box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2ContactPositionConstraint.prototype.radiusA = 0, box2d.b2ContactPositionConstraint.prototype.radiusB = 0, box2d.b2ContactPositionConstraint.prototype.pointCount = 0, box2d.b2ContactPositionConstraint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2ContactPositionConstraint
    })
}, box2d.b2ContactSolverDef = function() {
    this.step = new box2d.b2TimeStep
}, box2d.b2ContactSolverDef.prototype.step = null, box2d.b2ContactSolverDef.prototype.contacts = null, box2d.b2ContactSolverDef.prototype.count = 0, box2d.b2ContactSolverDef.prototype.positions = null, box2d.b2ContactSolverDef.prototype.velocities = null, box2d.b2ContactSolverDef.prototype.allocator = null, box2d.b2ContactSolver = function() {
    this.m_step = new box2d.b2TimeStep, this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024), this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024)
}, box2d.b2ContactSolver.prototype.m_step = null, box2d.b2ContactSolver.prototype.m_positions = null, box2d.b2ContactSolver.prototype.m_velocities = null, box2d.b2ContactSolver.prototype.m_allocator = null, box2d.b2ContactSolver.prototype.m_positionConstraints = null, box2d.b2ContactSolver.prototype.m_velocityConstraints = null, box2d.b2ContactSolver.prototype.m_contacts = null, box2d.b2ContactSolver.prototype.m_count = 0, box2d.b2ContactSolver.prototype.Initialize = function(t) {
    if (this.m_step.Copy(t.step), this.m_allocator = t.allocator, this.m_count = t.count, this.m_positionConstraints.length < this.m_count) {
        var e = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count);
        for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + e); this.m_positionConstraints.length < e;) this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint
    }
    if (this.m_velocityConstraints.length < this.m_count) {
        e = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count);
        for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + e); this.m_velocityConstraints.length < e;) this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint
    }
    var i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g, _;
    for (this.m_positions = t.positions, this.m_velocities = t.velocities, this.m_contacts = t.contacts, i = 0, o = this.m_count; i < o; ++i)
        for (a = (r = this.m_contacts[i]).m_fixtureA, h = r.m_fixtureB, l = a.GetShape(), d = h.GetShape(), c = l.m_radius, u = d.m_radius, p = a.GetBody(), b = h.GetBody(), y = (m = r.GetManifold()).pointCount, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < y), (f = this.m_velocityConstraints[i]).friction = r.m_friction, f.restitution = r.m_restitution, f.tangentSpeed = r.m_tangentSpeed, f.indexA = p.m_islandIndex, f.indexB = b.m_islandIndex, f.invMassA = p.m_invMass, f.invMassB = b.m_invMass, f.invIA = p.m_invI, f.invIB = b.m_invI, f.contactIndex = i, f.pointCount = y, f.K.SetZero(), f.normalMass.SetZero(), (x = this.m_positionConstraints[i]).indexA = p.m_islandIndex, x.indexB = b.m_islandIndex, x.invMassA = p.m_invMass, x.invMassB = b.m_invMass, x.localCenterA.Copy(p.m_sweep.localCenter), x.localCenterB.Copy(b.m_sweep.localCenter), x.invIA = p.m_invI, x.invIB = b.m_invI, x.localNormal.Copy(m.localNormal), x.localPoint.Copy(m.localPoint), x.pointCount = y, x.radiusA = c, x.radiusB = u, x.type = m.type, s = 0, n = y; s < n; ++s) g = m.points[s], _ = f.points[s], this.m_step.warmStarting ? (_.normalImpulse = this.m_step.dtRatio * g.normalImpulse, _.tangentImpulse = this.m_step.dtRatio * g.tangentImpulse) : (_.normalImpulse = 0, _.tangentImpulse = 0), _.rA.SetZero(), _.rB.SetZero(), _.normalMass = 0, _.tangentMass = 0, _.velocityBias = 0, x.localPoints[s].Copy(g.localPoint);
    return this
}, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g, _, v, S, C, w, A, P, T, B, M, E, I, V, R, L, D, F, k, G, O, N, J, U, W = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA,
        X = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB,
        q = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (s = this.m_velocityConstraints[t], r = (n = this.m_positionConstraints[t]).radiusA, a = n.radiusB, h = this.m_contacts[s.contactIndex].GetManifold(), l = s.indexA, d = s.indexB, c = s.invMassA, u = s.invMassB, p = s.invIA, b = s.invIB, m = n.localCenterA, y = n.localCenterB, f = this.m_positions[l].c, x = this.m_positions[l].a, g = this.m_velocities[l].v, _ = this.m_velocities[l].w, v = this.m_positions[d].c, S = this.m_positions[d].a, C = this.m_velocities[d].v, w = this.m_velocities[d].w, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < h.pointCount), W.q.SetAngleRadians(x), X.q.SetAngleRadians(S), box2d.b2SubVV(f, box2d.b2MulRV(W.q, m, box2d.b2Vec2.s_t0), W.p), box2d.b2SubVV(v, box2d.b2MulRV(X.q, y, box2d.b2Vec2.s_t0), X.p), q.Initialize(h, W, r, X, a), s.normal.Copy(q.normal), box2d.b2CrossVOne(s.normal, s.tangent), i = 0, o = s.pointCount; i < o; ++i) A = s.points[i], box2d.b2SubVV(q.points[i], f, A.rA), box2d.b2SubVV(q.points[i], v, A.rB), B = c + u + p * (P = box2d.b2CrossVV(A.rA, s.normal)) * P + b * (T = box2d.b2CrossVV(A.rB, s.normal)) * T, A.normalMass = 0 < B ? 1 / B : 0, M = s.tangent, V = c + u + p * (E = box2d.b2CrossVV(A.rA, M)) * E + b * (I = box2d.b2CrossVV(A.rB, M)) * I, A.tangentMass = 0 < V ? 1 / V : 0, A.velocityBias = 0, (R = box2d.b2DotVV(s.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(C, w, A.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(g, _, A.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))) < -box2d.b2_velocityThreshold && (A.velocityBias += -s.restitution * R);
        2 === s.pointCount && (L = s.points[0], D = s.points[1], (N = c + u + p * (F = box2d.b2CrossVV(L.rA, s.normal)) * F + b * (k = box2d.b2CrossVV(L.rB, s.normal)) * k) * N < 1e3 * (N * (J = c + u + p * (G = box2d.b2CrossVV(D.rA, s.normal)) * G + b * (O = box2d.b2CrossVV(D.rB, s.normal)) * O) - (U = c + u + p * F * G + b * k * O) * U) ? (s.K.ex.SetXY(N, U), s.K.ey.SetXY(U, J), s.K.GetInverse(s.normalMass)) : s.pointCount = 1)
    }
}, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold, box2d.b2ContactSolver.prototype.WarmStart = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g = box2d.b2ContactSolver.prototype.WarmStart.s_P;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (n = (s = this.m_velocityConstraints[t]).indexA, r = s.indexB, a = s.invMassA, h = s.invIA, l = s.invMassB, d = s.invIB, c = s.pointCount, u = this.m_velocities[n].v, p = this.m_velocities[n].w, b = this.m_velocities[r].v, m = this.m_velocities[r].w, y = s.normal, f = s.tangent, i = 0, o = c; i < o; ++i) x = s.points[i], box2d.b2AddVV(box2d.b2MulSV(x.normalImpulse, y, box2d.b2Vec2.s_t0), box2d.b2MulSV(x.tangentImpulse, f, box2d.b2Vec2.s_t1), g), p -= h * box2d.b2CrossVV(x.rA, g), u.SelfMulSub(a, g), m += d * box2d.b2CrossVV(x.rB, g), b.SelfMulAdd(l, g);
        this.m_velocities[n].w = p, this.m_velocities[r].w = m
    }
}, box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g, _, v, S, C, w, A, P, T, B, M = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv,
        E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1,
        I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2,
        V = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P,
        R = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a,
        L = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b,
        D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
        F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d,
        k = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1,
        G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2,
        O = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (n = (s = this.m_velocityConstraints[t]).indexA, r = s.indexB, a = s.invMassA, h = s.invIA, l = s.invMassB, d = s.invIB, c = s.pointCount, u = this.m_velocities[n].v, p = this.m_velocities[n].w, b = this.m_velocities[r].v, m = this.m_velocities[r].w, y = s.normal, f = s.tangent, x = s.friction, box2d.ENABLE_ASSERTS && box2d.b2Assert(1 === c || 2 === c), i = 0, o = c; i < o; ++i) g = s.points[i], box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, g.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, g.rA, box2d.b2Vec2.s_t1), M), _ = box2d.b2DotVV(M, f) - s.tangentSpeed, S = g.tangentMass * -_, C = x * g.normalImpulse, S = (w = box2d.b2Clamp(g.tangentImpulse + S, -C, C)) - g.tangentImpulse, g.tangentImpulse = w, box2d.b2MulSV(S, f, V), u.SelfMulSub(a, V), p -= h * box2d.b2CrossVV(g.rA, V), b.SelfMulAdd(l, V), m += d * box2d.b2CrossVV(g.rB, V);
        if (1 === s.pointCount) g = s.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, g.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, g.rA, box2d.b2Vec2.s_t1), M), v = box2d.b2DotVV(M, y), S = -g.normalMass * (v - g.velocityBias), S = (w = box2d.b2Max(g.normalImpulse + S, 0)) - g.normalImpulse, g.normalImpulse = w, box2d.b2MulSV(S, y, V), u.SelfMulSub(a, V), p -= h * box2d.b2CrossVV(g.rA, V), b.SelfMulAdd(l, V), m += d * box2d.b2CrossVV(g.rB, V);
        else
            for (A = s.points[0], P = s.points[1], R.SetXY(A.normalImpulse, P.normalImpulse), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= R.x && 0 <= R.y), box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, A.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, A.rA, box2d.b2Vec2.s_t1), E), box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, P.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, P.rA, box2d.b2Vec2.s_t1), I), T = box2d.b2DotVV(E, y), B = box2d.b2DotVV(I, y), L.x = T - A.velocityBias, L.y = B - P.velocityBias, L.SelfSub(box2d.b2MulMV(s.K, R, box2d.b2Vec2.s_t0));;) {
                if (box2d.b2MulMV(s.normalMass, L, D).SelfNeg(), 0 <= D.x && 0 <= D.y) {
                    box2d.b2SubVV(D, R, F), box2d.b2MulSV(F.x, y, k), box2d.b2MulSV(F.y, y, G), box2d.b2AddVV(k, G, O), u.SelfMulSub(a, O), p -= h * (box2d.b2CrossVV(A.rA, k) + box2d.b2CrossVV(P.rA, G)), b.SelfMulAdd(l, O), m += d * (box2d.b2CrossVV(A.rB, k) + box2d.b2CrossVV(P.rB, G)), A.normalImpulse = D.x, P.normalImpulse = D.y;
                    break
                }
                if (D.x = -A.normalMass * L.x, T = D.y = 0, B = s.K.ex.y * D.x + L.y, 0 <= D.x && 0 <= B) {
                    box2d.b2SubVV(D, R, F), box2d.b2MulSV(F.x, y, k), box2d.b2MulSV(F.y, y, G), box2d.b2AddVV(k, G, O), u.SelfMulSub(a, O), p -= h * (box2d.b2CrossVV(A.rA, k) + box2d.b2CrossVV(P.rA, G)), b.SelfMulAdd(l, O), m += d * (box2d.b2CrossVV(A.rB, k) + box2d.b2CrossVV(P.rB, G)), A.normalImpulse = D.x, P.normalImpulse = D.y;
                    break
                }
                if (D.x = 0, D.y = -P.normalMass * L.y, T = s.K.ey.x * D.y + L.x, (B = 0) <= D.y && 0 <= T) {
                    box2d.b2SubVV(D, R, F), box2d.b2MulSV(F.x, y, k), box2d.b2MulSV(F.y, y, G), box2d.b2AddVV(k, G, O), u.SelfMulSub(a, O), p -= h * (box2d.b2CrossVV(A.rA, k) + box2d.b2CrossVV(P.rA, G)), b.SelfMulAdd(l, O), m += d * (box2d.b2CrossVV(A.rB, k) + box2d.b2CrossVV(P.rB, G)), A.normalImpulse = D.x, P.normalImpulse = D.y;
                    break
                }
                if (D.x = 0, D.y = 0, T = L.x, B = L.y, 0 <= T && 0 <= B) {
                    box2d.b2SubVV(D, R, F), box2d.b2MulSV(F.x, y, k), box2d.b2MulSV(F.y, y, G), box2d.b2AddVV(k, G, O), u.SelfMulSub(a, O), p -= h * (box2d.b2CrossVV(A.rA, k) + box2d.b2CrossVV(P.rA, G)), b.SelfMulAdd(l, O), m += d * (box2d.b2CrossVV(A.rB, k) + box2d.b2CrossVV(P.rB, G)), A.normalImpulse = D.x, P.normalImpulse = D.y;
                    break
                }
                break
            }
        this.m_velocities[n].w = p, this.m_velocities[r].w = m
    }
}, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.StoreImpulses = function() {
    var t, e, i, o, s, n;
    for (t = 0, e = this.m_count; t < e; ++t)
        for (s = this.m_velocityConstraints[t], n = this.m_contacts[s.contactIndex].GetManifold(), i = 0, o = s.pointCount; i < o; ++i) n.points[i].normalImpulse = s.points[i].normalImpulse, n.points[i].tangentImpulse = s.points[i].tangentImpulse
}, box2d.b2PositionSolverManifold = function() {
    this.normal = new box2d.b2Vec2, this.point = new box2d.b2Vec2
}, box2d.b2PositionSolverManifold.prototype.normal = null, box2d.b2PositionSolverManifold.prototype.point = null, box2d.b2PositionSolverManifold.prototype.separation = 0, box2d.b2PositionSolverManifold.prototype.Initialize = function(t, e, i, o) {
    var s = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA,
        n = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB,
        r = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint,
        a = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;
    switch (box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < t.pointCount), t.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(e, t.localPoint, s), box2d.b2MulXV(i, t.localPoints[0], n), box2d.b2SubVV(n, s, this.normal).SelfNormalize(), box2d.b2MidVV(s, n, this.point), this.separation = box2d.b2DotVV(box2d.b2SubVV(n, s, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB;
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal), box2d.b2MulXV(e, t.localPoint, r), box2d.b2MulXV(i, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a);
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(i.q, t.localNormal, this.normal), box2d.b2MulXV(i, t.localPoint, r), box2d.b2MulXV(e, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a), this.normal.SelfNeg()
    }
}, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g, _, v, S, C, w, A, P = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA,
        T = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB,
        B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm,
        M = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA,
        E = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB,
        I = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P,
        V = 0;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (n = (s = this.m_positionConstraints[t]).indexA, r = s.indexB, a = s.localCenterA, h = s.invMassA, l = s.invIA, d = s.localCenterB, c = s.invMassB, u = s.invIB, p = s.pointCount, b = this.m_positions[n].c, m = this.m_positions[n].a, y = this.m_positions[r].c, f = this.m_positions[r].a, i = 0, o = p; i < o; ++i) P.q.SetAngleRadians(m), T.q.SetAngleRadians(f), box2d.b2SubVV(b, box2d.b2MulRV(P.q, a, box2d.b2Vec2.s_t0), P.p), box2d.b2SubVV(y, box2d.b2MulRV(T.q, d, box2d.b2Vec2.s_t0), T.p), B.Initialize(s, P, T, i), x = B.normal, g = B.point, _ = B.separation, box2d.b2SubVV(g, b, M), box2d.b2SubVV(g, y, E), V = box2d.b2Min(V, _), v = box2d.b2Clamp(box2d.b2_baumgarte * (_ + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), A = 0 < (w = h + c + l * (S = box2d.b2CrossVV(M, x)) * S + u * (C = box2d.b2CrossVV(E, x)) * C) ? -v / w : 0, box2d.b2MulSV(A, x, I), b.SelfMulSub(h, I), m -= l * box2d.b2CrossVV(M, I), y.SelfMulAdd(c, I), f += u * box2d.b2CrossVV(E, I);
        this.m_positions[n].a = m, this.m_positions[r].a = f
    }
    return V > -3 * box2d.b2_linearSlop
}, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(t, e) {
    var i, o, s, n, r, a, h, l, d, c, u, p, b, m, y, f, x, g, _, v, S, C, w, A, P, T, B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA,
        M = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB,
        E = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm,
        I = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA,
        V = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB,
        R = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
        L = 0;
    for (i = 0, o = this.m_count; i < o; ++i) {
        for (a = (r = this.m_positionConstraints[i]).indexA, h = r.indexB, l = r.localCenterA, d = r.localCenterB, c = r.pointCount, p = u = 0, (a === t || a === e) && (u = r.invMassA, p = r.invIA), m = b = 0, (h === t || h === e) && (b = r.invMassB, m = r.invIB), y = this.m_positions[a].c, f = this.m_positions[a].a, x = this.m_positions[h].c, g = this.m_positions[h].a, s = 0, n = c; s < n; ++s) B.q.SetAngleRadians(f), M.q.SetAngleRadians(g), box2d.b2SubVV(y, box2d.b2MulRV(B.q, l, box2d.b2Vec2.s_t0), B.p), box2d.b2SubVV(x, box2d.b2MulRV(M.q, d, box2d.b2Vec2.s_t0), M.p), E.Initialize(r, B, M, s), _ = E.normal, v = E.point, S = E.separation, box2d.b2SubVV(v, y, I), box2d.b2SubVV(v, x, V), L = box2d.b2Min(L, S), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (S + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), T = 0 < (P = u + b + p * (w = box2d.b2CrossVV(I, _)) * w + m * (A = box2d.b2CrossVV(V, _)) * A) ? -C / P : 0, box2d.b2MulSV(T, _, R), y.SelfMulSub(u, R), f -= p * box2d.b2CrossVV(I, R), x.SelfMulAdd(b, R), g += m * box2d.b2CrossVV(V, R);
        this.m_positions[a].a = f, this.m_positions[h].a = g
    }
    return L >= -1.5 * box2d.b2_linearSlop
}, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2WorldCallbacks"), goog.require("box2d.b2Settings"), box2d.b2DestructionListener = function() {}, box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function() {}, box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function() {}, box2d.b2ContactFilter = function() {}, box2d.b2ContactFilter.prototype.ShouldCollide = function(t, e) {
    var i = t.GetFilterData(),
        o = e.GetFilterData();
    return i.groupIndex === o.groupIndex && 0 !== i.groupIndex ? 0 < i.groupIndex : 0 != (i.maskBits & o.categoryBits) && 0 != (i.categoryBits & o.maskBits)
}, box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter, box2d.b2ContactImpulse = function() {
    this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints), this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
}, box2d.b2ContactImpulse.prototype.normalImpulses = null, box2d.b2ContactImpulse.prototype.tangentImpulses = null, box2d.b2ContactImpulse.prototype.count = 0, box2d.b2ContactListener = function() {}, box2d.b2ContactListener.prototype.BeginContact = function() {}, box2d.b2ContactListener.prototype.EndContact = function() {}, box2d.b2ContactListener.prototype.PreSolve = function() {}, box2d.b2ContactListener.prototype.PostSolve = function() {}, box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener, box2d.b2QueryCallback = function() {}, box2d.b2QueryCallback.prototype.ReportFixture = function() {
    return !0
}, box2d.b2RayCastCallback = function() {}, box2d.b2RayCastCallback.prototype.ReportFixture = function(t, e, i, o) {
    return o
}, goog.provide("box2d.b2Island"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Timer"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2ContactSolver"), box2d.b2Island = function() {
    this.m_bodies = new Array(1024), this.m_contacts = new Array(1024), this.m_joints = new Array(1024), this.m_positions = box2d.b2Position.MakeArray(1024), this.m_velocities = box2d.b2Velocity.MakeArray(1024)
}, box2d.b2Island.prototype.m_allocator = null, box2d.b2Island.prototype.m_listener = null, box2d.b2Island.prototype.m_bodies = null, box2d.b2Island.prototype.m_contacts = null, box2d.b2Island.prototype.m_joints = null, box2d.b2Island.prototype.m_positions = null, box2d.b2Island.prototype.m_velocities = null, box2d.b2Island.prototype.m_bodyCount = 0, box2d.b2Island.prototype.m_jointCount = 0, box2d.b2Island.prototype.m_contactCount = 0, box2d.b2Island.prototype.m_bodyCapacity = 0, box2d.b2Island.prototype.m_contactCapacity = 0, box2d.b2Island.prototype.m_jointCapacity = 0, box2d.b2Island.prototype.Initialize = function(t, e, i, o, s) {
    for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = o, this.m_listener = s; this.m_bodies.length < t;) this.m_bodies[this.m_bodies.length] = null;
    for (; this.m_contacts.length < e;) this.m_contacts[this.m_contacts.length] = null;
    for (; this.m_joints.length < i;) this.m_joints[this.m_joints.length] = null;
    if (this.m_positions.length < t) {
        var n = box2d.b2Max(2 * this.m_positions.length, t);
        for (box2d.DEBUG && window.console.log("box2d.b2Island.m_positions: " + n); this.m_positions.length < n;) this.m_positions[this.m_positions.length] = new box2d.b2Position
    }
    if (this.m_velocities.length < t) {
        n = box2d.b2Max(2 * this.m_velocities.length, t);
        for (box2d.DEBUG && window.console.log("box2d.b2Island.m_velocities: " + n); this.m_velocities.length < n;) this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity
    }
}, box2d.b2Island.prototype.Clear = function() {
    this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0
}, box2d.b2Island.prototype.AddBody = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity), t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t
}, box2d.b2Island.prototype.AddContact = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_contactCount < this.m_contactCapacity), this.m_contacts[this.m_contactCount++] = t
}, box2d.b2Island.prototype.AddJoint = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount < this.m_jointCapacity), this.m_joints[this.m_jointCount++] = t
}, box2d.b2Island.prototype.Solve = function(t, e, i, o) {
    for (var s = box2d.b2Island.s_timer.Reset(), n = e.dt, r = 0; r < this.m_bodyCount; ++r) {
        var a = this.m_bodies[r],
            h = this.m_positions[r].c.Copy(a.m_sweep.c),
            l = a.m_sweep.a,
            d = this.m_velocities[r].v.Copy(a.m_linearVelocity),
            c = a.m_angularVelocity;
        a.m_sweep.c0.Copy(a.m_sweep.c), a.m_sweep.a0 = a.m_sweep.a, a.m_type === box2d.b2BodyType.b2_dynamicBody && (d.x += n * (a.m_gravityScale * i.x + a.m_invMass * a.m_force.x), d.y += n * (a.m_gravityScale * i.y + a.m_invMass * a.m_force.y), c += n * a.m_invI * a.m_torque, d.SelfMul(1 / (1 + n * a.m_linearDamping)), c *= 1 / (1 + n * a.m_angularDamping)), this.m_positions[r].a = l, this.m_velocities[r].w = c
    }
    s.Reset();
    var u = box2d.b2Island.s_solverData;
    u.step.Copy(e), u.positions = this.m_positions, u.velocities = this.m_velocities;
    var p = box2d.b2Island.s_contactSolverDef;
    p.step.Copy(e), p.contacts = this.m_contacts, p.count = this.m_contactCount, p.positions = this.m_positions, p.velocities = this.m_velocities, p.allocator = this.m_allocator;
    var b = box2d.b2Island.s_contactSolver.Initialize(p);
    b.InitializeVelocityConstraints(), e.warmStarting && b.WarmStart();
    for (r = 0; r < this.m_jointCount; ++r) this.m_joints[r].InitVelocityConstraints(u);
    t.solveInit = s.GetMilliseconds(), s.Reset();
    for (r = 0; r < e.velocityIterations; ++r) {
        for (var m = 0; m < this.m_jointCount; ++m) this.m_joints[m].SolveVelocityConstraints(u);
        b.SolveVelocityConstraints()
    }
    b.StoreImpulses(), t.solveVelocity = s.GetMilliseconds();
    for (r = 0; r < this.m_bodyCount; ++r) {
        h = this.m_positions[r].c, l = this.m_positions[r].a, d = this.m_velocities[r].v, c = this.m_velocities[r].w;
        var y = box2d.b2MulSV(n, d, box2d.b2Island.s_translation);
        if (box2d.b2DotVV(y, y) > box2d.b2_maxTranslationSquared) {
            var f = box2d.b2_maxTranslation / y.GetLength();
            d.SelfMul(f)
        }
        var x = n * c;
        if (x * x > box2d.b2_maxRotationSquared) c *= f = box2d.b2_maxRotation / box2d.b2Abs(x);
        h.x += n * d.x, h.y += n * d.y, l += n * c, this.m_positions[r].a = l, this.m_velocities[r].w = c
    }
    s.Reset();
    var g = !1;
    for (r = 0; r < e.positionIterations; ++r) {
        var _ = b.SolvePositionConstraints(),
            v = !0;
        for (m = 0; m < this.m_jointCount; ++m) {
            var S = this.m_joints[m].SolvePositionConstraints(u);
            v = v && S
        }
        if (_ && v) {
            g = !0;
            break
        }
    }
    for (r = 0; r < this.m_bodyCount; ++r) {
        var C = this.m_bodies[r];
        C.m_sweep.c.Copy(this.m_positions[r].c), C.m_sweep.a = this.m_positions[r].a, C.m_linearVelocity.Copy(this.m_velocities[r].v), C.m_angularVelocity = this.m_velocities[r].w, C.SynchronizeTransform()
    }
    if (t.solvePosition = s.GetMilliseconds(), this.Report(b.m_velocityConstraints), o) {
        var w = box2d.b2_maxFloat,
            A = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance,
            P = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;
        for (r = 0; r < this.m_bodyCount; ++r) {
            (a = this.m_bodies[r]).GetType() !== box2d.b2BodyType.b2_staticBody && (w = 0 == (a.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || a.m_angularVelocity * a.m_angularVelocity > P || box2d.b2DotVV(a.m_linearVelocity, a.m_linearVelocity) > A ? a.m_sleepTime = 0 : (a.m_sleepTime += n, box2d.b2Min(w, a.m_sleepTime)))
        }
        if (w >= box2d.b2_timeToSleep && g)
            for (r = 0; r < this.m_bodyCount; ++r) {
                (a = this.m_bodies[r]).SetAwake(!1)
            }
    }
}, box2d.b2Island.prototype.SolveTOI = function(t, e, i) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e < this.m_bodyCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(i < this.m_bodyCount);
    for (var o = 0; o < this.m_bodyCount; ++o) {
        var s = this.m_bodies[o];
        this.m_positions[o].c.Copy(s.m_sweep.c), this.m_positions[o].a = s.m_sweep.a, this.m_velocities[o].v.Copy(s.m_linearVelocity), this.m_velocities[o].w = s.m_angularVelocity
    }
    var n = box2d.b2Island.s_contactSolverDef;
    n.contacts = this.m_contacts, n.count = this.m_contactCount, n.allocator = this.m_allocator, n.step.Copy(t), n.positions = this.m_positions, n.velocities = this.m_velocities;
    var r = box2d.b2Island.s_contactSolver.Initialize(n);
    for (o = 0; o < t.positionIterations; ++o) {
        if (r.SolveTOIPositionConstraints(e, i)) break
    }
    this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c), this.m_bodies[e].m_sweep.a0 = this.m_positions[e].a, this.m_bodies[i].m_sweep.c0.Copy(this.m_positions[i].c), this.m_bodies[i].m_sweep.a0 = this.m_positions[i].a, r.InitializeVelocityConstraints();
    for (o = 0; o < t.velocityIterations; ++o) r.SolveVelocityConstraints();
    var a = t.dt;
    for (o = 0; o < this.m_bodyCount; ++o) {
        var h = this.m_positions[o].c,
            l = this.m_positions[o].a,
            d = this.m_velocities[o].v,
            c = this.m_velocities[o].w,
            u = box2d.b2MulSV(a, d, box2d.b2Island.s_translation);
        if (box2d.b2DotVV(u, u) > box2d.b2_maxTranslationSquared) {
            var p = box2d.b2_maxTranslation / u.GetLength();
            d.SelfMul(p)
        }
        var b = a * c;
        if (b * b > box2d.b2_maxRotationSquared) c *= p = box2d.b2_maxRotation / box2d.b2Abs(b);
        h.SelfMulAdd(a, d), l += a * c, this.m_positions[o].a = l, this.m_velocities[o].w = c;
        var m = this.m_bodies[o];
        m.m_sweep.c.Copy(h), m.m_sweep.a = l, m.m_linearVelocity.Copy(d), m.m_angularVelocity = c, m.SynchronizeTransform()
    }
    this.Report(r.m_velocityConstraints)
}, box2d.b2Island.prototype.Report = function(t) {
    if (null !== this.m_listener)
        for (var e = 0; e < this.m_contactCount; ++e) {
            var i = this.m_contacts[e];
            if (i) {
                var o = t[e],
                    s = box2d.b2Island.s_impulse;
                s.count = o.pointCount;
                for (var n = 0; n < o.pointCount; ++n) s.normalImpulses[n] = o.points[n].normalImpulse, s.tangentImpulses[n] = o.points[n].tangentImpulse;
                this.m_listener.PostSolve(i, s)
            }
        }
}, box2d.b2Island.s_timer = new box2d.b2Timer, box2d.b2Island.s_solverData = new box2d.b2SolverData, box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef, box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver, box2d.b2Island.s_translation = new box2d.b2Vec2, box2d.b2Island.s_impulse = new box2d.b2ContactImpulse, goog.provide("box2d.b2ContactFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2ContactRegister = function() {}, box2d.b2ContactRegister.prototype.createFcn = null, box2d.b2ContactRegister.prototype.destroyFcn = null, box2d.b2ContactRegister.prototype.primary = !1, box2d.b2ContactFactory = function(t) {
    this.m_allocator = t, this.InitializeRegisters()
}, box2d.b2ContactFactory.prototype.m_allocator = null, box2d.b2ContactFactory.prototype.AddType = function(e, t, i, o) {
    var s = box2d.b2MakeArray(256, function() {
            return e()
        }),
        n = function(t) {
            return 0 < s.length ? s.pop() : e(t)
        },
        r = function(t) {
            s.push(t)
        };
    this.m_registers[i][o].pool = s, this.m_registers[i][o].createFcn = n, this.m_registers[i][o].destroyFcn = r, this.m_registers[i][o].primary = !0, i !== o && (this.m_registers[o][i].pool = s, this.m_registers[o][i].createFcn = n, this.m_registers[o][i].destroyFcn = r, this.m_registers[o][i].primary = !1)
}, box2d.b2ContactFactory.prototype.InitializeRegisters = function() {
    this.m_registers = new Array(box2d.b2ShapeType.e_shapeTypeCount);
    for (var t = 0; t < box2d.b2ShapeType.e_shapeTypeCount; t++) {
        this.m_registers[t] = new Array(box2d.b2ShapeType.e_shapeTypeCount);
        for (var e = 0; e < box2d.b2ShapeType.e_shapeTypeCount; e++) this.m_registers[t][e] = new box2d.b2ContactRegister
    }
    this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonAndCircleContact.Create, box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape)
}, box2d.b2ContactFactory.prototype.Create = function(t, e, i, o) {
    var s = t.GetType(),
        n = i.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= s && s < box2d.b2ShapeType.e_shapeTypeCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= n && n < box2d.b2ShapeType.e_shapeTypeCount);
    var r, a = this.m_registers[s][n],
        h = a.createFcn;
    return null === h ? null : (a.primary ? (r = h(this.m_allocator)).Reset(t, e, i, o) : (r = h(this.m_allocator)).Reset(i, o, t, e), r)
}, box2d.b2ContactFactory.prototype.Destroy = function(t) {
    var e = t.m_fixtureA,
        i = t.m_fixtureB;
    0 < t.m_manifold.pointCount && !1 === e.IsSensor() && !1 === i.IsSensor() && (e.GetBody().SetAwake(!0), i.GetBody().SetAwake(!0));
    var o = e.GetType(),
        s = i.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= o && s < box2d.b2ShapeType.e_shapeTypeCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= o && s < box2d.b2ShapeType.e_shapeTypeCount), (0, this.m_registers[o][s].destroyFcn)(t, this.m_allocator)
}, goog.provide("box2d.b2GrowableStack"), goog.require("box2d.b2Settings"), box2d.b2GrowableStack = function(t) {
    this.m_stack = new Array(t)
}, box2d.b2GrowableStack.prototype.m_stack = null, box2d.b2GrowableStack.prototype.m_count = 0, box2d.b2GrowableStack.prototype.Reset = function() {
    return this.m_count = 0, this
}, box2d.b2GrowableStack.prototype.Push = function(t) {
    this.m_stack[this.m_count] = t, ++this.m_count
}, box2d.b2GrowableStack.prototype.Pop = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_count), --this.m_count;
    var t = this.m_stack[this.m_count];
    return this.m_stack[this.m_count] = null, t
}, box2d.b2GrowableStack.prototype.GetCount = function() {
    return this.m_count
}, goog.provide("box2d.b2DynamicTree"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2GrowableStack"), box2d.b2TreeNode = function(t) {
    this.m_id = t || 0, this.aabb = new box2d.b2AABB
}, box2d.b2TreeNode.prototype.m_id = 0, box2d.b2TreeNode.prototype.aabb = null, box2d.b2TreeNode.prototype.userData = null, box2d.b2TreeNode.prototype.parent = null, box2d.b2TreeNode.prototype.child1 = null, box2d.b2TreeNode.prototype.child2 = null, box2d.b2TreeNode.prototype.height = 0, box2d.b2TreeNode.prototype.IsLeaf = function() {
    return null === this.child1
}, box2d.b2DynamicTree = function() {}, box2d.b2DynamicTree.prototype.m_root = null, box2d.b2DynamicTree.prototype.m_freeList = null, box2d.b2DynamicTree.prototype.m_path = 0, box2d.b2DynamicTree.prototype.m_insertionCount = 0, box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256), box2d.b2DynamicTree.s_r = new box2d.b2Vec2, box2d.b2DynamicTree.s_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput, box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_aabb = new box2d.b2AABB, box2d.b2DynamicTree.prototype.GetUserData = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.userData
}, box2d.b2DynamicTree.prototype.GetFatAABB = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.aabb
}, box2d.b2DynamicTree.prototype.Query = function(t, e) {
    if (null !== this.m_root) {
        var i = box2d.b2DynamicTree.s_stack.Reset();
        for (i.Push(this.m_root); 0 < i.GetCount();) {
            var o = i.Pop();
            if (null !== o && o.aabb.TestOverlap(e))
                if (o.IsLeaf()) {
                    if (!1 === t(o)) return
                } else i.Push(o.child1), i.Push(o.child2)
        }
    }
}, box2d.b2DynamicTree.prototype.RayCast = function(t, e) {
    if (null !== this.m_root) {
        var i = e.p1,
            o = e.p2,
            s = box2d.b2SubVV(o, i, box2d.b2DynamicTree.s_r);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < s.GetLengthSquared()), s.Normalize();
        var n = box2d.b2CrossOneV(s, box2d.b2DynamicTree.s_v),
            r = box2d.b2AbsV(n, box2d.b2DynamicTree.s_abs_v),
            a = e.maxFraction,
            h = box2d.b2DynamicTree.s_segmentAABB,
            l = i.x + a * (o.x - i.x),
            d = i.y + a * (o.y - i.y);
        h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, d), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, d);
        var c = box2d.b2DynamicTree.s_stack.Reset();
        for (c.Push(this.m_root); 0 < c.GetCount();) {
            var u = c.Pop();
            if (null !== u && !1 !== box2d.b2TestOverlapAABB(u.aabb, h)) {
                var p = u.aabb.GetCenter(),
                    b = u.aabb.GetExtents();
                if (!(0 < box2d.b2Abs(box2d.b2DotVV(n, box2d.b2SubVV(i, p, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(r, b)))
                    if (u.IsLeaf()) {
                        var m = box2d.b2DynamicTree.s_subInput;
                        m.p1.Copy(e.p1), m.p2.Copy(e.p2), m.maxFraction = a;
                        var y = t(m, u);
                        if (0 === y) return;
                        0 < y && (a = y, l = i.x + a * (o.x - i.x), d = i.y + a * (o.y - i.y), h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, d), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, d))
                    } else c.Push(u.child1), c.Push(u.child2)
            }
        }
    }
}, box2d.b2DynamicTree.prototype.AllocateNode = function() {
    if (this.m_freeList) {
        var t = this.m_freeList;
        return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t.height = 0, t.userData = null, t
    }
    return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++)
}, box2d.b2DynamicTree.prototype.s_node_id = 0, box2d.b2DynamicTree.prototype.FreeNode = function(t) {
    t.parent = this.m_freeList, t.height = -1, this.m_freeList = t
}, box2d.b2DynamicTree.prototype.CreateProxy = function(t, e) {
    var i = this.AllocateNode(),
        o = box2d.b2_aabbExtension,
        s = box2d.b2_aabbExtension;
    return i.aabb.lowerBound.x = t.lowerBound.x - o, i.aabb.lowerBound.y = t.lowerBound.y - s, i.aabb.upperBound.x = t.upperBound.x + o, i.aabb.upperBound.y = t.upperBound.y + s, i.userData = e, i.height = 0, this.InsertLeaf(i), i
}, box2d.b2DynamicTree.prototype.DestroyProxy = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(t.IsLeaf()), this.RemoveLeaf(t), this.FreeNode(t)
}, box2d.b2DynamicTree.prototype.MoveProxy = function(t, e, i) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(t.IsLeaf()), t.aabb.Contains(e)) return !1;
    this.RemoveLeaf(t);
    var o = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < i.x ? i.x : -i.x),
        s = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < i.y ? i.y : -i.y);
    return t.aabb.lowerBound.x = e.lowerBound.x - o, t.aabb.lowerBound.y = e.lowerBound.y - s, t.aabb.upperBound.x = e.upperBound.x + o, t.aabb.upperBound.y = e.upperBound.y + s, this.InsertLeaf(t), !0
}, box2d.b2DynamicTree.prototype.InsertLeaf = function(t) {
    if (++this.m_insertionCount, null === this.m_root) return this.m_root = t, void(this.m_root.parent = null);
    for (var e, i, o = t.aabb, s = (o.GetCenter(), this.m_root); !1 === s.IsLeaf();) {
        e = s.child1, i = s.child2;
        var n = s.aabb.GetPerimeter(),
            r = box2d.b2DynamicTree.s_combinedAABB;
        r.Combine2(s.aabb, o);
        var a, h, l, d = r.GetPerimeter(),
            c = 2 * d,
            u = 2 * (d - n),
            p = box2d.b2DynamicTree.s_aabb;
        if (a = e.IsLeaf() ? (p.Combine2(o, e.aabb), p.GetPerimeter() + u) : (p.Combine2(o, e.aabb), h = e.aabb.GetPerimeter(), p.GetPerimeter() - h + u), l = i.IsLeaf() ? (p.Combine2(o, i.aabb), p.GetPerimeter() + u) : (p.Combine2(o, i.aabb), h = i.aabb.GetPerimeter(), p.GetPerimeter() - h + u), c < a && c < l) break;
        s = a < l ? e : i
    }
    var b = s,
        m = b.parent,
        y = this.AllocateNode();
    for (y.parent = m, y.userData = null, y.aabb.Combine2(o, b.aabb), y.height = b.height + 1, m ? (m.child1 === b ? m.child1 = y : m.child2 = y, y.child1 = b, y.child2 = t, b.parent = y, t.parent = y) : (y.child1 = b, y.child2 = t, b.parent = y, t.parent = y, this.m_root = y), s = t.parent; null !== s;) e = (s = this.Balance(s)).child1, i = s.child2, box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== e), box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== i), s.height = 1 + box2d.b2Max(e.height, i.height), s.aabb.Combine2(e.aabb, i.aabb), s = s.parent
}, box2d.b2DynamicTree.prototype.RemoveLeaf = function(t) {
    if (t !== this.m_root) {
        var e, i = t.parent,
            o = i.parent;
        if (e = i.child1 === t ? i.child2 : i.child1, o) {
            o.child1 === i ? o.child1 = e : o.child2 = e, e.parent = o, this.FreeNode(i);
            for (var s = o; s;) {
                var n = (s = this.Balance(s)).child1,
                    r = s.child2;
                s.aabb.Combine2(n.aabb, r.aabb), s.height = 1 + box2d.b2Max(n.height, r.height), s = s.parent
            }
        } else(this.m_root = e).parent = null, this.FreeNode(i)
    } else this.m_root = null
}, box2d.b2DynamicTree.prototype.Balance = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.IsLeaf() || t.height < 2) return t;
    var e = t.child1,
        i = t.child2,
        o = i.height - e.height;
    if (1 < o) {
        var s = i.child1,
            n = i.child2;
        return i.child1 = t, i.parent = t.parent, null !== (t.parent = i).parent ? i.parent.child1 === t ? i.parent.child1 = i : (box2d.ENABLE_ASSERTS && box2d.b2Assert(i.parent.child2 === t), i.parent.child2 = i) : this.m_root = i, s.height > n.height ? (i.child2 = s, ((t.child2 = n).parent = t).aabb.Combine2(e.aabb, n.aabb), i.aabb.Combine2(t.aabb, s.aabb), t.height = 1 + box2d.b2Max(e.height, n.height), i.height = 1 + box2d.b2Max(t.height, s.height)) : (i.child2 = n, ((t.child2 = s).parent = t).aabb.Combine2(e.aabb, s.aabb), i.aabb.Combine2(t.aabb, n.aabb), t.height = 1 + box2d.b2Max(e.height, s.height), i.height = 1 + box2d.b2Max(t.height, n.height)), i
    }
    if (o < -1) {
        var r = e.child1,
            a = e.child2;
        return e.child1 = t, e.parent = t.parent, null !== (t.parent = e).parent ? e.parent.child1 === t ? e.parent.child1 = e : (box2d.ENABLE_ASSERTS && box2d.b2Assert(e.parent.child2 === t), e.parent.child2 = e) : this.m_root = e, r.height > a.height ? (e.child2 = r, ((t.child1 = a).parent = t).aabb.Combine2(i.aabb, a.aabb), e.aabb.Combine2(t.aabb, r.aabb), t.height = 1 + box2d.b2Max(i.height, a.height), e.height = 1 + box2d.b2Max(t.height, r.height)) : (e.child2 = a, ((t.child1 = r).parent = t).aabb.Combine2(i.aabb, r.aabb), e.aabb.Combine2(t.aabb, a.aabb), t.height = 1 + box2d.b2Max(i.height, r.height), e.height = 1 + box2d.b2Max(t.height, a.height)), e
    }
    return t
}, box2d.b2DynamicTree.prototype.GetHeight = function() {
    return null === this.m_root ? 0 : this.m_root.height
}, box2d.b2DynamicTree.prototype.GetAreaRatio = function() {
    if (null === this.m_root) return 0;
    var t = this.m_root.aabb.GetPerimeter(),
        i = function(t) {
            if (null === t) return 0;
            if (t.IsLeaf()) return 0;
            var e = t.aabb.GetPerimeter();
            return (e += i(t.child1)) + i(t.child2)
        };
    return i(this.m_root) / t
}, box2d.b2DynamicTree.prototype.ComputeHeightNode = function(t) {
    if (t.IsLeaf()) return 0;
    var e = this.ComputeHeightNode(t.child1),
        i = this.ComputeHeightNode(t.child2);
    return 1 + box2d.b2Max(e, i)
}, box2d.b2DynamicTree.prototype.ComputeHeight = function() {
    return this.ComputeHeightNode(this.m_root)
}, box2d.b2DynamicTree.prototype.ValidateStructure = function(t) {
    if (null !== t) {
        t === this.m_root && box2d.ENABLE_ASSERTS && box2d.b2Assert(null === t.parent);
        var e = t,
            i = e.child1,
            o = e.child2;
        if (e.IsLeaf()) return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === i), box2d.ENABLE_ASSERTS && box2d.b2Assert(null === o), void(box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === e.height));
        box2d.ENABLE_ASSERTS && box2d.b2Assert(i.parent === t), box2d.ENABLE_ASSERTS && box2d.b2Assert(o.parent === t), this.ValidateStructure(i), this.ValidateStructure(o)
    }
}, box2d.b2DynamicTree.prototype.ValidateMetrics = function(t) {
    if (null !== t) {
        var e = t,
            i = e.child1,
            o = e.child2;
        if (e.IsLeaf()) return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === i), box2d.ENABLE_ASSERTS && box2d.b2Assert(null === o), void(box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === e.height));
        var s, n = i.height,
            r = o.height;
        s = 1 + box2d.b2Max(n, r), box2d.ENABLE_ASSERTS && box2d.b2Assert(e.height === s);
        var a = box2d.b2DynamicTree.s_aabb;
        a.Combine2(i.aabb, o.aabb), box2d.ENABLE_ASSERTS && box2d.b2Assert(a.lowerBound === e.aabb.lowerBound), box2d.ENABLE_ASSERTS && box2d.b2Assert(a.upperBound === e.aabb.upperBound), this.ValidateMetrics(i), this.ValidateMetrics(o)
    }
}, box2d.b2DynamicTree.prototype.Validate = function() {
    this.ValidateStructure(this.m_root), this.ValidateMetrics(this.m_root);
    for (var t = this.m_freeList; null !== t;) t = t.parent, 0;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.GetHeight() === this.ComputeHeight())
}, box2d.b2DynamicTree.prototype.GetMaxBalance = function() {
    return function(t, e) {
        if (null === t) return e;
        if (t.height <= 1) return e;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === t.IsLeaf());
        var i = t.child1,
            o = t.child2,
            s = box2d.b2Abs(o.height - i.height);
        return box2d.b2Max(e, s)
    }(this.m_root, 0)
}, box2d.b2DynamicTree.prototype.RebuildBottomUp = function() {
    this.Validate()
}, box2d.b2DynamicTree.prototype.ShiftOrigin = function(t) {
    var s = function(t, e) {
        if (null !== t && !(t.height <= 1)) {
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === t.IsLeaf());
            var i = t.child1,
                o = t.child2;
            s(i, e), s(o, e), t.aabb.lowerBound.SelfSub(e), t.aabb.upperBound.SelfSub(e)
        }
    };
    s(this.m_root, t)
}, goog.provide("box2d.b2BroadPhase"), goog.require("box2d.b2Settings"), goog.require("box2d.b2DynamicTree"), box2d.b2Pair = function() {}, box2d.b2Pair.prototype.proxyA = null, box2d.b2Pair.prototype.proxyB = null, box2d.b2BroadPhase = function() {
    this.m_tree = new box2d.b2DynamicTree, this.m_moveBuffer = new Array, this.m_pairBuffer = new Array
}, box2d.b2BroadPhase.prototype.m_tree = null, box2d.b2BroadPhase.prototype.m_proxyCount = 0, box2d.b2BroadPhase.prototype.m_moveCount = 0, box2d.b2BroadPhase.prototype.m_moveBuffer = null, box2d.b2BroadPhase.prototype.m_pairCount = 0, box2d.b2BroadPhase.prototype.m_pairBuffer = null, box2d.b2BroadPhase.prototype.CreateProxy = function(t, e) {
    var i = this.m_tree.CreateProxy(t, e);
    return ++this.m_proxyCount, this.BufferMove(i), i
}, box2d.b2BroadPhase.prototype.DestroyProxy = function(t) {
    this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t)
}, box2d.b2BroadPhase.prototype.MoveProxy = function(t, e, i) {
    this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t)
}, box2d.b2BroadPhase.prototype.TouchProxy = function(t) {
    this.BufferMove(t)
}, box2d.b2BroadPhase.prototype.GetFatAABB = function(t) {
    return this.m_tree.GetFatAABB(t)
}, box2d.b2BroadPhase.prototype.GetUserData = function(t) {
    return this.m_tree.GetUserData(t)
}, box2d.b2BroadPhase.prototype.TestOverlap = function(t, e) {
    var i = this.m_tree.GetFatAABB(t),
        o = this.m_tree.GetFatAABB(e);
    return box2d.b2TestOverlapAABB(i, o)
}, box2d.b2BroadPhase.prototype.GetProxyCount = function() {
    return this.m_proxyCount
}, box2d.b2BroadPhase.prototype.GetTreeHeight = function() {
    return this.m_tree.GetHeight()
}, box2d.b2BroadPhase.prototype.GetTreeBalance = function() {
    return this.m_tree.GetMaxBalance()
}, box2d.b2BroadPhase.prototype.GetTreeQuality = function() {
    return this.m_tree.GetAreaRatio()
}, box2d.b2BroadPhase.prototype.ShiftOrigin = function(t) {
    this.m_tree.ShiftOrigin(t)
}, box2d.b2BroadPhase.prototype.UpdatePairs = function(t) {
    for (var e = this.m_pairCount = 0; e < this.m_moveCount; ++e) {
        var i = this.m_moveBuffer[e];
        if (null !== i) {
            var o = this,
                s = this.m_tree.GetFatAABB(i);
            this.m_tree.Query(function(t) {
                if (t.m_id === i.m_id) return !0;
                o.m_pairCount === o.m_pairBuffer.length && (o.m_pairBuffer[o.m_pairCount] = new box2d.b2Pair);
                var e = o.m_pairBuffer[o.m_pairCount];
                return t.m_id < i.m_id ? (e.proxyA = t, e.proxyB = i) : (e.proxyA = i, e.proxyB = t), ++o.m_pairCount, !0
            }, s)
        }
    }
    this.m_moveCount = 0, this.m_pairBuffer.length = this.m_pairCount, this.m_pairBuffer.sort(box2d.b2PairLessThan);
    for (e = 0; e < this.m_pairCount;) {
        var n = this.m_pairBuffer[e],
            r = this.m_tree.GetUserData(n.proxyA),
            a = this.m_tree.GetUserData(n.proxyB);
        for (t.AddPair(r, a), ++e; e < this.m_pairCount;) {
            var h = this.m_pairBuffer[e];
            if (h.proxyA.m_id !== n.proxyA.m_id || h.proxyB.m_id !== n.proxyB.m_id) break;
            ++e
        }
    }
}, box2d.b2BroadPhase.prototype.Query = function(t, e) {
    this.m_tree.Query(t, e)
}, box2d.b2BroadPhase.prototype.RayCast = function(t, e) {
    this.m_tree.RayCast(t, e)
}, box2d.b2BroadPhase.prototype.BufferMove = function(t) {
    this.m_moveBuffer[this.m_moveCount] = t, ++this.m_moveCount
}, box2d.b2BroadPhase.prototype.UnBufferMove = function(t) {
    var e = this.m_moveBuffer.indexOf(t);
    this.m_moveBuffer[e] = null
}, box2d.b2PairLessThan = function(t, e) {
    return t.proxyA.m_id === e.proxyA.m_id ? t.proxyB.m_id - e.proxyB.m_id : t.proxyA.m_id - e.proxyA.m_id
}, goog.provide("box2d.b2ContactManager"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2ContactFactory"), box2d.b2ContactManager = function() {
    this.m_broadPhase = new box2d.b2BroadPhase, this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator)
}, box2d.b2ContactManager.prototype.m_broadPhase = null, box2d.b2ContactManager.prototype.m_contactList = null, box2d.b2ContactManager.prototype.m_contactCount = 0, box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter, box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener, box2d.b2ContactManager.prototype.m_allocator = null, box2d.b2ContactManager.prototype.m_contactFactory = null, box2d.b2ContactManager.prototype.Destroy = function(t) {
    var e = t.GetFixtureA(),
        i = t.GetFixtureB(),
        o = e.GetBody(),
        s = i.GetBody();
    this.m_contactListener && t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_contactList && (this.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA === o.m_contactList && (o.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB === s.m_contactList && (s.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount
}, box2d.b2ContactManager.prototype.Collide = function() {
    for (var t = this.m_contactList; t;) {
        var e = t.GetFixtureA(),
            i = t.GetFixtureB(),
            o = t.GetChildIndexA(),
            s = t.GetChildIndexB(),
            n = e.GetBody(),
            r = i.GetBody();
        if (t.m_flags & box2d.b2ContactFlag.e_filterFlag) {
            if (!1 === r.ShouldCollide(n)) {
                var a = t;
                t = a.m_next, this.Destroy(a);
                continue
            }
            if (this.m_contactFilter && !1 === this.m_contactFilter.ShouldCollide(e, i)) {
                t = (a = t).m_next, this.Destroy(a);
                continue
            }
            t.m_flags &= ~box2d.b2ContactFlag.e_filterFlag
        }
        var h = n.IsAwake() && n.m_type !== box2d.b2BodyType.b2_staticBody,
            l = r.IsAwake() && r.m_type !== box2d.b2BodyType.b2_staticBody;
        if (!1 !== h || !1 !== l) {
            var d = e.m_proxies[o].proxy,
                c = i.m_proxies[s].proxy;
            !1 !== this.m_broadPhase.TestOverlap(d, c) ? (t.Update(this.m_contactListener), t = t.m_next) : (t = (a = t).m_next, this.Destroy(a))
        } else t = t.m_next
    }
}, box2d.b2ContactManager.prototype.FindNewContacts = function() {
    this.m_broadPhase.UpdatePairs(this)
}, box2d.b2ContactManager.prototype.AddPair = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2FixtureProxy), box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2FixtureProxy);
    var i = t,
        o = e,
        s = i.fixture,
        n = o.fixture,
        r = i.childIndex,
        a = o.childIndex,
        h = s.GetBody(),
        l = n.GetBody();
    if (h !== l) {
        for (var d = l.GetContactList(); d;) {
            if (d.other === h) {
                var c = d.contact.GetFixtureA(),
                    u = d.contact.GetFixtureB(),
                    p = d.contact.GetChildIndexA(),
                    b = d.contact.GetChildIndexB();
                if (c === s && u === n && p === r && b === a) return;
                if (c === n && u === s && p === a && b === r) return
            }
            d = d.next
        }
        if (!1 !== l.ShouldCollide(h) && (!this.m_contactFilter || !1 !== this.m_contactFilter.ShouldCollide(s, n))) {
            var m = this.m_contactFactory.Create(s, r, n, a);
            null !== m && (s = m.GetFixtureA(), n = m.GetFixtureB(), r = m.GetChildIndexA(), a = m.GetChildIndexB(), h = s.m_body, l = n.m_body, m.m_prev = null, m.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = m), ((this.m_contactList = m).m_nodeA.contact = m).m_nodeA.other = l, m.m_nodeA.prev = null, m.m_nodeA.next = h.m_contactList, null !== h.m_contactList && (h.m_contactList.prev = m.m_nodeA), h.m_contactList = m.m_nodeA, (m.m_nodeB.contact = m).m_nodeB.other = h, m.m_nodeB.prev = null, m.m_nodeB.next = l.m_contactList, null !== l.m_contactList && (l.m_contactList.prev = m.m_nodeB), l.m_contactList = m.m_nodeB, !1 === s.IsSensor() && !1 === n.IsSensor() && (h.SetAwake(!0), l.SetAwake(!0)), ++this.m_contactCount)
        }
    }
}, goog.provide("box2d.b2JointFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Joint"), box2d.b2JointFactory.Create = function(t) {
    var e = null;
    switch (t.type) {
        case box2d.b2JointType.e_distanceJoint:
            e = new box2d.b2DistanceJoint(t instanceof box2d.b2DistanceJointDef ? t : null);
            break;
        case box2d.b2JointType.e_mouseJoint:
            e = new box2d.b2MouseJoint(t instanceof box2d.b2MouseJointDef ? t : null);
            break;
        case box2d.b2JointType.e_prismaticJoint:
            e = new box2d.b2PrismaticJoint(t instanceof box2d.b2PrismaticJointDef ? t : null);
            break;
        case box2d.b2JointType.e_revoluteJoint:
            e = new box2d.b2RevoluteJoint(t instanceof box2d.b2RevoluteJointDef ? t : null);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            e = new box2d.b2PulleyJoint(t instanceof box2d.b2PulleyJointDef ? t : null);
            break;
        case box2d.b2JointType.e_gearJoint:
            e = new box2d.b2GearJoint(t instanceof box2d.b2GearJointDef ? t : null);
            break;
        case box2d.b2JointType.e_wheelJoint:
            e = new box2d.b2WheelJoint(t instanceof box2d.b2WheelJointDef ? t : null);
            break;
        case box2d.b2JointType.e_weldJoint:
            e = new box2d.b2WeldJoint(t instanceof box2d.b2WeldJointDef ? t : null);
            break;
        case box2d.b2JointType.e_frictionJoint:
            e = new box2d.b2FrictionJoint(t instanceof box2d.b2FrictionJointDef ? t : null);
            break;
        case box2d.b2JointType.e_ropeJoint:
            e = new box2d.b2RopeJoint(t instanceof box2d.b2RopeJointDef ? t : null);
            break;
        case box2d.b2JointType.e_motorJoint:
            e = new box2d.b2MotorJoint(t instanceof box2d.b2MotorJointDef ? t : null);
            break;
        case box2d.b2JointType.e_areaJoint:
            e = new box2d.b2AreaJoint(t instanceof box2d.b2AreaJointDef ? t : null);
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
    }
    return e
}, box2d.b2JointFactory.Destroy = function() {}, goog.provide("box2d.b2Draw"), goog.require("box2d.b2Settings"), box2d.b2Color = function(t, e, i) {
    this.r = t, this.g = e, this.b = i
}, box2d.b2Color.prototype.r = .5, box2d.b2Color.prototype.g = .5, box2d.b2Color.prototype.b = .5, box2d.b2Color.prototype.SetRGB = function(t, e, i) {
    return this.r = t, this.g = e, this.b = i, this
}, box2d.b2Color.prototype.MakeStyleString = function(t) {
    var e = Math.round(Math.max(0, Math.min(255, 255 * this.r))),
        i = Math.round(Math.max(0, Math.min(255, 255 * this.g))),
        o = Math.round(Math.max(0, Math.min(255, 255 * this.b))),
        s = void 0 === t ? 1 : Math.max(0, Math.min(1, t));
    return box2d.b2Color.MakeStyleString(e, i, o, s)
}, box2d.b2Color.MakeStyleString = function(t, e, i, o) {
    return o < 1 ? "rgba(" + t + "," + e + "," + i + "," + o + ")" : "rgb(" + t + "," + e + "," + i + ")"
}, box2d.b2Color.RED = new box2d.b2Color(1, 0, 0), box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0), box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1), box2d.b2DrawFlags = {
    e_none: 0,
    e_shapeBit: 1,
    e_jointBit: 2,
    e_aabbBit: 4,
    e_pairBit: 8,
    e_centerOfMassBit: 16,
    e_controllerBit: 32,
    e_all: 63
}, goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none), goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit), goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit), goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit), goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit), goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit), goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit), goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all), box2d.b2Draw = function() {}, box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none, box2d.b2Draw.prototype.SetFlags = function(t) {
    this.m_drawFlags = t
}, box2d.b2Draw.prototype.GetFlags = function() {
    return this.m_drawFlags
}, box2d.b2Draw.prototype.AppendFlags = function(t) {
    this.m_drawFlags |= t
}, box2d.b2Draw.prototype.ClearFlags = function(t) {
    this.m_drawFlags &= ~t
}, box2d.b2Draw.prototype.PushTransform = function() {}, box2d.b2Draw.prototype.PopTransform = function() {}, box2d.b2Draw.prototype.DrawPolygon = function() {}, box2d.b2Draw.prototype.DrawSolidPolygon = function() {}, box2d.b2Draw.prototype.DrawCircle = function() {}, box2d.b2Draw.prototype.DrawSolidCircle = function() {}, box2d.b2Draw.prototype.DrawSegment = function() {}, box2d.b2Draw.prototype.DrawTransform = function() {}, goog.provide("box2d.b2Fixture"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2Shape"), box2d.b2Filter = function() {}, box2d.b2Filter.prototype.categoryBits = 1, box2d.b2Filter.prototype.maskBits = 65535, box2d.b2Filter.prototype.groupIndex = 0, box2d.b2Filter.prototype.Clone = function() {
    return (new box2d.b2Filter).Copy(this)
}, box2d.b2Filter.prototype.Copy = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(this !== t), this.categoryBits = t.categoryBits, this.maskBits = t.maskBits, this.groupIndex = t.groupIndex, this
}, box2d.b2FixtureDef = function() {
    this.filter = new box2d.b2Filter
}, box2d.b2FixtureDef.prototype.shape = null, box2d.b2FixtureDef.prototype.userData = null, box2d.b2FixtureDef.prototype.friction = .2, box2d.b2FixtureDef.prototype.restitution = 0, box2d.b2FixtureDef.prototype.density = 0, box2d.b2FixtureDef.prototype.isSensor = !1, box2d.b2FixtureDef.prototype.filter = null, box2d.b2FixtureProxy = function() {
    this.aabb = new box2d.b2AABB
}, box2d.b2FixtureProxy.prototype.aabb = null, box2d.b2FixtureProxy.prototype.fixture = null, box2d.b2FixtureProxy.prototype.childIndex = 0, box2d.b2FixtureProxy.prototype.proxy = null, box2d.b2FixtureProxy.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function() {
        return new box2d.b2FixtureProxy
    })
}, box2d.b2Fixture = function() {
    this.m_proxyCount = 0, this.m_filter = new box2d.b2Filter
}, box2d.b2Fixture.prototype.m_density = 0, box2d.b2Fixture.prototype.m_next = null, box2d.b2Fixture.prototype.m_body = null, box2d.b2Fixture.prototype.m_shape = null, box2d.b2Fixture.prototype.m_friction = 0, box2d.b2Fixture.prototype.m_restitution = 0, box2d.b2Fixture.prototype.m_proxies = null, box2d.b2Fixture.prototype.m_proxyCount = 0, box2d.b2Fixture.prototype.m_filter = null, box2d.b2Fixture.prototype.m_isSensor = !1, box2d.b2Fixture.prototype.m_userData = null, box2d.b2Fixture.prototype.GetType = function() {
    return this.m_shape.GetType()
}, box2d.b2Fixture.prototype.GetShape = function() {
    return this.m_shape
}, box2d.b2Fixture.prototype.IsSensor = function() {
    return this.m_isSensor
}, box2d.b2Fixture.prototype.GetFilterData = function() {
    return this.m_filter
}, box2d.b2Fixture.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Fixture.prototype.SetUserData = function(t) {
    this.m_userData = t
}, box2d.b2Fixture.prototype.GetBody = function() {
    return this.m_body
}, box2d.b2Fixture.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Fixture.prototype.SetDensity = function(t) {
    this.m_density = t
}, box2d.b2Fixture.prototype.GetDensity = function() {
    return this.m_density
}, box2d.b2Fixture.prototype.GetFriction = function() {
    return this.m_friction
}, box2d.b2Fixture.prototype.SetFriction = function(t) {
    this.m_friction = t
}, box2d.b2Fixture.prototype.GetRestitution = function() {
    return this.m_restitution
}, box2d.b2Fixture.prototype.SetRestitution = function(t) {
    this.m_restitution = t
}, box2d.b2Fixture.prototype.TestPoint = function(t) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), t)
}, box2d.b2Fixture.prototype.RayCast = function(t, e, i) {
    return this.m_shape.RayCast(t, e, this.m_body.GetTransform(), i)
}, box2d.b2Fixture.prototype.GetMassData = function(t) {
    return t = t || new box2d.b2MassData, this.m_shape.ComputeMass(t, this.m_density), t
}, box2d.b2Fixture.prototype.GetAABB = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= t && t < this.m_proxyCount), this.m_proxies[t].aabb
}, box2d.b2Fixture.prototype.Create = function(t, e) {
    this.m_userData = e.userData, this.m_friction = e.friction, this.m_restitution = e.restitution, this.m_body = t, this.m_next = null, this.m_filter.Copy(e.filter), this.m_isSensor = e.isSensor, this.m_shape = e.shape.Clone(), this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount()), this.m_proxyCount = 0, this.m_density = e.density
}, box2d.b2Fixture.prototype.Destroy = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === this.m_proxyCount), this.m_shape = null
}, box2d.b2Fixture.prototype.CreateProxies = function(t, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === this.m_proxyCount), this.m_proxyCount = this.m_shape.GetChildCount();
    for (var i = 0; i < this.m_proxyCount; ++i) {
        var o = this.m_proxies[i];
        this.m_shape.ComputeAABB(o.aabb, e, i), o.proxy = t.CreateProxy(o.aabb, o), o.fixture = this, o.childIndex = i
    }
}, box2d.b2Fixture.prototype.DestroyProxies = function(t) {
    for (var e = 0; e < this.m_proxyCount; ++e) {
        var i = this.m_proxies[e];
        t.DestroyProxy(i.proxy), i.proxy = null
    }
    this.m_proxyCount = 0
}, box2d.b2Fixture.prototype.Synchronize = function(t, e, i) {
    if (0 !== this.m_proxyCount)
        for (var o = 0; o < this.m_proxyCount; ++o) {
            var s = this.m_proxies[o],
                n = box2d.b2Fixture.prototype.Synchronize.s_aabb1,
                r = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(n, e, o), this.m_shape.ComputeAABB(r, i, o), s.aabb.Combine2(n, r);
            var a = box2d.b2SubVV(i.p, e.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            t.MoveProxy(s.proxy, s.aabb, a)
        }
}, box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2, box2d.b2Fixture.prototype.SetFilterData = function(t) {
    this.m_filter.Copy(t), this.Refilter()
}, box2d.b2Fixture.prototype.Refilter = function() {
    if (!this.m_body) {
        for (var t = this.m_body.GetContactList(); t;) {
            var e = t.contact,
                i = e.GetFixtureA(),
                o = e.GetFixtureB();
            (i === this || o === this) && e.FlagForFiltering(), t = t.next
        }
        var s = this.m_body.GetWorld();
        if (null !== s)
            for (var n = s.m_contactManager.m_broadPhase, r = 0; r < this.m_proxyCount; ++r) n.TouchProxy(this.m_proxies[r].proxy)
    }
}, box2d.b2Fixture.prototype.SetSensor = function(t) {
    t !== this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = t)
}, box2d.b2Fixture.prototype.Dump = function(t) {
    box2d.DEBUG && (box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n"), box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction), box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution), box2d.b2Log("    fd.density = %.15f;\n", this.m_density), box2d.b2Log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false"), box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits), box2d.b2Log("    fd.filter.maskBits = %d;\n", this.m_filter.maskBits), box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex), this.m_shape.Dump(), box2d.b2Log("\n"), box2d.b2Log("    fd.shape = shape;\n"), box2d.b2Log("\n"), box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", t))
}, goog.provide("box2d.b2Body"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Fixture"), box2d.b2BodyType = {
    b2_unknown: -1,
    b2_staticBody: 0,
    b2_kinematicBody: 1,
    b2_dynamicBody: 2,
    b2_bulletBody: 3
}, goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown), goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody), goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody), goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody), goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody), box2d.b2BodyDef = function() {
    this.position = new box2d.b2Vec2(0, 0), this.linearVelocity = new box2d.b2Vec2(0, 0)
}, box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody, box2d.b2BodyDef.prototype.position = null, box2d.b2BodyDef.prototype.angle = 0, box2d.b2BodyDef.prototype.linearVelocity = null, box2d.b2BodyDef.prototype.angularVelocity = 0, box2d.b2BodyDef.prototype.linearDamping = 0, box2d.b2BodyDef.prototype.angularDamping = 0, box2d.b2BodyDef.prototype.allowSleep = !0, box2d.b2BodyDef.prototype.awake = !0, box2d.b2BodyDef.prototype.fixedRotation = !1, box2d.b2BodyDef.prototype.bullet = !1, box2d.b2BodyDef.prototype.active = !0, box2d.b2BodyDef.prototype.userData = null, box2d.b2BodyDef.prototype.gravityScale = 1, box2d.b2BodyFlag = {
    e_none: 0,
    e_islandFlag: 1,
    e_awakeFlag: 2,
    e_autoSleepFlag: 4,
    e_bulletFlag: 8,
    e_fixedRotationFlag: 16,
    e_activeFlag: 32,
    e_toiFlag: 64
}, goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none), goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag), goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag), goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag), goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag), goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag), box2d.b2Body = function(t, e) {
    this.m_xf = new box2d.b2Transform, this.m_out_xf = new box2d.b2Transform, this.m_sweep = new box2d.b2Sweep, this.m_out_sweep = new box2d.b2Sweep, this.m_linearVelocity = new box2d.b2Vec2, this.m_out_linearVelocity = new box2d.b2Vec2, this.m_force = new box2d.b2Vec2, box2d.ENABLE_ASSERTS && box2d.b2Assert(t.position.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.linearVelocity.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angle)), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angularVelocity)), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.gravityScale) && 0 <= t.gravityScale), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angularDamping) && 0 <= t.angularDamping), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.linearDamping) && 0 <= t.linearDamping), this.m_flags = box2d.b2BodyFlag.e_none, t.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag), t.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag), t.awake && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag), t.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag), this.m_world = e, this.m_xf.p.Copy(t.position), this.m_xf.q.SetAngleRadians(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = t.angle, this.m_sweep.a = t.angle, this.m_sweep.alpha0 = 0, this.m_linearVelocity.Copy(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_gravityScale = t.gravityScale, this.m_force.SetZero(), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, t.type === box2d.b2BodyType.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0, this.m_controllerList = null, this.m_controllerCount = 0
}, box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none, box2d.b2Body.prototype.m_islandIndex = 0, box2d.b2Body.prototype.m_world = null, box2d.b2Body.prototype.m_xf = null, box2d.b2Body.prototype.m_out_xf = null, box2d.b2Body.prototype.m_sweep = null, box2d.b2Body.prototype.m_out_sweep = null, box2d.b2Body.prototype.m_jointList = null, box2d.b2Body.prototype.m_contactList = null, box2d.b2Body.prototype.m_prev = null, box2d.b2Body.prototype.m_next = null, box2d.b2Body.prototype.m_linearVelocity = null, box2d.b2Body.prototype.m_out_linearVelocity = null, box2d.b2Body.prototype.m_angularVelocity = 0, box2d.b2Body.prototype.m_linearDamping = 0, box2d.b2Body.prototype.m_angularDamping = 0, box2d.b2Body.prototype.m_gravityScale = 1, box2d.b2Body.prototype.m_force = null, box2d.b2Body.prototype.m_torque = 0, box2d.b2Body.prototype.m_sleepTime = 0, box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody, box2d.b2Body.prototype.m_mass = 1, box2d.b2Body.prototype.m_invMass = 1, box2d.b2Body.prototype.m_I = 0, box2d.b2Body.prototype.m_invI = 0, box2d.b2Body.prototype.m_userData = null, box2d.b2Body.prototype.m_fixtureList = null, box2d.b2Body.prototype.m_fixtureCount = 0, box2d.b2Body.prototype.m_controllerList = null, box2d.b2Body.prototype.m_controllerCount = 0, box2d.b2Body.prototype.CreateFixture = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 === this.m_world.IsLocked()) return null;
    var e = new box2d.b2Fixture;
    if (e.Create(this, t), this.m_flags & box2d.b2BodyFlag.e_activeFlag) {
        var i = this.m_world.m_contactManager.m_broadPhase;
        e.CreateProxies(i, this.m_xf)
    }
    return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, 0 < e.m_density && this.ResetMassData(), this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture, e
}, box2d.b2Body.prototype.CreateFixture2 = function(t, e) {
    void 0 === e && (e = 0);
    var i = box2d.b2Body.prototype.CreateFixture2.s_def;
    return i.shape = t, i.density = e, this.CreateFixture(i)
}, box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef, box2d.b2Body.prototype.DestroyFixture = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked()) {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(t.m_body === this), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_fixtureCount);
        for (var e = this.m_fixtureList, i = null, o = !1; null !== e;) {
            if (e === t) {
                i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, o = !0;
                break
            }
            e = (i = e).m_next
        }
        box2d.ENABLE_ASSERTS && box2d.b2Assert(o);
        for (var s = this.m_contactList; s;) {
            var n = s.contact;
            s = s.next;
            var r = n.GetFixtureA(),
                a = n.GetFixtureB();
            (t === r || t === a) && this.m_world.m_contactManager.Destroy(n)
        }
        if (this.m_flags & box2d.b2BodyFlag.e_activeFlag) {
            var h = this.m_world.m_contactManager.m_broadPhase;
            t.DestroyProxies(h)
        }
        t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData()
    }
}, box2d.b2Body.prototype.SetTransformVecRadians = function(t, e) {
    this.SetTransformXYRadians(t.x, t.y, e)
}, box2d.b2Body.prototype.SetTransformXYRadians = function(t, e, i) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && (this.m_xf.p.x !== t || this.m_xf.p.y !== e || this.m_xf.q.GetAngleRadians() !== i)) {
        this.m_xf.q.SetAngleRadians(i), this.m_xf.p.SetXY(t, e), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.a = i, this.m_sweep.c0.Copy(this.m_sweep.c), this.m_sweep.a0 = i;
        for (var o = this.m_world.m_contactManager.m_broadPhase, s = this.m_fixtureList; s; s = s.m_next) s.Synchronize(o, this.m_xf, this.m_xf)
    }
}, box2d.b2Body.prototype.SetTransform = function(t) {
    this.SetTransformVecRadians(t.p, t.GetAngleRadians())
}, box2d.b2Body.prototype.GetTransform = function(t) {
    return (t = t || this.m_out_xf).Copy(this.m_xf)
}, box2d.b2Body.prototype.GetPosition = function(t) {
    return (t = t || this.m_out_xf.p).Copy(this.m_xf.p)
}, box2d.b2Body.prototype.SetPosition = function(t) {
    this.SetTransformVecRadians(t, this.GetAngleRadians())
}, box2d.b2Body.prototype.SetPositionXY = function(t, e) {
    this.SetTransformXYRadians(t, e, this.GetAngleRadians())
}, box2d.b2Body.prototype.GetAngle = function() {
    return this.m_sweep.a
}, box2d.b2Body.prototype.GetAngleRadians = box2d.b2Body.prototype.GetAngle, box2d.b2Body.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
}, box2d.b2Body.prototype.SetAngle = function(t) {
    this.SetTransformVecRadians(this.GetPosition(), t)
}, box2d.b2Body.prototype.SetAngleRadians = box2d.b2Body.prototype.SetAngle, box2d.b2Body.prototype.SetAngleDegrees = function(t) {
    this.SetAngle(box2d.b2DegToRad(t))
}, box2d.b2Body.prototype.GetWorldCenter = function(t) {
    return (t = t || this.m_out_sweep.c).Copy(this.m_sweep.c)
}, box2d.b2Body.prototype.GetLocalCenter = function(t) {
    return (t = t || this.m_out_sweep.localCenter).Copy(this.m_sweep.localCenter)
}, box2d.b2Body.prototype.SetLinearVelocity = function(t) {
    this.m_type !== box2d.b2BodyType.b2_staticBody && (0 < box2d.b2DotVV(t, t) && this.SetAwake(!0), this.m_linearVelocity.Copy(t))
}, box2d.b2Body.prototype.GetLinearVelocity = function(t) {
    return (t = t || this.m_out_linearVelocity).Copy(this.m_linearVelocity)
}, box2d.b2Body.prototype.SetAngularVelocity = function(t) {
    this.m_type !== box2d.b2BodyType.b2_staticBody && (0 < t * t && this.SetAwake(!0), this.m_angularVelocity = t)
}, box2d.b2Body.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity
}, box2d.b2Body.prototype.GetDefinition = function(t) {
    return t.type = this.GetType(), t.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag, t.angle = this.GetAngleRadians(), t.angularDamping = this.m_angularDamping, t.gravityScale = this.m_gravityScale, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag, t.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag, t.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.Copy(this.GetLinearVelocity()), t.position.Copy(this.GetPosition()), t.userData = this.GetUserData(), t
}, box2d.b2Body.prototype.ApplyForce = function(t, e, i) {
    i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x))
}, box2d.b2Body.prototype.ApplyForceToCenter = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y))
}, box2d.b2Body.prototype.ApplyTorque = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += t))
}, box2d.b2Body.prototype.ApplyLinearImpulse = function(t, e, i) {
    i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x)))
}, box2d.b2Body.prototype.ApplyAngularImpulse = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * t))
}, box2d.b2Body.prototype.GetMass = function() {
    return this.m_mass
}, box2d.b2Body.prototype.GetInertia = function() {
    return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)
}, box2d.b2Body.prototype.GetMassData = function(t) {
    return t.mass = this.m_mass, t.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter), t.center.Copy(this.m_sweep.localCenter), t
}, box2d.b2Body.prototype.SetMassData = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && this.m_type === box2d.b2BodyType.b2_dynamicBody) {
        this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = t.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, 0 < t.I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = t.I - this.m_mass * box2d.b2DotVV(t.center, t.center), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I);
        var e = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(t.center), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, e, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
}, box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData = function() {
    if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type === box2d.b2BodyType.b2_staticBody || this.m_type === box2d.b2BodyType.b2_kinematicBody) return this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), void(this.m_sweep.a0 = this.m_sweep.a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type === box2d.b2BodyType.b2_dynamicBody);
    for (var t = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), e = this.m_fixtureList; e; e = e.m_next)
        if (0 !== e.m_density) {
            var i = e.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
            this.m_mass += i.mass, t.x += i.center.x * i.mass, t.y += i.center.y * i.mass, this.m_I += i.I
        }
    0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, t.x *= this.m_invMass, t.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), 0 < this.m_I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(t, t), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
    var o = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
    this.m_sweep.localCenter.Copy(t), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, o, box2d.b2Vec2.s_t0), this.m_linearVelocity)
}, box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData, box2d.b2Body.prototype.GetWorldPoint = function(t, e) {
    return box2d.b2MulXV(this.m_xf, t, e)
}, box2d.b2Body.prototype.GetWorldVector = function(t, e) {
    return box2d.b2MulRV(this.m_xf.q, t, e)
}, box2d.b2Body.prototype.GetLocalPoint = function(t, e) {
    return box2d.b2MulTXV(this.m_xf, t, e)
}, box2d.b2Body.prototype.GetLocalVector = function(t, e) {
    return box2d.b2MulTRV(this.m_xf.q, t, e)
}, box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(t, e) {
    return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(t, this.m_sweep.c, box2d.b2Vec2.s_t0), e)
}, box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(t, e) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t, e), e)
}, box2d.b2Body.prototype.GetLinearDamping = function() {
    return this.m_linearDamping
}, box2d.b2Body.prototype.SetLinearDamping = function(t) {
    this.m_linearDamping = t
}, box2d.b2Body.prototype.GetAngularDamping = function() {
    return this.m_angularDamping
}, box2d.b2Body.prototype.SetAngularDamping = function(t) {
    this.m_angularDamping = t
}, box2d.b2Body.prototype.GetGravityScale = function() {
    return this.m_gravityScale
}, box2d.b2Body.prototype.SetGravityScale = function(t) {
    this.m_gravityScale = t
}, box2d.b2Body.prototype.SetType = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && this.m_type !== t) {
        this.m_type = t, this.ResetMassData(), this.m_type === box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures()), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
        for (var e = this.m_contactList; e;) {
            var i = e;
            e = e.next, this.m_world.m_contactManager.Destroy(i.contact)
        }
        this.m_contactList = null;
        for (var o = this.m_world.m_contactManager.m_broadPhase, s = this.m_fixtureList; s; s = s.m_next)
            for (var n = s.m_proxyCount, r = 0; r < n; ++r) o.TouchProxy(s.m_proxies[r].proxy)
    }
}, box2d.b2Body.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Body.prototype.SetBullet = function(t) {
    t ? this.m_flags |= box2d.b2BodyFlag.e_bulletFlag : this.m_flags &= ~box2d.b2BodyFlag.e_bulletFlag
}, box2d.b2Body.prototype.IsBullet = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag
}, box2d.b2Body.prototype.SetSleepingAllowed = function(t) {
    t ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0))
}, box2d.b2Body.prototype.IsSleepingAllowed = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag
}, box2d.b2Body.prototype.SetAwake = function(t) {
    t ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
}, box2d.b2Body.prototype.IsAwake = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag
}, box2d.b2Body.prototype.SetActive = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), t !== this.IsActive())
        if (t) {
            this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
            for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxies(e, this.m_xf)
        } else {
            this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;
            for (e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxies(e);
            for (var o = this.m_contactList; o;) {
                var s = o;
                o = o.next, this.m_world.m_contactManager.Destroy(s.contact)
            }
            this.m_contactList = null
        }
}, box2d.b2Body.prototype.IsActive = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_activeFlag) === box2d.b2BodyFlag.e_activeFlag
}, box2d.b2Body.prototype.SetFixedRotation = function(t) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag !== t && (t ? this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags &= ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData())
}, box2d.b2Body.prototype.IsFixedRotation = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag
}, box2d.b2Body.prototype.GetFixtureList = function() {
    return this.m_fixtureList
}, box2d.b2Body.prototype.GetJointList = function() {
    return this.m_jointList
}, box2d.b2Body.prototype.GetContactList = function() {
    return this.m_contactList
}, box2d.b2Body.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Body.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Body.prototype.SetUserData = function(t) {
    this.m_userData = t
}, box2d.b2Body.prototype.GetWorld = function() {
    return this.m_world
}, box2d.b2Body.prototype.SynchronizeFixtures = function() {
    var t = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    t.q.SetAngleRadians(this.m_sweep.a0), box2d.b2MulRV(t.q, this.m_sweep.localCenter, t.p), box2d.b2SubVV(this.m_sweep.c0, t.p, t.p);
    for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(e, t, this.m_xf)
}, box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform, box2d.b2Body.prototype.SynchronizeTransform = function() {
    this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
}, box2d.b2Body.prototype.ShouldCollide = function(t) {
    if (this.m_type !== box2d.b2BodyType.b2_dynamicBody && t.m_type !== box2d.b2BodyType.b2_dynamicBody) return !1;
    for (var e = this.m_jointList; e; e = e.next)
        if (e.other === t && !1 === e.joint.m_collideConnected) return !1;
    return !0
}, box2d.b2Body.prototype.Advance = function(t) {
    this.m_sweep.Advance(t), this.m_sweep.c.Copy(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
}, box2d.b2Body.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_islandIndex;
        box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n");
        var e = "";
        switch (this.m_type) {
            case box2d.b2BodyType.b2_staticBody:
                e = "box2d.b2BodyType.b2_staticBody";
                break;
            case box2d.b2BodyType.b2_kinematicBody:
                e = "box2d.b2BodyType.b2_kinematicBody";
                break;
            case box2d.b2BodyType.b2_dynamicBody:
                e = "box2d.b2BodyType.b2_dynamicBody";
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        box2d.b2Log("  bd.type = %s;\n", e), box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y), box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a), box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y), box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity), box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping), box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping), box2d.b2Log("  bd.allowSleep = %s;\n", this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag ? "true" : "false"), box2d.b2Log("  bd.awake = %s;\n", this.m_flags & box2d.b2BodyFlag.e_awakeFlag ? "true" : "false"), box2d.b2Log("  bd.fixedRotation = %s;\n", this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag ? "true" : "false"), box2d.b2Log("  bd.bullet = %s;\n", this.m_flags & box2d.b2BodyFlag.e_bulletFlag ? "true" : "false"), box2d.b2Log("  bd.active = %s;\n", this.m_flags & box2d.b2BodyFlag.e_activeFlag ? "true" : "false"), box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale), box2d.b2Log("\n"), box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n", this.m_islandIndex), box2d.b2Log("\n");
        for (var i = this.m_fixtureList; i; i = i.m_next) box2d.b2Log("  if (true)\n"), box2d.b2Log("  {\n"), i.Dump(t), box2d.b2Log("  }\n");
        box2d.b2Log("}\n")
    }
}, box2d.b2Body.prototype.GetControllerList = function() {
    return this.m_controllerList
}, box2d.b2Body.prototype.GetControllerCount = function() {
    return this.m_controllerCount
}, goog.provide("box2d.b2World"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2ContactManager"), goog.require("box2d.b2ContactSolver"), goog.require("box2d.b2Island"), goog.require("box2d.b2Body"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2JointFactory"), box2d.b2WorldFlag = {
    e_none: 0,
    e_newFixture: 1,
    e_locked: 2,
    e_clearForces: 4
}, goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none), goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture), goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked), goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces), box2d.b2World = function(t) {
    this.m_flags = box2d.b2WorldFlag.e_clearForces, this.m_contactManager = new box2d.b2ContactManager, this.m_gravity = t.Clone(), this.m_out_gravity = new box2d.b2Vec2, this.m_allowSleep = !0, this.m_destructionListener = null, this.m_debugDraw = null, this.m_warmStarting = !0, this.m_continuousPhysics = !0, this.m_subStepping = !1, this.m_stepComplete = !0, this.m_profile = new box2d.b2Profile, this.m_island = new box2d.b2Island, this.s_stack = new Array
}, box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none, box2d.b2World.prototype.m_contactManager = null, box2d.b2World.prototype.m_bodyList = null, box2d.b2World.prototype.m_jointList = null, box2d.b2World.prototype.m_bodyCount = 0, box2d.b2World.prototype.m_jointCount = 0, box2d.b2World.prototype.m_gravity = null, box2d.b2World.prototype.m_out_gravity = null, box2d.b2World.prototype.m_allowSleep = !0, box2d.b2World.prototype.m_destructionListener = null, box2d.b2World.prototype.m_debugDraw = null, box2d.b2World.prototype.m_inv_dt0 = 0, box2d.b2World.prototype.m_warmStarting = !0, box2d.b2World.prototype.m_continuousPhysics = !0, box2d.b2World.prototype.m_subStepping = !1, box2d.b2World.prototype.m_stepComplete = !0, box2d.b2World.prototype.m_profile = null, box2d.b2World.prototype.m_island = null, box2d.b2World.prototype.s_stack = null, box2d.b2World.prototype.m_controllerList = null, box2d.b2World.prototype.m_controllerCount = 0, box2d.b2World.prototype.SetAllowSleeping = function(t) {
    if (t !== this.m_allowSleep && (this.m_allowSleep = t, !1 === this.m_allowSleep))
        for (var e = this.m_bodyList; e; e = e.m_next) e.SetAwake(!0)
}, box2d.b2World.prototype.GetAllowSleeping = function() {
    return this.m_allowSleep
}, box2d.b2World.prototype.SetWarmStarting = function(t) {
    this.m_warmStarting = t
}, box2d.b2World.prototype.GetWarmStarting = function() {
    return this.m_warmStarting
}, box2d.b2World.prototype.SetContinuousPhysics = function(t) {
    this.m_continuousPhysics = t
}, box2d.b2World.prototype.GetContinuousPhysics = function() {
    return this.m_continuousPhysics
}, box2d.b2World.prototype.SetSubStepping = function(t) {
    this.m_subStepping = t
}, box2d.b2World.prototype.GetSubStepping = function() {
    return this.m_subStepping
}, box2d.b2World.prototype.GetBodyList = function() {
    return this.m_bodyList
}, box2d.b2World.prototype.GetJointList = function() {
    return this.m_jointList
}, box2d.b2World.prototype.GetContactList = function() {
    return this.m_contactManager.m_contactList
}, box2d.b2World.prototype.GetBodyCount = function() {
    return this.m_bodyCount
}, box2d.b2World.prototype.GetJointCount = function() {
    return this.m_jointCount
}, box2d.b2World.prototype.GetContactCount = function() {
    return this.m_contactManager.m_contactCount
}, box2d.b2World.prototype.SetGravity = function(t, e) {
    if (e = e || !0, (this.m_gravity.x !== t.x || this.m_gravity.y !== t.y) && (this.m_gravity.Copy(t), e))
        for (var i = this.m_bodyList; i; i = i.m_next) i.SetAwake(!0)
}, box2d.b2World.prototype.GetGravity = function(t) {
    return (t = t || this.m_out_gravity).Copy(this.m_gravity)
}, box2d.b2World.prototype.IsLocked = function() {
    return 0 < (this.m_flags & box2d.b2WorldFlag.e_locked)
}, box2d.b2World.prototype.SetAutoClearForces = function(t) {
    t ? this.m_flags |= box2d.b2WorldFlag.e_clearForces : this.m_flags &= ~box2d.b2WorldFlag.e_clearForces
}, box2d.b2World.prototype.GetAutoClearForces = function() {
    return (this.m_flags & box2d.b2WorldFlag.e_clearForces) === box2d.b2WorldFlag.e_clearForces
}, box2d.b2World.prototype.GetContactManager = function() {
    return this.m_contactManager
}, box2d.b2World.prototype.GetProfile = function() {
    return this.m_profile
}, box2d.b2World.prototype.SetDestructionListener = function(t) {
    this.m_destructionListener = t
}, box2d.b2World.prototype.SetContactFilter = function(t) {
    this.m_contactManager.m_contactFilter = t
}, box2d.b2World.prototype.SetContactListener = function(t) {
    this.m_contactManager.m_contactListener = t
}, box2d.b2World.prototype.SetDebugDraw = function(t) {
    this.m_debugDraw = t
}, box2d.b2World.prototype.CreateBody = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), this.IsLocked()) return null;
    var e = new box2d.b2Body(t, this);
    return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e
}, box2d.b2World.prototype.DestroyBody = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) {
        for (var e = t.m_jointList; e;) {
            var i = e;
            e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint), t.m_jointList = e
        }
        t.m_jointList = null;
        for (var o = t.m_controllerList; o;) {
            var s = o;
            o = o.nextController, s.controller.RemoveBody(t)
        }
        for (var n = t.m_contactList; n;) {
            var r = n;
            n = n.next, this.m_contactManager.Destroy(r.contact)
        }
        t.m_contactList = null;
        for (var a = t.m_fixtureList; a;) {
            var h = a;
            a = a.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(h), h.DestroyProxies(this.m_contactManager.m_broadPhase), h.Destroy(), t.m_fixtureList = a, t.m_fixtureCount -= 1
        }
        t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount
    }
}, box2d.b2World.prototype.CreateJoint = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), this.IsLocked()) return null;
    var e = box2d.b2JointFactory.Create(t, null);
    e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, (e.m_edgeA.joint = e).m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, (e.m_edgeB.joint = e).m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
    var i = t.bodyA,
        o = t.bodyB;
    if (!1 === t.collideConnected)
        for (var s = o.GetContactList(); s;) s.other === i && s.contact.FlagForFiltering(), s = s.next;
    return e
}, box2d.b2World.prototype.DestroyJoint = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) {
        var e = t.m_collideConnected;
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_jointList && (this.m_jointList = t.m_next);
        var i = t.m_bodyA,
            o = t.m_bodyB;
        if (i.SetAwake(!0), o.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA === i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB === o.m_jointList && (o.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, box2d.b2JointFactory.Destroy(t, null), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_jointCount), --this.m_jointCount, !1 === e)
            for (var s = o.GetContactList(); s;) s.other === i && s.contact.FlagForFiltering(), s = s.next
    }
}, box2d.b2World.prototype.Solve = function(t) {
    for (var e = this.m_controllerList; e; e = e.m_next) e.Step(t);
    this.m_profile.solveInit = 0, this.m_profile.solveVelocity = 0, this.m_profile.solvePosition = 0;
    var i = this.m_island;
    i.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
    for (var o = this.m_bodyList; o; o = o.m_next) o.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
    for (var s = this.m_contactManager.m_contactList; s; s = s.m_next) s.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
    for (var n = this.m_jointList; n; n = n.m_next) n.m_islandFlag = !1;
    for (var r = this.m_bodyCount, a = this.s_stack, h = this.m_bodyList; h; h = h.m_next)
        if (!(h.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 !== h.IsAwake() && !1 !== h.IsActive() && h.GetType() !== box2d.b2BodyType.b2_staticBody) {
            i.Clear();
            var l = 0;
            for ((a[l++] = h).m_flags |= box2d.b2BodyFlag.e_islandFlag; 0 < l;) {
                o = a[--l];
                if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!0 === o.IsActive()), i.AddBody(o), o.SetAwake(!0), o.GetType() !== box2d.b2BodyType.b2_staticBody) {
                    for (var d = o.m_contactList; d; d = d.next) {
                        var c = d.contact;
                        if (!(c.m_flags & box2d.b2ContactFlag.e_islandFlag) && !1 !== c.IsEnabled() && !1 !== c.IsTouching()) {
                            var u = c.m_fixtureA.m_isSensor,
                                p = c.m_fixtureB.m_isSensor;
                            if (!u && !p) i.AddContact(c), c.m_flags |= box2d.b2ContactFlag.e_islandFlag, (m = d.other).m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(l < r), (a[l++] = m).m_flags |= box2d.b2BodyFlag.e_islandFlag)
                        }
                    }
                    for (var b = o.m_jointList; b; b = b.next)
                        if (!0 !== b.joint.m_islandFlag) {
                            var m;
                            !1 !== (m = b.other).IsActive() && (i.AddJoint(b.joint), b.joint.m_islandFlag = !0, m.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(l < r), (a[l++] = m).m_flags |= box2d.b2BodyFlag.e_islandFlag))
                        }
                }
            }
            var y = new box2d.b2Profile;
            i.Solve(y, t, this.m_gravity, this.m_allowSleep), this.m_profile.solveInit += y.solveInit, this.m_profile.solveVelocity += y.solveVelocity, this.m_profile.solvePosition += y.solvePosition;
            for (var f = 0; f < i.m_bodyCount; ++f) {
                (o = i.m_bodies[f]).GetType() === box2d.b2BodyType.b2_staticBody && (o.m_flags &= ~box2d.b2BodyFlag.e_islandFlag)
            }
        }
    for (f = 0; f < a.length && a[f]; ++f) a[f] = null;
    var x = new box2d.b2Timer;
    for (o = this.m_bodyList; o; o = o.m_next) 0 != (o.m_flags & box2d.b2BodyFlag.e_islandFlag) && o.GetType() !== box2d.b2BodyType.b2_staticBody && o.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts(), this.m_profile.broadphase = x.GetMilliseconds()
}, box2d.b2World.prototype.SolveTOI = function(t) {
    var e = this.m_island;
    if (e.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener), this.m_stepComplete) {
        for (var i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, i.m_sweep.alpha0 = 0;
        for (var o = this.m_contactManager.m_contactList; o; o = o.m_next) o.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), o.m_toiCount = 0, o.m_toi = 1
    }
    for (;;) {
        var s = null,
            n = 1;
        for (o = this.m_contactManager.m_contactList; o; o = o.m_next)
            if (!1 !== o.IsEnabled() && !(o.m_toiCount > box2d.b2_maxSubSteps)) {
                var r = 1;
                if (o.m_flags & box2d.b2ContactFlag.e_toiFlag) r = o.m_toi;
                else {
                    var a = o.GetFixtureA(),
                        h = o.GetFixtureB();
                    if (a.IsSensor() || h.IsSensor()) continue;
                    var l = a.GetBody(),
                        d = h.GetBody(),
                        c = l.m_type,
                        u = d.m_type;
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(c === box2d.b2BodyType.b2_dynamicBody || u === box2d.b2BodyType.b2_dynamicBody);
                    var p = l.IsAwake() && c !== box2d.b2BodyType.b2_staticBody,
                        b = d.IsAwake() && u !== box2d.b2BodyType.b2_staticBody;
                    if (!1 === p && !1 === b) continue;
                    var m = l.IsBullet() || c !== box2d.b2BodyType.b2_dynamicBody,
                        y = d.IsBullet() || u !== box2d.b2BodyType.b2_dynamicBody;
                    if (!1 === m && !1 === y) continue;
                    var f = l.m_sweep.alpha0;
                    l.m_sweep.alpha0 < d.m_sweep.alpha0 ? (f = d.m_sweep.alpha0, l.m_sweep.Advance(f)) : d.m_sweep.alpha0 < l.m_sweep.alpha0 && (f = l.m_sweep.alpha0, d.m_sweep.Advance(f)), box2d.ENABLE_ASSERTS && box2d.b2Assert(f < 1);
                    var x = o.GetChildIndexA(),
                        g = o.GetChildIndexB(),
                        _ = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    _.proxyA.SetShape(a.GetShape(), x), _.proxyB.SetShape(h.GetShape(), g), _.sweepA.Copy(l.m_sweep), _.sweepB.Copy(d.m_sweep), _.tMax = 1;
                    var v = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(v, _);
                    var S = v.t;
                    r = v.state === box2d.b2TOIOutputState.e_touching ? box2d.b2Min(f + (1 - f) * S, 1) : 1, o.m_toi = r, o.m_flags |= box2d.b2ContactFlag.e_toiFlag
                }
                r < n && (s = o, n = r)
            }
        if (null === s || 1 - 10 * box2d.b2_epsilon < n) {
            this.m_stepComplete = !0;
            break
        }
        a = s.GetFixtureA(), h = s.GetFixtureB(), l = a.GetBody(), d = h.GetBody();
        var C = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(l.m_sweep),
            w = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(d.m_sweep);
        if (l.Advance(n), d.Advance(n), s.Update(this.m_contactManager.m_contactListener), s.m_flags &= ~box2d.b2ContactFlag.e_toiFlag, ++s.m_toiCount, !1 !== s.IsEnabled() && !1 !== s.IsTouching()) {
            l.SetAwake(!0), d.SetAwake(!0), e.Clear(), e.AddBody(l), e.AddBody(d), e.AddContact(s), l.m_flags |= box2d.b2BodyFlag.e_islandFlag, d.m_flags |= box2d.b2BodyFlag.e_islandFlag, s.m_flags |= box2d.b2ContactFlag.e_islandFlag;
            for (var A = 0; A < 2; ++A) {
                if ((R = 0 === A ? l : d).m_type === box2d.b2BodyType.b2_dynamicBody)
                    for (var P = R.m_contactList; P && e.m_bodyCount !== e.m_bodyCapacity && e.m_contactCount !== e.m_contactCapacity; P = P.next) {
                        var T = P.contact;
                        if (!(T.m_flags & box2d.b2ContactFlag.e_islandFlag)) {
                            var B = P.other;
                            if (B.m_type !== box2d.b2BodyType.b2_dynamicBody || !1 !== R.IsBullet() || !1 !== B.IsBullet()) {
                                var M = T.m_fixtureA.m_isSensor,
                                    E = T.m_fixtureB.m_isSensor;
                                if (!M && !E) {
                                    var I = box2d.b2World.prototype.SolveTOI.s_backup.Copy(B.m_sweep);
                                    0 == (B.m_flags & box2d.b2BodyFlag.e_islandFlag) && B.Advance(n), T.Update(this.m_contactManager.m_contactListener), !1 !== T.IsEnabled() && !1 !== T.IsTouching() ? (T.m_flags |= box2d.b2ContactFlag.e_islandFlag, e.AddContact(T), B.m_flags & box2d.b2BodyFlag.e_islandFlag || (B.m_flags |= box2d.b2BodyFlag.e_islandFlag, B.m_type !== box2d.b2BodyType.b2_staticBody && B.SetAwake(!0), e.AddBody(B))) : (B.m_sweep.Copy(I), B.SynchronizeTransform())
                                }
                            }
                        }
                    }
            }
            var V = box2d.b2World.prototype.SolveTOI.s_subStep;
            V.dt = (1 - n) * t.dt, V.inv_dt = 1 / V.dt, V.dtRatio = 1, V.positionIterations = 20, V.velocityIterations = t.velocityIterations, V.warmStarting = !1, e.SolveTOI(V, l.m_islandIndex, d.m_islandIndex);
            for (A = 0; A < e.m_bodyCount; ++A) {
                var R;
                if ((R = e.m_bodies[A]).m_flags &= ~box2d.b2BodyFlag.e_islandFlag, R.m_type === box2d.b2BodyType.b2_dynamicBody) {
                    R.SynchronizeFixtures();
                    for (P = R.m_contactList; P; P = P.next) P.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag)
                }
            }
            if (this.m_contactManager.FindNewContacts(), this.m_subStepping) {
                this.m_stepComplete = !1;
                break
            }
        } else s.SetEnabled(!1), l.m_sweep.Copy(C), d.m_sweep.Copy(w), l.SynchronizeTransform(), d.SynchronizeTransform()
    }
}, box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep, box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput, box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput, box2d.b2World.prototype.Step = function(t, e, i) {
    var o = new box2d.b2Timer;
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture), this.m_flags |= box2d.b2WorldFlag.e_locked;
    var s = box2d.b2World.prototype.Step.s_step;
    s.dt = t, s.velocityIterations = e, s.positionIterations = i, s.inv_dt = 0 < t ? 1 / t : 0, s.dtRatio = this.m_inv_dt0 * t, s.warmStarting = this.m_warmStarting;
    var n = new box2d.b2Timer;
    if (this.m_contactManager.Collide(), this.m_profile.collide = n.GetMilliseconds(), this.m_stepComplete && 0 < s.dt) {
        n = new box2d.b2Timer;
        this.Solve(s), this.m_profile.solve = n.GetMilliseconds()
    }
    if (this.m_continuousPhysics && 0 < s.dt) {
        n = new box2d.b2Timer;
        this.SolveTOI(s), this.m_profile.solveTOI = n.GetMilliseconds()
    }
    0 < s.dt && (this.m_inv_dt0 = s.inv_dt), this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces(), this.m_flags &= ~box2d.b2WorldFlag.e_locked, this.m_profile.step = o.GetMilliseconds()
}, box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep, box2d.b2World.prototype.ClearForces = function() {
    for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0
}, box2d.b2World.prototype.QueryAABB = function(o, t) {
    var s = this.m_contactManager.m_broadPhase;
    s.Query(function(t) {
        var e = s.GetUserData(t);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2FixtureProxy);
        var i = e.fixture;
        return e.childIndex, o instanceof box2d.b2QueryCallback ? o.ReportFixture(i) : o(i)
    }, t)
}, box2d.b2World.prototype.QueryShape = function(o, s, n) {
    var r = this.m_contactManager.m_broadPhase,
        t = box2d.b2World.prototype.QueryShape.s_aabb;
    s.ComputeAABB(t, n, 0), r.Query(function(t) {
        var e = r.GetUserData(t);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2FixtureProxy);
        var i = e.fixture;
        return e.childIndex, !box2d.b2TestOverlapShape(s, 0, i.GetShape(), 0, n, i.GetBody().GetTransform()) || (o instanceof box2d.b2QueryCallback ? o.ReportFixture(i) : o(i))
    }, t)
}, box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.QueryPoint = function(o, s) {
    var n = this.m_contactManager.m_broadPhase,
        t = box2d.b2World.prototype.QueryPoint.s_aabb;
    t.lowerBound.SetXY(s.x - box2d.b2_linearSlop, s.y - box2d.b2_linearSlop), t.upperBound.SetXY(s.x + box2d.b2_linearSlop, s.y + box2d.b2_linearSlop), n.Query(function(t) {
        var e = n.GetUserData(t);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2FixtureProxy);
        var i = e.fixture;
        return e.childIndex, !i.TestPoint(s) || (o instanceof box2d.b2QueryCallback ? o.ReportFixture(i) : o(i))
    }, t)
}, box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.RayCast = function(h, l, d) {
    var c = this.m_contactManager.m_broadPhase,
        t = box2d.b2World.prototype.RayCast.s_input;
    t.maxFraction = 1, t.p1.Copy(l), t.p2.Copy(d), c.RayCast(function(t, e) {
        var i = c.GetUserData(e);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(i instanceof box2d.b2FixtureProxy);
        var o = i.fixture,
            s = i.childIndex,
            n = box2d.b2World.prototype.RayCast.s_output;
        if (o.RayCast(n, t, s)) {
            var r = n.fraction,
                a = box2d.b2World.prototype.RayCast.s_point;
            return a.SetXY((1 - r) * l.x + r * d.x, (1 - r) * l.y + r * d.y), h instanceof box2d.b2RayCastCallback ? h.ReportFixture(o, a, n.normal, r) : h(o, a, n.normal, r)
        }
        return t.maxFraction
    }, t)
}, box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput, box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput, box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2, box2d.b2World.prototype.RayCastOne = function(t, e) {
    var s = null,
        n = 1;
    return this.RayCast(function(t, e, i, o) {
        return o < n && (n = o, s = t), n
    }, t, e), s
}, box2d.b2World.prototype.RayCastAll = function(t, e, i) {
    return i.length = 0, this.RayCast(function(t) {
        return i.push(t), 1
    }, t, e), i
}, box2d.b2World.prototype.DrawShape = function(t, e) {
    var i = t.GetShape();
    switch (i.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            var o = i instanceof box2d.b2CircleShape ? i : null,
                s = o.m_p,
                n = o.m_radius,
                r = box2d.b2Vec2.UNITX;
            this.m_debugDraw.DrawSolidCircle(s, n, r, e);
            break;
        case box2d.b2ShapeType.e_edgeShape:
            var a = i instanceof box2d.b2EdgeShape ? i : null,
                h = a.m_vertex1,
                l = a.m_vertex2;
            this.m_debugDraw.DrawSegment(h, l, e);
            break;
        case box2d.b2ShapeType.e_chainShape:
            for (var d = i instanceof box2d.b2ChainShape ? i : null, c = d.m_count, u = (h = (m = d.m_vertices)[0], 0); u < c; ++u) {
                l = m[u];
                this.m_debugDraw.DrawSegment(h, l, e), this.m_debugDraw.DrawCircle(l, .05, e), h = l
            }
            break;
        case box2d.b2ShapeType.e_polygonShape:
            var p = i instanceof box2d.b2PolygonShape ? i : null,
                b = p.m_count,
                m = p.m_vertices;
            this.m_debugDraw.DrawSolidPolygon(m, b, e)
    }
}, box2d.b2World.prototype.DrawJoint = function(t) {
    var e = t.GetBodyA(),
        i = t.GetBodyB(),
        o = e.m_xf,
        s = i.m_xf,
        n = o.p,
        r = s.p,
        a = t.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1),
        h = t.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2),
        l = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(.5, .8, .8);
    switch (t.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(a, h, l);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            var d = t instanceof box2d.b2PulleyJoint ? t : null,
                c = d.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1),
                u = d.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(c, a, l), this.m_debugDraw.DrawSegment(u, h, l), this.m_debugDraw.DrawSegment(c, u, l);
            break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(a, h, l);
            break;
        default:
            this.m_debugDraw.DrawSegment(n, a, l), this.m_debugDraw.DrawSegment(a, h, l), this.m_debugDraw.DrawSegment(r, h, l)
    }
}, box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(.5, .8, .8), box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawDebugData = function() {
    if (null !== this.m_debugDraw) {
        var t = this.m_debugDraw.GetFlags(),
            e = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);
        if (t & box2d.b2DrawFlags.e_shapeBit)
            for (var i = this.m_bodyList; i; i = i.m_next) {
                var o = i.m_xf;
                this.m_debugDraw.PushTransform(o);
                for (var s = i.GetFixtureList(); s; s = s.m_next) !1 === i.IsActive() ? e.SetRGB(.5, .5, .3) : i.GetType() === box2d.b2BodyType.b2_staticBody ? e.SetRGB(.5, .9, .5) : i.GetType() === box2d.b2BodyType.b2_kinematicBody ? e.SetRGB(.5, .5, .9) : !1 === i.IsAwake() ? e.SetRGB(.6, .6, .6) : e.SetRGB(.9, .7, .7), this.DrawShape(s, e);
                this.m_debugDraw.PopTransform(o)
            }
        if (t & box2d.b2DrawFlags.e_jointBit)
            for (var n = this.m_jointList; n; n = n.m_next) this.DrawJoint(n);
        if (t & box2d.b2DrawFlags.e_aabbBit) {
            e.SetRGB(.9, .3, .9);
            var r = this.m_contactManager.m_broadPhase,
                a = box2d.b2World.prototype.DrawDebugData.s_vs;
            for (i = this.m_bodyList; i; i = i.m_next)
                if (!1 !== i.IsActive())
                    for (s = i.GetFixtureList(); s; s = s.m_next)
                        for (var h = 0; h < s.m_proxyCount; ++h) {
                            var l = s.m_proxies[h],
                                d = r.GetFatAABB(l.proxy);
                            a[0].SetXY(d.lowerBound.x, d.lowerBound.y), a[1].SetXY(d.upperBound.x, d.lowerBound.y), a[2].SetXY(d.upperBound.x, d.upperBound.y), a[3].SetXY(d.lowerBound.x, d.upperBound.y), this.m_debugDraw.DrawPolygon(a, 4, e)
                        }
        }
        if (t & box2d.b2DrawFlags.e_centerOfMassBit)
            for (i = this.m_bodyList; i; i = i.m_next) {
                (o = box2d.b2World.prototype.DrawDebugData.s_xf).q.Copy(i.m_xf.q), o.p.Copy(i.GetWorldCenter()), this.m_debugDraw.DrawTransform(o)
            }
        if (t & box2d.b2DrawFlags.e_controllerBit)
            for (var c = this.m_controllerList; c; c = c.m_next) c.Draw(this.m_debugDraw)
    }
}, box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0), box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4), box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform, box2d.b2World.prototype.SetBroadPhase = function(t) {
    var e = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = t;
    for (var i = this.m_bodyList; i; i = i.m_next)
        for (var o = i.m_fixtureList; o; o = o.m_next) o.m_proxy = t.CreateProxy(e.GetFatAABB(o.m_proxy), o)
}, box2d.b2World.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount()
}, box2d.b2World.prototype.GetTreeHeight = function() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight()
}, box2d.b2World.prototype.GetTreeBalance = function() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance()
}, box2d.b2World.prototype.GetTreeQuality = function() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality()
}, box2d.b2World.prototype.ShiftOrigin = function(t) {
    if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) {
        for (var e = this.m_bodyList; e; e = e.m_next) e.m_xf.p.SelfSub(t), e.m_sweep.c0.SelfSub(t), e.m_sweep.c.SelfSub(t);
        for (var i = this.m_jointList; i; i = i.m_next) i.ShiftOrigin(t);
        this.m_contactManager.m_broadPhase.ShiftOrigin(t)
    }
}, box2d.b2World.prototype.Dump = function() {
    if (box2d.DEBUG) {
        if ((this.m_flags & box2d.b2WorldFlag.e_locked) === box2d.b2WorldFlag.e_locked) return;
        box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y), box2d.b2Log("this.m_world.SetGravity(g);\n"), box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount), box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount);
        for (var t = 0, e = this.m_bodyList; e; e = e.m_next) e.m_islandIndex = t, e.Dump(), ++t;
        t = 0;
        for (var i = this.m_jointList; i; i = i.m_next) i.m_index = t, ++t;
        for (i = this.m_jointList; i; i = i.m_next) i.m_type !== box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), i.Dump(), box2d.b2Log("}\n"));
        for (i = this.m_jointList; i; i = i.m_next) i.m_type === box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), i.Dump(), box2d.b2Log("}\n"))
    }
}, box2d.b2World.prototype.AddController = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === t.m_world, "Controller can only be a member of one world"), t.m_world = this, t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t
}, box2d.b2World.prototype.RemoveController = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(t.m_world === this, "Controller is not a member of this world"), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList === t && (this.m_controllerList = t.m_next), --this.m_controllerCount, t.m_prev = null, t.m_next = null, t.m_world = null
}, goog.provide("box2d.b2AreaJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2AreaJointDef = function() {
    goog.base(this, box2d.b2JointType.e_areaJoint), this.bodies = new Array
}, goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef), box2d.b2AreaJointDef.prototype.world = null, box2d.b2AreaJointDef.prototype.bodies = null, box2d.b2AreaJointDef.prototype.frequencyHz = 0, box2d.b2AreaJointDef.prototype.dampingRatio = 0, box2d.b2AreaJointDef.prototype.AddBody = function(t) {
    this.bodies.push(t), 1 === this.bodies.length ? this.bodyA = t : 2 === this.bodies.length && (this.bodyB = t)
}, box2d.b2AreaJoint = function(t) {
    goog.base(this, t), box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= t.bodies.length, "You cannot create an area joint with less than three bodies."), this.m_bodies = t.bodies, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_targetLengths = box2d.b2MakeNumberArray(t.bodies.length), this.m_normals = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_joints = new Array(t.bodies.length), this.m_deltas = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_delta = new box2d.b2Vec2;
    var e = new box2d.b2DistanceJointDef;
    e.frequencyHz = t.frequencyHz, e.dampingRatio = t.dampingRatio;
    for (var i = this.m_targetArea = 0, o = this.m_bodies.length; i < o; ++i) {
        var s = this.m_bodies[i],
            n = this.m_bodies[(i + 1) % o],
            r = s.GetWorldCenter(),
            a = n.GetWorldCenter();
        this.m_targetLengths[i] = box2d.b2DistanceVV(r, a), this.m_targetArea += box2d.b2CrossVV(r, a), e.Initialize(s, n, r, a), this.m_joints[i] = t.world.CreateJoint(e)
    }
    this.m_targetArea *= .5
}, goog.inherits(box2d.b2AreaJoint, box2d.b2Joint), box2d.b2AreaJoint.prototype.m_bodies = null, box2d.b2AreaJoint.prototype.m_frequencyHz = 0, box2d.b2AreaJoint.prototype.m_dampingRatio = 0, box2d.b2AreaJoint.prototype.m_impulse = 0, box2d.b2AreaJoint.prototype.m_targetLengths = null, box2d.b2AreaJoint.prototype.m_targetArea = 0, box2d.b2AreaJoint.prototype.m_normals = null, box2d.b2AreaJoint.prototype.m_joints = null, box2d.b2AreaJoint.prototype.m_deltas = null, box2d.b2AreaJoint.prototype.m_delta = null, box2d.b2AreaJoint.prototype.GetAnchorA = function(t) {
    return t.SetZero()
}, box2d.b2AreaJoint.prototype.GetAnchorB = function(t) {
    return t.SetZero()
}, box2d.b2AreaJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetZero()
}, box2d.b2AreaJoint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2AreaJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t;
    for (var e = 0, i = this.m_joints.length; e < i; ++e) this.m_joints[e].SetFrequency(t)
}, box2d.b2AreaJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2AreaJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t;
    for (var e = 0, i = this.m_joints.length; e < i; ++e) this.m_joints[e].SetDampingRatio(t)
}, box2d.b2AreaJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2AreaJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Area joint dumping is not supported.\n")
}, box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(t) {
    for (var e = 0, i = this.m_bodies.length; e < i; ++e) {
        var o = this.m_bodies[(e + i - 1) % i],
            s = this.m_bodies[(e + 1) % i],
            n = t.positions[o.m_islandIndex].c,
            r = t.positions[s.m_islandIndex].c,
            a = this.m_deltas[e];
        box2d.b2SubVV(r, n, a)
    }
    if (t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        for (e = 0, i = this.m_bodies.length; e < i; ++e) {
            var h = this.m_bodies[e],
                l = t.velocities[h.m_islandIndex].v;
            a = this.m_deltas[e];
            l.x += h.m_invMass * a.y * .5 * this.m_impulse, l.y += h.m_invMass * -a.x * .5 * this.m_impulse
        }
    } else this.m_impulse = 0
}, box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(t) {
    for (var e = 0, i = 0, o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            r = t.velocities[n.m_islandIndex].v;
        e += (h = this.m_deltas[o]).GetLengthSquared() / n.GetMass(), i += box2d.b2CrossVV(r, h)
    }
    var a = -2 * i / e;
    this.m_impulse += a;
    for (o = 0, s = this.m_bodies.length; o < s; ++o) {
        n = this.m_bodies[o], r = t.velocities[n.m_islandIndex].v;
        var h = this.m_deltas[o];
        r.x += n.m_invMass * h.y * .5 * a, r.y += n.m_invMass * -h.x * .5 * a
    }
}, box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(t) {
    for (var e = 0, i = 0, o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            r = this.m_bodies[(o + 1) % s],
            a = t.positions[n.m_islandIndex].c,
            h = t.positions[r.m_islandIndex].c,
            l = (u = box2d.b2SubVV(h, a, this.m_delta)).GetLength();
        l < box2d.b2_epsilon && (l = 1), this.m_normals[o].x = u.y / l, this.m_normals[o].y = -u.x / l, e += l, i += box2d.b2CrossVV(a, h)
    }
    i *= .5;
    var d = .5 * (this.m_targetArea - i) / e,
        c = !0;
    for (o = 0, s = this.m_bodies.length; o < s; ++o) {
        n = this.m_bodies[o], a = t.positions[n.m_islandIndex].c;
        var u, p = (o + 1) % s;
        (u = box2d.b2AddVV(this.m_normals[o], this.m_normals[p], this.m_delta)).SelfMul(d);
        var b = u.GetLengthSquared();
        b > box2d.b2Sq(box2d.b2_maxLinearCorrection) && u.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(b)), b > box2d.b2Sq(box2d.b2_linearSlop) && (c = !1), a.x += u.x, a.y += u.y
    }
    return c
}, goog.provide("box2d.b2BuoyancyController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), goog.require("box2d.b2WorldCallbacks"), box2d.b2BuoyancyController = function() {
    goog.base(this), this.normal = new box2d.b2Vec2(0, 1), this.velocity = new box2d.b2Vec2(0, 0), this.gravity = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller), box2d.b2BuoyancyController.prototype.normal = null, box2d.b2BuoyancyController.prototype.offset = 0, box2d.b2BuoyancyController.prototype.density = 0, box2d.b2BuoyancyController.prototype.velocity = null, box2d.b2BuoyancyController.prototype.linearDrag = 0, box2d.b2BuoyancyController.prototype.angularDrag = 0, box2d.b2BuoyancyController.prototype.useDensity = !1, box2d.b2BuoyancyController.prototype.useWorldGravity = !0, box2d.b2BuoyancyController.prototype.gravity = null, box2d.b2BuoyancyController.prototype.Step = function() {
    if (this.m_bodyList) {
        this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity());
        for (var t = this.m_bodyList; t; t = t.nextBody) {
            var e = t.body;
            if (!1 !== e.IsAwake()) {
                for (var i = new box2d.b2Vec2, o = new box2d.b2Vec2, s = 0, n = 0, r = e.GetFixtureList(); r; r = r.m_next) {
                    var a = new box2d.b2Vec2,
                        h = r.GetShape().ComputeSubmergedArea(this.normal, this.offset, e.GetTransform(), a);
                    s += h, i.x += h * a.x, i.y += h * a.y;
                    var l;
                    n += h * (l = this.useDensity ? r.GetDensity() : 1), o.x += h * a.x * l, o.y += h * a.y * l
                }
                if (i.x /= s, i.y /= s, o.x /= n, o.y /= n, !(s < box2d.b2_epsilon)) {
                    var d = box2d.b2NegV(this.gravity, new box2d.b2Vec2);
                    d.SelfMul(this.density * s), e.ApplyForce(d, o);
                    var c = e.GetLinearVelocityFromWorldPoint(i, new box2d.b2Vec2);
                    c.SelfSub(this.velocity), c.SelfMul(-this.linearDrag * s), e.ApplyForce(c, i), e.ApplyTorque(-e.GetInertia() / e.GetMass() * s * e.GetAngularVelocity() * this.angularDrag)
                }
            }
        }
    }
}, box2d.b2BuoyancyController.prototype.Draw = function(t) {
    var e = new box2d.b2Vec2,
        i = new box2d.b2Vec2;
    e.x = this.normal.x * this.offset + 100 * this.normal.y, e.y = this.normal.y * this.offset - 100 * this.normal.x, i.x = this.normal.x * this.offset - 100 * this.normal.y, i.y = this.normal.y * this.offset + 100 * this.normal.x;
    var o = new box2d.b2Color(0, 0, .8);
    t.DrawSegment(e, i, o)
}, goog.provide("box2d.b2TensorDampingController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2TensorDampingController = function() {
    goog.base(this), this.T = new box2d.b2Mat22, this.maxTimestep = 0
}, goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller), box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22, box2d.b2TensorDampingController.prototype.maxTimestep = 0, box2d.b2TensorDampingController.prototype.Step = function(t) {
    var e = t.dt;
    if (!(e <= box2d.b2_epsilon)) {
        e > this.maxTimestep && 0 < this.maxTimestep && (e = this.maxTimestep);
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var o = i.body;
            if (o.IsAwake()) {
                var s = o.GetWorldVector(box2d.b2MulMV(this.T, o.GetLocalVector(o.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), box2d.b2MulSV(e, s, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1))
            }
        }
    }
}, box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2, box2d.b2TensorDampingController.prototype.SetAxisAligned = function(t, e) {
    this.T.ex.x = -t, this.T.ex.y = 0, this.T.ey.x = 0, this.T.ey.y = -e, this.maxTimestep = 0 < t || 0 < e ? 1 / box2d.b2Max(t, e) : 0
}, goog.provide("box2d.b2DistanceJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2DistanceJointDef = function() {
    goog.base(this, box2d.b2JointType.e_distanceJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef), box2d.b2DistanceJointDef.prototype.localAnchorA = null, box2d.b2DistanceJointDef.prototype.localAnchorB = null, box2d.b2DistanceJointDef.prototype.length = 1, box2d.b2DistanceJointDef.prototype.frequencyHz = 0, box2d.b2DistanceJointDef.prototype.dampingRatio = 0, box2d.b2DistanceJointDef.prototype.Initialize = function(t, e, i, o) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(o, this.localAnchorB), this.length = box2d.b2DistanceVV(i, o), this.frequencyHz = 0, this.dampingRatio = 0
}, box2d.b2DistanceJoint = function(t) {
    goog.base(this, t), this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_length = t.length
}, goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint), box2d.b2DistanceJoint.prototype.m_frequencyHz = 0, box2d.b2DistanceJoint.prototype.m_dampingRatio = 0, box2d.b2DistanceJoint.prototype.m_bias = 0, box2d.b2DistanceJoint.prototype.m_localAnchorA = null, box2d.b2DistanceJoint.prototype.m_localAnchorB = null, box2d.b2DistanceJoint.prototype.m_gamma = 0, box2d.b2DistanceJoint.prototype.m_impulse = 0, box2d.b2DistanceJoint.prototype.m_length = 0, box2d.b2DistanceJoint.prototype.m_indexA = 0, box2d.b2DistanceJoint.prototype.m_indexB = 0, box2d.b2DistanceJoint.prototype.m_u = null, box2d.b2DistanceJoint.prototype.m_rA = null, box2d.b2DistanceJoint.prototype.m_rB = null, box2d.b2DistanceJoint.prototype.m_localCenterA = null, box2d.b2DistanceJoint.prototype.m_localCenterB = null, box2d.b2DistanceJoint.prototype.m_invMassA = 0, box2d.b2DistanceJoint.prototype.m_invMassB = 0, box2d.b2DistanceJoint.prototype.m_invIA = 0, box2d.b2DistanceJoint.prototype.m_invIB = 0, box2d.b2DistanceJoint.prototype.m_mass = 0, box2d.b2DistanceJoint.prototype.m_qA = null, box2d.b2DistanceJoint.prototype.m_qB = null, box2d.b2DistanceJoint.prototype.m_lalcA = null, box2d.b2DistanceJoint.prototype.m_lalcB = null, box2d.b2DistanceJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2DistanceJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2DistanceJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y)
}, box2d.b2DistanceJoint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2DistanceJoint.prototype.SetLength = function(t) {
    this.m_length = t
}, box2d.b2DistanceJoint.prototype.GetLength = function() {
    return this.m_length
}, box2d.b2DistanceJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2DistanceJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2DistanceJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2DistanceJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2DistanceJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.length = %.15f;\n", this.m_length), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_u.x = n.x + this.m_rB.x - e.x - this.m_rA.x, this.m_u.y = n.y + this.m_rB.y - e.y - this.m_rA.y;
    var c = this.m_u.GetLength();
    c > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / c) : this.m_u.SetZero();
    var u = box2d.b2CrossVV(this.m_rA, this.m_u),
        p = box2d.b2CrossVV(this.m_rB, this.m_u),
        b = this.m_invMassA + this.m_invIA * u * u + this.m_invMassB + this.m_invIB * p * p;
    if (this.m_mass = 0 !== b ? 1 / b : 0, 0 < this.m_frequencyHz) {
        var m = c - this.m_length,
            y = 2 * box2d.b2_pi * this.m_frequencyHz,
            f = 2 * this.m_mass * this.m_dampingRatio * y,
            x = this.m_mass * y * y,
            g = t.step.dt;
        this.m_gamma = g * (f + g * x), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = m * g * x * this.m_gamma, b += this.m_gamma, this.m_mass = 0 !== b ? 1 / b : 0
    } else this.m_gamma = 0, this.m_bias = 0;
    if (t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var _ = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, _), s -= this.m_invIA * box2d.b2CrossVV(this.m_rA, _), a.SelfMulAdd(this.m_invMassB, _), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, _)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0)),
        h = -this.m_mass * (a + this.m_bias + this.m_gamma * this.m_impulse);
    this.m_impulse += h;
    var l = box2d.b2MulSV(h, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, l), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, l), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, l), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(t) {
    if (0 < this.m_frequencyHz) return !0;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = (this.m_qA.SetAngleRadians(i), this.m_qB.SetAngleRadians(s), box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA)),
        r = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB),
        a = this.m_u;
    a.x = o.x + r.x - e.x - n.x, a.y = o.y + r.y - e.y - n.y;
    var h = this.m_u.Normalize() - this.m_length;
    h = box2d.b2Clamp(h, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection);
    var l = -this.m_mass * h,
        d = box2d.b2MulSV(l, a, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);
    return e.SelfMulSub(this.m_invMassA, d), i -= this.m_invIA * box2d.b2CrossVV(n, d), o.SelfMulAdd(this.m_invMassB, d), s += this.m_invIB * box2d.b2CrossVV(r, d), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, box2d.b2Abs(h) < box2d.b2_linearSlop
}, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2FrictionJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2FrictionJointDef = function() {
    goog.base(this, box2d.b2JointType.e_frictionJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef), box2d.b2FrictionJointDef.prototype.localAnchorA = null, box2d.b2FrictionJointDef.prototype.localAnchorB = null, box2d.b2FrictionJointDef.prototype.maxForce = 0, box2d.b2FrictionJointDef.prototype.maxTorque = 0, box2d.b2FrictionJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB)
}, box2d.b2FrictionJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_linearImpulse = (new box2d.b2Vec2).SetZero(), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_linearMass = (new box2d.b2Mat22).SetZero(), this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22
}, goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint), box2d.b2FrictionJoint.prototype.m_localAnchorA = null, box2d.b2FrictionJoint.prototype.m_localAnchorB = null, box2d.b2FrictionJoint.prototype.m_linearImpulse = null, box2d.b2FrictionJoint.prototype.m_angularImpulse = 0, box2d.b2FrictionJoint.prototype.m_maxForce = 0, box2d.b2FrictionJoint.prototype.m_maxTorque = 0, box2d.b2FrictionJoint.prototype.m_indexA = 0, box2d.b2FrictionJoint.prototype.m_indexB = 0, box2d.b2FrictionJoint.prototype.m_rA = null, box2d.b2FrictionJoint.prototype.m_rB = null, box2d.b2FrictionJoint.prototype.m_localCenterA = null, box2d.b2FrictionJoint.prototype.m_localCenterB = null, box2d.b2FrictionJoint.prototype.m_invMassA = 0, box2d.b2FrictionJoint.prototype.m_invMassB = 0, box2d.b2FrictionJoint.prototype.m_invIA = 0, box2d.b2FrictionJoint.prototype.m_invIB = 0, box2d.b2FrictionJoint.prototype.m_linearMass = null, box2d.b2FrictionJoint.prototype.m_angularMass = 0, box2d.b2FrictionJoint.prototype.m_qA = null, box2d.b2FrictionJoint.prototype.m_qB = null, box2d.b2FrictionJoint.prototype.m_lalcA = null, box2d.b2FrictionJoint.prototype.m_lalcB = null, box2d.b2FrictionJoint.prototype.m_K = null, box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var l = box2d.b2MulRV(a, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var d = box2d.b2MulRV(h, this.m_lalcB, this.m_rB),
        c = this.m_invMassA,
        u = this.m_invMassB,
        p = this.m_invIA,
        b = this.m_invIB,
        m = this.m_K;
    if (m.ex.x = c + u + p * l.y * l.y + b * d.y * d.y, m.ex.y = -p * l.x * l.y - b * d.x * d.y, m.ey.x = m.ex.y, m.ey.y = c + u + p * l.x * l.x + b * d.x * d.x, m.GetInverse(this.m_linearMass), this.m_angularMass = p + b, 0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass), t.step.warmStarting) {
        this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
        var y = this.m_linearImpulse;
        i.SelfMulSub(c, y), o -= p * (box2d.b2CrossVV(this.m_rA, y) + this.m_angularImpulse), n.SelfMulAdd(u, y), r += b * (box2d.b2CrossVV(this.m_rB, y) + this.m_angularImpulse)
    } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        d = s - i,
        c = -this.m_angularMass * d,
        u = this.m_angularImpulse,
        p = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + c, -p, p), i -= a * (c = this.m_angularImpulse - u), s += h * c;
    d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);
    var b = box2d.b2MulMV(this.m_linearMass, d, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg(),
        m = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(b);
    p = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > p * p && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(p)), box2d.b2SubVV(this.m_linearImpulse, m, b), e.SelfMulSub(n, b), i -= a * box2d.b2CrossVV(this.m_rA, b), o.SelfMulAdd(r, b), s += h * box2d.b2CrossVV(this.m_rB, b), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function() {
    return !0
}, box2d.b2FrictionJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2FrictionJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2FrictionJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y)
}, box2d.b2FrictionJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_angularImpulse
}, box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2FrictionJoint.prototype.SetMaxForce = function(t) {
    this.m_maxForce = t
}, box2d.b2FrictionJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2FrictionJoint.prototype.SetMaxTorque = function(t) {
    this.m_maxTorque = t
}, box2d.b2FrictionJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
}, box2d.b2FrictionJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce), box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2MouseJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2MouseJointDef = function() {
    goog.base(this, box2d.b2JointType.e_mouseJoint), this.target = new box2d.b2Vec2
}, goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef), box2d.b2MouseJointDef.prototype.target = null, box2d.b2MouseJointDef.prototype.maxForce = 0, box2d.b2MouseJointDef.prototype.frequencyHz = 5, box2d.b2MouseJointDef.prototype.dampingRatio = .7, box2d.b2MouseJoint = function(t) {
    goog.base(this, t), this.m_localAnchorB = new box2d.b2Vec2, this.m_targetA = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat22, this.m_C = new box2d.b2Vec2, this.m_qB = new box2d.b2Rot, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, box2d.ENABLE_ASSERTS && box2d.b2Assert(t.target.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.maxForce) && 0 <= t.maxForce), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.frequencyHz) && 0 <= t.frequencyHz), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.dampingRatio) && 0 <= t.dampingRatio), this.m_targetA.Copy(t.target), box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB), this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0
}, goog.inherits(box2d.b2MouseJoint, box2d.b2Joint), box2d.b2MouseJoint.prototype.m_localAnchorB = null, box2d.b2MouseJoint.prototype.m_targetA = null, box2d.b2MouseJoint.prototype.m_frequencyHz = 0, box2d.b2MouseJoint.prototype.m_dampingRatio = 0, box2d.b2MouseJoint.prototype.m_beta = 0, box2d.b2MouseJoint.prototype.m_impulse = null, box2d.b2MouseJoint.prototype.m_maxForce = 0, box2d.b2MouseJoint.prototype.m_gamma = 0, box2d.b2MouseJoint.prototype.m_indexA = 0, box2d.b2MouseJoint.prototype.m_indexB = 0, box2d.b2MouseJoint.prototype.m_rB = null, box2d.b2MouseJoint.prototype.m_localCenterB = null, box2d.b2MouseJoint.prototype.m_invMassB = 0, box2d.b2MouseJoint.prototype.m_invIB = 0, box2d.b2MouseJoint.prototype.m_mass = null, box2d.b2MouseJoint.prototype.m_C = null, box2d.b2MouseJoint.prototype.m_qB = null, box2d.b2MouseJoint.prototype.m_lalcB = null, box2d.b2MouseJoint.prototype.m_K = null, box2d.b2MouseJoint.prototype.SetTarget = function(t) {
    !1 === this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_targetA.Copy(t)
}, box2d.b2MouseJoint.prototype.GetTarget = function(t) {
    return t.Copy(this.m_targetA)
}, box2d.b2MouseJoint.prototype.SetMaxForce = function(t) {
    this.m_maxForce = t
}, box2d.b2MouseJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2MouseJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2MouseJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2MouseJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2MouseJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexB].c,
        i = t.positions[this.m_indexB].a,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_qB.SetAngleRadians(i),
        r = this.m_bodyB.GetMass(),
        a = 2 * box2d.b2_pi * this.m_frequencyHz,
        h = 2 * r * this.m_dampingRatio * a,
        l = r * a * a,
        d = t.step.dt;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(h + d * l > box2d.b2_epsilon), this.m_gamma = d * (h + d * l), 0 !== this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_beta = d * l * this.m_gamma, box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(n, this.m_lalcB, this.m_rB);
    var c = this.m_K;
    c.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma, c.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y, c.ey.x = c.ex.y, c.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma, c.GetInverse(this.m_mass), this.m_C.x = e.x + this.m_rB.x - this.m_targetA.x, this.m_C.y = e.y + this.m_rB.y - this.m_targetA.y, this.m_C.SelfMul(this.m_beta), s *= .98, t.step.warmStarting ? (this.m_impulse.SelfMul(t.step.dtRatio), o.x += this.m_invMassB * this.m_impulse.x, o.y += this.m_invMassB * this.m_impulse.y, s += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero(), t.velocities[this.m_indexB].w = s
}, box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexB].v,
        i = t.velocities[this.m_indexB].w,
        o = box2d.b2AddVCrossSV(e, i, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot),
        s = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(o, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse),
        n = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(s);
    var r = t.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > r * r && this.m_impulse.SelfMul(r / this.m_impulse.GetLength()), box2d.b2SubVV(this.m_impulse, n, s), e.SelfMulAdd(this.m_invMassB, s), i += this.m_invIB * box2d.b2CrossVV(this.m_rB, s), t.velocities[this.m_indexB].w = i
}, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolvePositionConstraints = function() {
    return !0
}, box2d.b2MouseJoint.prototype.GetAnchorA = function(t) {
    return t.Copy(this.m_targetA)
}, box2d.b2MouseJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2MouseJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t, this.m_impulse, e)
}, box2d.b2MouseJoint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2MouseJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Mouse joint dumping is not supported.\n")
}, box2d.b2MouseJoint.prototype.ShiftOrigin = function(t) {
    this.m_targetA.SelfSub(t)
}, goog.provide("box2d.b2ConstantForceController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantForceController = function() {
    goog.base(this), this.F = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.F = null, box2d.b2ConstantForceController.prototype.Step = function() {
    for (var t = this.m_bodyList; t; t = t.nextBody) {
        var e = t.body;
        e.IsAwake() && e.ApplyForce(this.F, e.GetWorldCenter())
    }
}, goog.provide("box2d.b2PulleyJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2_minPulleyLength = 2, box2d.b2PulleyJointDef = function() {
    goog.base(this, box2d.b2JointType.e_pulleyJoint), this.collideConnected = !0, this.groundAnchorA = new box2d.b2Vec2(-1, 1), this.groundAnchorB = new box2d.b2Vec2(1, 1), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef), box2d.b2PulleyJointDef.prototype.groundAnchorA = null, box2d.b2PulleyJointDef.prototype.groundAnchorB = null, box2d.b2PulleyJointDef.prototype.localAnchorA = null, box2d.b2PulleyJointDef.prototype.localAnchorB = null, box2d.b2PulleyJointDef.prototype.lengthA = 0, box2d.b2PulleyJointDef.prototype.lengthB = 0, box2d.b2PulleyJointDef.prototype.ratio = 1, box2d.b2PulleyJointDef.prototype.Initialize = function(t, e, i, o, s, n, r) {
    this.bodyA = t, this.bodyB = e, this.groundAnchorA.Copy(i), this.groundAnchorB.Copy(o), this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(n, this.localAnchorB), this.lengthA = box2d.b2DistanceVV(s, i), this.lengthB = box2d.b2DistanceVV(n, o), this.ratio = r, box2d.ENABLE_ASSERTS && box2d.b2Assert(this.ratio > box2d.b2_epsilon)
}, box2d.b2PulleyJoint = function(t) {
    goog.base(this, t), this.m_groundAnchorA = new box2d.b2Vec2, this.m_groundAnchorB = new box2d.b2Vec2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_uA = new box2d.b2Vec2, this.m_uB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_groundAnchorA.Copy(t.groundAnchorA), this.m_groundAnchorB.Copy(t.groundAnchorB), this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_lengthA = t.lengthA, this.m_lengthB = t.lengthB, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 !== t.ratio), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_impulse = 0
}, goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint), box2d.b2PulleyJoint.prototype.m_groundAnchorA = null, box2d.b2PulleyJoint.prototype.m_groundAnchorB = null, box2d.b2PulleyJoint.prototype.m_lengthA = 0, box2d.b2PulleyJoint.prototype.m_lengthB = 0, box2d.b2PulleyJoint.prototype.m_localAnchorA = null, box2d.b2PulleyJoint.prototype.m_localAnchorB = null, box2d.b2PulleyJoint.prototype.m_constant = 0, box2d.b2PulleyJoint.prototype.m_ratio = 0, box2d.b2PulleyJoint.prototype.m_impulse = 0, box2d.b2PulleyJoint.prototype.m_indexA = 0, box2d.b2PulleyJoint.prototype.m_indexB = 0, box2d.b2PulleyJoint.prototype.m_uA = null, box2d.b2PulleyJoint.prototype.m_uB = null, box2d.b2PulleyJoint.prototype.m_rA = null, box2d.b2PulleyJoint.prototype.m_rB = null, box2d.b2PulleyJoint.prototype.m_localCenterA = null, box2d.b2PulleyJoint.prototype.m_localCenterB = null, box2d.b2PulleyJoint.prototype.m_invMassA = 0, box2d.b2PulleyJoint.prototype.m_invMassB = 0, box2d.b2PulleyJoint.prototype.m_invIA = 0, box2d.b2PulleyJoint.prototype.m_invIB = 0, box2d.b2PulleyJoint.prototype.m_mass = 0, box2d.b2PulleyJoint.prototype.m_qA = null, box2d.b2PulleyJoint.prototype.m_qB = null, box2d.b2PulleyJoint.prototype.m_lalcA = null, box2d.b2PulleyJoint.prototype.m_lalcB = null, box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA), this.m_uB.Copy(n).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
    var c = this.m_uA.GetLength(),
        u = this.m_uB.GetLength();
    c > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / c) : this.m_uA.SetZero(), u > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / u) : this.m_uB.SetZero();
    var p = box2d.b2CrossVV(this.m_rA, this.m_uA),
        b = box2d.b2CrossVV(this.m_rB, this.m_uB),
        m = this.m_invMassA + this.m_invIA * p * p,
        y = this.m_invMassB + this.m_invIB * b * b;
    if (this.m_mass = m + this.m_ratio * this.m_ratio * y, 0 < this.m_mass && (this.m_mass = 1 / this.m_mass), t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var f = box2d.b2MulSV(-this.m_impulse, this.m_uA, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA),
            x = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB);
        o.SelfMulAdd(this.m_invMassA, f), s += this.m_invIA * box2d.b2CrossVV(this.m_rA, f), a.SelfMulAdd(this.m_invMassB, x), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, x)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = -box2d.b2DotVV(this.m_uA, n) - this.m_ratio * box2d.b2DotVV(this.m_uB, r),
        h = -this.m_mass * a;
    this.m_impulse += h;
    var l = box2d.b2MulSV(-h, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA),
        d = box2d.b2MulSV(-this.m_ratio * h, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    e.SelfMulAdd(this.m_invMassA, l), i += this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, d), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, d), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        l = this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),
        d = this.m_uB.Copy(o).SelfAdd(h).SelfSub(this.m_groundAnchorB),
        c = l.GetLength(),
        u = d.GetLength();
    c > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / c) : l.SetZero(), u > 10 * box2d.b2_linearSlop ? d.SelfMul(1 / u) : d.SetZero();
    var p = box2d.b2CrossVV(a, l),
        b = box2d.b2CrossVV(h, d),
        m = this.m_invMassA + this.m_invIA * p * p,
        y = this.m_invMassB + this.m_invIB * b * b,
        f = m + this.m_ratio * this.m_ratio * y;
    0 < f && (f = 1 / f);
    var x = this.m_constant - c - this.m_ratio * u,
        g = box2d.b2Abs(x),
        _ = -f * x,
        v = box2d.b2MulSV(-_, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA),
        S = box2d.b2MulSV(-this.m_ratio * _, d, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);
    return e.SelfMulAdd(this.m_invMassA, v), i += this.m_invIA * box2d.b2CrossVV(a, v), o.SelfMulAdd(this.m_invMassB, S), s += this.m_invIB * box2d.b2CrossVV(h, S), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, g < box2d.b2_linearSlop
}, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2PulleyJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2PulleyJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse * this.m_uB.x, t * this.m_impulse * this.m_uB.y)
}, box2d.b2PulleyJoint.prototype.GetReactionTorque = function() {
    return 0
}, box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(t) {
    return t.Copy(this.m_groundAnchorA)
}, box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(t) {
    return t.Copy(this.m_groundAnchorB)
}, box2d.b2PulleyJoint.prototype.GetLengthA = function() {
    return this.m_lengthA
}, box2d.b2PulleyJoint.prototype.GetLengthB = function() {
    return this.m_lengthB
}, box2d.b2PulleyJoint.prototype.GetRatio = function() {
    return this.m_ratio
}, box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() {
    var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p),
        e = this.m_groundAnchorA;
    return box2d.b2DistanceVV(t, e)
}, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() {
    var t = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p),
        e = this.m_groundAnchorB;
    return box2d.b2DistanceVV(t, e)
}, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y), box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n", this.m_groundAnchorB.x, this.m_groundAnchorB.y), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA), box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB), box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, box2d.b2PulleyJoint.prototype.ShiftOrigin = function(t) {
    this.m_groundAnchorA.SelfSub(t), this.m_groundAnchorB.SelfSub(t)
}, goog.provide("box2d.b2CircleShape"), goog.require("box2d.b2Shape"), box2d.b2CircleShape = function(t) {
    goog.base(this, box2d.b2ShapeType.e_circleShape, t || 0), this.m_p = new box2d.b2Vec2
}, goog.inherits(box2d.b2CircleShape, box2d.b2Shape), box2d.b2CircleShape.prototype.m_p = null, box2d.b2CircleShape.prototype.Clone = function() {
    return (new box2d.b2CircleShape).Copy(this)
}, box2d.b2CircleShape.prototype.Copy = function(t) {
    return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2CircleShape), this.m_p.Copy(t.m_p), this
}, box2d.b2CircleShape.prototype.GetChildCount = function() {
    return 1
}, box2d.b2CircleShape.prototype.TestPoint = function(t, e) {
    var i = box2d.b2MulXV(t, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center),
        o = box2d.b2SubVV(e, i, box2d.b2CircleShape.prototype.TestPoint.s_d);
    return box2d.b2DotVV(o, o) <= box2d.b2Sq(this.m_radius)
}, box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2, box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast = function(t, e, i) {
    var o = box2d.b2MulXV(i, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position),
        s = box2d.b2SubVV(e.p1, o, box2d.b2CircleShape.prototype.RayCast.s_s),
        n = box2d.b2DotVV(s, s) - box2d.b2Sq(this.m_radius),
        r = box2d.b2SubVV(e.p2, e.p1, box2d.b2CircleShape.prototype.RayCast.s_r),
        a = box2d.b2DotVV(s, r),
        h = box2d.b2DotVV(r, r),
        l = a * a - h * n;
    if (l < 0 || h < box2d.b2_epsilon) return !1;
    var d = -(a + box2d.b2Sqrt(l));
    return 0 <= d && d <= e.maxFraction * h && (d /= h, t.fraction = d, box2d.b2AddVMulSV(s, d, r, t.normal).SelfNormalize(), !0)
}, box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeAABB = function(t, e) {
    var i = box2d.b2MulXV(e, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
    t.lowerBound.SetXY(i.x - this.m_radius, i.y - this.m_radius), t.upperBound.SetXY(i.x + this.m_radius, i.y + this.m_radius)
}, box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeMass = function(t, e) {
    var i = box2d.b2Sq(this.m_radius);
    t.mass = e * box2d.b2_pi * i, t.center.Copy(this.m_p), t.I = t.mass * (.5 * i + box2d.b2DotVV(this.m_p, this.m_p))
}, box2d.b2CircleShape.prototype.SetupDistanceProxy = function(t) {
    t.m_vertices = new Array(1, !0), t.m_vertices[0] = this.m_p, t.m_count = 1, t.m_radius = this.m_radius
}, box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    var s = box2d.b2MulXV(i, this.m_p, new box2d.b2Vec2),
        n = -(box2d.b2DotVV(t, s) - e);
    if (n < -this.m_radius + box2d.b2_epsilon) return 0;
    if (n > this.m_radius) return o.Copy(s), box2d.b2_pi * this.m_radius * this.m_radius;
    var r = this.m_radius * this.m_radius,
        a = n * n,
        h = r * (box2d.b2Asin(n / this.m_radius) + box2d.b2_pi / 2) + n * box2d.b2Sqrt(r - a),
        l = -2 / 3 * box2d.b2Pow(r - a, 1.5) / h;
    return o.x = s.x + t.x * l, o.y = s.y + t.y * l, h
}, box2d.b2CircleShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y)
}, goog.provide("box2d.b2Rope"), goog.require("box2d.b2Math"), goog.require("box2d.b2Draw"), box2d.b2RopeDef = function() {
    this.vertices = new Array, this.masses = new Array, this.gravity = new box2d.b2Vec2
}, box2d.b2RopeDef.prototype.vertices = null, box2d.b2RopeDef.prototype.count = 0, box2d.b2RopeDef.prototype.masses = null, box2d.b2RopeDef.prototype.gravity = null, box2d.b2RopeDef.prototype.damping = .1, box2d.b2RopeDef.prototype.k2 = .9, box2d.b2RopeDef.prototype.k3 = .1, box2d.b2Rope = function() {
    this.m_gravity = new box2d.b2Vec2
}, box2d.b2Rope.prototype.m_count = 0, box2d.b2Rope.prototype.m_ps = null, box2d.b2Rope.prototype.m_p0s = null, box2d.b2Rope.prototype.m_vs = null, box2d.b2Rope.prototype.m_ims = null, box2d.b2Rope.prototype.m_Ls = null, box2d.b2Rope.prototype.m_as = null, box2d.b2Rope.prototype.m_gravity = null, box2d.b2Rope.prototype.m_damping = 0, box2d.b2Rope.prototype.m_k2 = 1, box2d.b2Rope.prototype.m_k3 = .1, box2d.b2Rope.prototype.GetVertexCount = function() {
    return this.m_count
}, box2d.b2Rope.prototype.GetVertices = function() {
    return this.m_ps
}, box2d.b2Rope.prototype.Initialize = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= t.count), this.m_count = t.count, this.m_ps = box2d.b2Vec2.MakeArray(this.m_count), this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count), this.m_vs = box2d.b2Vec2.MakeArray(this.m_count), this.m_ims = box2d.b2MakeNumberArray(this.m_count);
    for (var e = 0; e < this.m_count; ++e) {
        this.m_ps[e].Copy(t.vertices[e]), this.m_p0s[e].Copy(t.vertices[e]), this.m_vs[e].SetZero();
        var i = t.masses[e];
        this.m_ims[e] = 0 < i ? 1 / i : 0
    }
    var o = this.m_count - 1,
        s = this.m_count - 2;
    this.m_Ls = box2d.b2MakeNumberArray(o), this.m_as = box2d.b2MakeNumberArray(s);
    for (e = 0; e < o; ++e) {
        var n = this.m_ps[e],
            r = this.m_ps[e + 1];
        this.m_Ls[e] = box2d.b2DistanceVV(n, r)
    }
    for (e = 0; e < s; ++e) {
        n = this.m_ps[e], r = this.m_ps[e + 1];
        var a = this.m_ps[e + 2],
            h = box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0),
            l = box2d.b2SubVV(a, r, box2d.b2Vec2.s_t1),
            d = box2d.b2CrossVV(h, l),
            c = box2d.b2DotVV(h, l);
        this.m_as[e] = box2d.b2Atan2(d, c)
    }
    this.m_gravity.Copy(t.gravity), this.m_damping = t.damping, this.m_k2 = t.k2, this.m_k3 = t.k3
}, box2d.b2Rope.prototype.Step = function(t, e) {
    if (0 !== t) {
        for (var i = Math.exp(-t * this.m_damping), o = 0; o < this.m_count; ++o) this.m_p0s[o].Copy(this.m_ps[o]), 0 < this.m_ims[o] && this.m_vs[o].SelfMulAdd(t, this.m_gravity), this.m_vs[o].SelfMul(i), this.m_ps[o].SelfMulAdd(t, this.m_vs[o]);
        for (o = 0; o < e; ++o) this.SolveC2(), this.SolveC3(), this.SolveC2();
        var s = 1 / t;
        for (o = 0; o < this.m_count; ++o) box2d.b2MulSV(s, box2d.b2SubVV(this.m_ps[o], this.m_p0s[o], box2d.b2Vec2.s_t0), this.m_vs[o])
    }
}, box2d.b2Rope.prototype.SolveC2 = function() {
    for (var t = this.m_count - 1, e = 0; e < t; ++e) {
        var i = this.m_ps[e],
            o = this.m_ps[e + 1],
            s = box2d.b2SubVV(o, i, box2d.b2Rope.s_d),
            n = s.Normalize(),
            r = this.m_ims[e],
            a = this.m_ims[e + 1];
        if (r + a !== 0) {
            var h = r / (r + a),
                l = a / (r + a);
            i.SelfMulSub(this.m_k2 * h * (this.m_Ls[e] - n), s), o.SelfMulAdd(this.m_k2 * l * (this.m_Ls[e] - n), s)
        }
    }
}, box2d.b2Rope.s_d = new box2d.b2Vec2, box2d.b2Rope.prototype.SetAngleRadians = function(t) {
    for (var e = this.m_count - 2, i = 0; i < e; ++i) this.m_as[i] = t
}, box2d.b2Rope.prototype.SolveC3 = function() {
    for (var t = this.m_count - 2, e = 0; e < t; ++e) {
        var i = this.m_ps[e],
            o = this.m_ps[e + 1],
            s = this.m_ps[e + 2],
            n = this.m_ims[e],
            r = this.m_ims[e + 1],
            a = this.m_ims[e + 2],
            h = box2d.b2SubVV(o, i, box2d.b2Rope.s_d1),
            l = box2d.b2SubVV(s, o, box2d.b2Rope.s_d2),
            d = h.GetLengthSquared(),
            c = l.GetLengthSquared();
        if (d * c != 0) {
            var u = box2d.b2CrossVV(h, l),
                p = box2d.b2DotVV(h, l),
                b = box2d.b2Atan2(u, p),
                m = box2d.b2MulSV(-1 / d, h.SelfSkew(), box2d.b2Rope.s_Jd1),
                y = box2d.b2MulSV(1 / c, l.SelfSkew(), box2d.b2Rope.s_Jd2),
                f = box2d.b2NegV(m, box2d.b2Rope.s_J1),
                x = box2d.b2SubVV(m, y, box2d.b2Rope.s_J2),
                g = y,
                _ = n * box2d.b2DotVV(f, f) + r * box2d.b2DotVV(x, x) + a * box2d.b2DotVV(g, g);
            if (0 !== _) {
                _ = 1 / _;
                for (var v = b - this.m_as[e]; v > box2d.b2_pi;) v = (b -= 2 * box2d.b2_pi) - this.m_as[e];
                for (; v < -box2d.b2_pi;) v = (b += 2 * box2d.b2_pi) - this.m_as[e];
                var S = -this.m_k3 * _ * v;
                i.SelfMulAdd(n * S, f), o.SelfMulAdd(r * S, x), s.SelfMulAdd(a * S, g)
            }
        }
    }
}, box2d.b2Rope.s_d1 = new box2d.b2Vec2, box2d.b2Rope.s_d2 = new box2d.b2Vec2, box2d.b2Rope.s_Jd1 = new box2d.b2Vec2, box2d.b2Rope.s_Jd2 = new box2d.b2Vec2, box2d.b2Rope.s_J1 = new box2d.b2Vec2, box2d.b2Rope.s_J2 = new box2d.b2Vec2, box2d.b2Rope.prototype.Draw = function(t) {
    for (var e = new box2d.b2Color(.4, .5, .7), i = 0; i < this.m_count - 1; ++i) t.DrawSegment(this.m_ps[i], this.m_ps[i + 1], e)
}, goog.provide("box2d.b2WheelJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2WheelJointDef = function() {
    goog.base(this, box2d.b2JointType.e_wheelJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0), this.localAxisA = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef), box2d.b2WheelJointDef.prototype.localAnchorA = null, box2d.b2WheelJointDef.prototype.localAnchorB = null, box2d.b2WheelJointDef.prototype.localAxisA = null, box2d.b2WheelJointDef.prototype.enableMotor = !1, box2d.b2WheelJointDef.prototype.maxMotorTorque = 0, box2d.b2WheelJointDef.prototype.motorSpeed = 0, box2d.b2WheelJointDef.prototype.frequencyHz = 2, box2d.b2WheelJointDef.prototype.dampingRatio = .7, box2d.b2WheelJointDef.prototype.Initialize = function(t, e, i, o) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA)
}, box2d.b2WheelJoint = function(t) {
    goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_ax = new box2d.b2Vec2, this.m_ay = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_ax.SetZero(), this.m_ay.SetZero()
}, goog.inherits(box2d.b2WheelJoint, box2d.b2Joint), box2d.b2WheelJoint.prototype.m_frequencyHz = 0, box2d.b2WheelJoint.prototype.m_dampingRatio = 0, box2d.b2WheelJoint.prototype.m_localAnchorA = null, box2d.b2WheelJoint.prototype.m_localAnchorB = null, box2d.b2WheelJoint.prototype.m_localXAxisA = null, box2d.b2WheelJoint.prototype.m_localYAxisA = null, box2d.b2WheelJoint.prototype.m_impulse = 0, box2d.b2WheelJoint.prototype.m_motorImpulse = 0, box2d.b2WheelJoint.prototype.m_springImpulse = 0, box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0, box2d.b2WheelJoint.prototype.m_motorSpeed = 0, box2d.b2WheelJoint.prototype.m_enableMotor = !1, box2d.b2WheelJoint.prototype.m_indexA = 0, box2d.b2WheelJoint.prototype.m_indexB = 0, box2d.b2WheelJoint.prototype.m_localCenterA = null, box2d.b2WheelJoint.prototype.m_localCenterB = null, box2d.b2WheelJoint.prototype.m_invMassA = 0, box2d.b2WheelJoint.prototype.m_invMassB = 0, box2d.b2WheelJoint.prototype.m_invIA = 0, box2d.b2WheelJoint.prototype.m_invIB = 0, box2d.b2WheelJoint.prototype.m_ax = null, box2d.b2WheelJoint.prototype.m_ay = null, box2d.b2WheelJoint.prototype.m_sAx = 0, box2d.b2WheelJoint.prototype.m_sBx = 0, box2d.b2WheelJoint.prototype.m_sAy = 0, box2d.b2WheelJoint.prototype.m_sBy = 0, box2d.b2WheelJoint.prototype.m_mass = 0, box2d.b2WheelJoint.prototype.m_motorMass = 0, box2d.b2WheelJoint.prototype.m_springMass = 0, box2d.b2WheelJoint.prototype.m_bias = 0, box2d.b2WheelJoint.prototype.m_gamma = 0, box2d.b2WheelJoint.prototype.m_qA = null, box2d.b2WheelJoint.prototype.m_qB = null, box2d.b2WheelJoint.prototype.m_lalcA = null, box2d.b2WheelJoint.prototype.m_lalcB = null, box2d.b2WheelJoint.prototype.m_rA = null, box2d.b2WheelJoint.prototype.m_rB = null, box2d.b2WheelJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
}, box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
}, box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(t) {
    this.m_frequencyHz = t
}, box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
    return this.m_frequencyHz
}, box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = this.m_invMassA,
        i = this.m_invMassB,
        o = this.m_invIA,
        s = this.m_invIB,
        n = t.positions[this.m_indexA].c,
        r = t.positions[this.m_indexA].a,
        a = t.velocities[this.m_indexA].v,
        h = t.velocities[this.m_indexA].w,
        l = t.positions[this.m_indexB].c,
        d = t.positions[this.m_indexB].a,
        c = t.velocities[this.m_indexB].v,
        u = t.velocities[this.m_indexB].w,
        p = this.m_qA.SetAngleRadians(r),
        b = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var m = box2d.b2MulRV(p, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var y = box2d.b2MulRV(b, this.m_lalcB, this.m_rB),
        f = box2d.b2SubVV(box2d.b2AddVV(l, y, box2d.b2Vec2.s_t0), box2d.b2AddVV(n, m, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);
    if (box2d.b2MulRV(p, this.m_localYAxisA, this.m_ay), this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), this.m_ay), this.m_sBy = box2d.b2CrossVV(y, this.m_ay), this.m_mass = e + i + o * this.m_sAy * this.m_sAy + s * this.m_sBy * this.m_sBy, 0 < this.m_mass && (this.m_mass = 1 / this.m_mass), this.m_springMass = 0, this.m_bias = 0, (this.m_gamma = 0) < this.m_frequencyHz) {
        box2d.b2MulRV(p, this.m_localXAxisA, this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(y, this.m_ax);
        var x = e + i + o * this.m_sAx * this.m_sAx + s * this.m_sBx * this.m_sBx;
        if (0 < x) {
            this.m_springMass = 1 / x;
            var g = box2d.b2DotVV(f, this.m_ax),
                _ = 2 * box2d.b2_pi * this.m_frequencyHz,
                v = 2 * this.m_springMass * this.m_dampingRatio * _,
                S = this.m_springMass * _ * _,
                C = t.step.dt;
            this.m_gamma = C * (v + C * S), 0 < this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_bias = g * C * S * this.m_gamma, this.m_springMass = x + this.m_gamma, 0 < this.m_springMass && (this.m_springMass = 1 / this.m_springMass)
        }
    } else this.m_springImpulse = 0;
    if (this.m_enableMotor ? (this.m_motorMass = o + s, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass)) : (this.m_motorMass = 0, this.m_motorImpulse = 0), t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio, this.m_springImpulse *= t.step.dtRatio, this.m_motorImpulse *= t.step.dtRatio;
        var w = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
            A = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse,
            P = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
        a.SelfMulSub(this.m_invMassA, w), h -= this.m_invIA * A, c.SelfMulAdd(this.m_invMassB, w), u += this.m_invIB * P
    } else this.m_impulse = 0, this.m_springImpulse = 0, this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = h, t.velocities[this.m_indexB].w = u
}, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = this.m_invMassA,
        i = this.m_invMassB,
        o = this.m_invIA,
        s = this.m_invIB,
        n = t.velocities[this.m_indexA].v,
        r = t.velocities[this.m_indexA].w,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)) + this.m_sBx * h - this.m_sAx * r,
        d = -this.m_springMass * (l + this.m_bias + this.m_gamma * this.m_springImpulse);
    this.m_springImpulse += d;
    var c = box2d.b2MulSV(d, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
        u = d * this.m_sAx,
        p = d * this.m_sBx;
    n.SelfMulSub(e, c), r -= o * u, a.SelfMulAdd(i, c);
    l = (h += s * p) - r - this.m_motorSpeed, d = -this.m_motorMass * l;
    var b = this.m_motorImpulse,
        m = t.step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + d, -m, m), r -= o * (d = this.m_motorImpulse - b), h += s * d;
    l = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)) + this.m_sBy * h - this.m_sAy * r, d = -this.m_mass * l;
    this.m_impulse += d;
    c = box2d.b2MulSV(d, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P), u = d * this.m_sAy, p = d * this.m_sBy;
    n.SelfMulSub(e, c), r -= o * u, a.SelfMulAdd(i, c), h += s * p, t.velocities[this.m_indexA].w = r, t.velocities[this.m_indexB].w = h
}, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h, l = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        d = box2d.b2AddVV(box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(l, a, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d),
        c = box2d.b2MulRV(n, this.m_localYAxisA, this.m_ay),
        u = box2d.b2CrossVV(box2d.b2AddVV(d, a, box2d.b2Vec2.s_t0), c),
        p = box2d.b2CrossVV(l, c),
        b = box2d.b2DotVV(d, this.m_ay),
        m = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
    h = 0 !== m ? -b / m : 0;
    var y = box2d.b2MulSV(h, c, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P),
        f = h * u,
        x = h * p;
    return e.SelfMulSub(this.m_invMassA, y), i -= this.m_invIA * f, o.SelfMulAdd(this.m_invMassB, y), s += this.m_invIB * x, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, box2d.b2Abs(b) <= box2d.b2_linearSlop
}, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.GetDefinition = function(t) {
    return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t
}, box2d.b2WheelJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2WheelJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2WheelJoint.prototype.GetReactionForce = function(t, e) {
    return e.x = t * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x), e.y = t * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y), e
}, box2d.b2WheelJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2WheelJoint.prototype.GetLocalAxisA = function(t) {
    return t.Copy(this.m_localXAxisA)
}, box2d.b2WheelJoint.prototype.GetJointTranslation = function() {
    var t = this.m_bodyA,
        e = this.m_bodyB,
        i = t.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2),
        o = e.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2),
        s = box2d.b2SubVV(o, i, new box2d.b2Vec2),
        n = t.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2);
    return box2d.b2DotVV(s, n)
}, box2d.b2WheelJoint.prototype.GetJointSpeed = function() {
    var t = this.m_bodyA.m_angularVelocity;
    return this.m_bodyB.m_angularVelocity - t
}, box2d.b2WheelJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
}, box2d.b2WheelJoint.prototype.EnableMotor = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
}, box2d.b2WheelJoint.prototype.SetMotorSpeed = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
}, box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorTorque = t
}, box2d.b2WheelJoint.prototype.GetMotorTorque = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2WheelJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d.b2MotorJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2MotorJointDef = function() {
    goog.base(this, box2d.b2JointType.e_motorJoint), this.linearOffset = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef), box2d.b2MotorJointDef.prototype.linearOffset = null, box2d.b2MotorJointDef.prototype.angularOffset = 0, box2d.b2MotorJointDef.prototype.maxForce = 1, box2d.b2MotorJointDef.prototype.maxTorque = 1, box2d.b2MotorJointDef.prototype.correctionFactor = .3, box2d.b2MotorJointDef.prototype.Initialize = function(t, e) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
    var i = this.bodyA.GetAngleRadians(),
        o = this.bodyB.GetAngleRadians();
    this.angularOffset = o - i
}, box2d.b2MotorJoint = function(t) {
    goog.base(this, t), this.m_linearOffset = t.linearOffset.Clone(), this.m_linearImpulse = new box2d.b2Vec2(0, 0), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_correctionFactor = t.correctionFactor, this.m_rA = new box2d.b2Vec2(0, 0), this.m_rB = new box2d.b2Vec2(0, 0), this.m_localCenterA = new box2d.b2Vec2(0, 0), this.m_localCenterB = new box2d.b2Vec2(0, 0), this.m_linearError = new box2d.b2Vec2(0, 0), this.m_linearMass = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_K = new box2d.b2Mat22
}, goog.inherits(box2d.b2MotorJoint, box2d.b2Joint), box2d.b2MotorJoint.prototype.m_linearOffset = null, box2d.b2MotorJoint.prototype.m_angularOffset = 0, box2d.b2MotorJoint.prototype.m_linearImpulse = null, box2d.b2MotorJoint.prototype.m_angularImpulse = 0, box2d.b2MotorJoint.prototype.m_maxForce = 0, box2d.b2MotorJoint.prototype.m_maxTorque = 0, box2d.b2MotorJoint.prototype.m_correctionFactor = .3, box2d.b2MotorJoint.prototype.m_indexA = 0, box2d.b2MotorJoint.prototype.m_indexB = 0, box2d.b2MotorJoint.prototype.m_rA = null, box2d.b2MotorJoint.prototype.m_rB = null, box2d.b2MotorJoint.prototype.m_localCenterA = null, box2d.b2MotorJoint.prototype.m_localCenterB = null, box2d.b2MotorJoint.prototype.m_linearError = null, box2d.b2MotorJoint.prototype.m_angularError = 0, box2d.b2MotorJoint.prototype.m_invMassA = 0, box2d.b2MotorJoint.prototype.m_invMassB = 0, box2d.b2MotorJoint.prototype.m_invIA = 0, box2d.b2MotorJoint.prototype.m_invIB = 0, box2d.b2MotorJoint.prototype.m_linearMass = null, box2d.b2MotorJoint.prototype.m_angularMass = 0, box2d.b2MotorJoint.prototype.m_qA = null, box2d.b2MotorJoint.prototype.m_qB = null, box2d.b2MotorJoint.prototype.m_K = null, box2d.b2MotorJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetPosition(t)
}, box2d.b2MotorJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetPosition(t)
}, box2d.b2MotorJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t, this.m_linearImpulse, e)
}, box2d.b2MotorJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_angularImpulse
}, box2d.b2MotorJoint.prototype.SetCorrectionFactor = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && 0 <= t && t <= 1), this._correctionFactor = t
}, box2d.b2MotorJoint.prototype.GetCorrectionFactor = function() {
    return this.m_correctionFactor
}, box2d.b2MotorJoint.prototype.SetLinearOffset = function(t) {
    box2d.b2IsEqualToV(t, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(t))
}, box2d.b2MotorJoint.prototype.GetLinearOffset = function(t) {
    return t.Copy(this.m_linearOffset)
}, box2d.b2MotorJoint.prototype.SetAngularOffset = function(t) {
    t !== this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = t)
}, box2d.b2MotorJoint.prototype.GetAngularOffset = function() {
    return this.m_angularOffset
}, box2d.b2MotorJoint.prototype.SetMaxForce = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && 0 <= t), this.m_maxForce = t
}, box2d.b2MotorJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2MotorJoint.prototype.SetMaxTorque = function(t) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && 0 <= t), this.m_maxTorque = t
}, box2d.b2MotorJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
}, box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r),
        c = box2d.b2MulRV(l, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA),
        u = box2d.b2MulRV(d, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB),
        p = this.m_invMassA,
        b = this.m_invMassB,
        m = this.m_invIA,
        y = this.m_invIB,
        f = this.m_K;
    if (f.ex.x = p + b + m * c.y * c.y + y * u.y * u.y, f.ex.y = -m * c.x * c.y - y * u.x * u.y, f.ey.x = f.ex.y, f.ey.y = p + b + m * c.x * c.x + y * u.x * u.x, f.GetInverse(this.m_linearMass), this.m_angularMass = m + y, 0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass), box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(n, u, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(l, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError), this.m_angularError = r - i - this.m_angularOffset, t.step.warmStarting) {
        this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
        var x = this.m_linearImpulse;
        o.SelfMulSub(p, x), s -= m * (box2d.b2CrossVV(c, x) + this.m_angularImpulse), a.SelfMulAdd(b, x), h += y * (box2d.b2CrossVV(u, x) + this.m_angularImpulse)
    } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        d = t.step.inv_dt,
        c = s - i + d * this.m_correctionFactor * this.m_angularError,
        u = -this.m_angularMass * c,
        p = this.m_angularImpulse,
        b = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + u, -b, b), i -= a * (u = this.m_angularImpulse - p), s += h * u;
    var m = this.m_rA,
        y = this.m_rB;
    c = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(o, box2d.b2CrossSV(s, y, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(e, box2d.b2CrossSV(i, m, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(d * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot), u = box2d.b2MulMV(this.m_linearMass, c, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(), p = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(u);
    b = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > b * b && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(b)), box2d.b2SubVV(this.m_linearImpulse, p, u), e.SelfMulSub(n, u), i -= a * box2d.b2CrossVV(m, u), o.SelfMulAdd(r, u), s += h * box2d.b2CrossVV(y, u), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolvePositionConstraints = function() {
    return !0
}, box2d.b2MotorJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y), box2d.b2Log("  jd.angularOffset = %.15f;\n", this.m_angularOffset), box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce), box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque), box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
}, goog.provide("box2d"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2Timer"), goog.require("box2d.b2CircleShape"), goog.require("box2d.b2EdgeShape"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2Distance"), goog.require("box2d.b2DynamicTree"), goog.require("box2d.b2TimeOfImpact"), goog.require("box2d.b2Body"), goog.require("box2d.b2Fixture"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2World"), goog.require("box2d.b2Contact"), goog.require("box2d.b2AreaJoint"), goog.require("box2d.b2DistanceJoint"), goog.require("box2d.b2FrictionJoint"), goog.require("box2d.b2GearJoint"), goog.require("box2d.b2MotorJoint"), goog.require("box2d.b2MouseJoint"), goog.require("box2d.b2PrismaticJoint"), goog.require("box2d.b2PulleyJoint"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2RopeJoint"), goog.require("box2d.b2WeldJoint"), goog.require("box2d.b2WheelJoint"), goog.require("box2d.b2Rope"), goog.require("box2d.b2BuoyancyController"), goog.require("box2d.b2ConstantAccelController"), goog.require("box2d.b2ConstantForceController"), goog.require("box2d.b2GravityController"), goog.require("box2d.b2TensorDampingController"), Phaser.Physics.Box2D = function(t, e) {
    this.game = t, this.version = "1.0.2", this.ptmRatio = 50, this.world = new box2d.b2World(new box2d.b2Vec2(0, 0)), this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.mpx(1)), this.world.SetDebugDraw(this.debugDraw), this.contactListener = new Phaser.Physics.Box2D.DefaultContactListener, this.world.SetContactListener(this.contactListener), this.nextBodyId = 0, this.nextFixtureId = 0, this.gravity = new Phaser.Physics.Box2D.PointProxy(this, this.world, this.world.GetGravity, this.world.SetGravity), this.friction = .2, this.restitution = 0, this.density = 1, this.frameRate = 1 / 60, this.velocityIterations = 8, this.positionIterations = 3, this.useElapsedTime = !1, this.paused = !1, this.particleSystem = null;
    var i = new box2d.b2BodyDef;
    this.mouseJointBody = this.world.CreateBody(i), this.mouseJoint = null, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && (this.mpx = e.mpx, this.pxm = e.pxm), this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    }, this.onBodyAdded = new Phaser.Signal, this.onBodyRemoved = new Phaser.Signal, this._toRemove = []
}, Phaser.Physics.Box2D.worldBoundsFilterCategory = 32768, Phaser.Physics.Box2D.prototype = {
    getNextBodyId: function() {
        var t = this.nextBodyId;
        return this.nextBodyId += 1, t
    },
    getNextFixtureId: function() {
        var t = this.nextFixtureId;
        return this.nextFixtureId += 1, t
    },
    removeBodyNextStep: function(t) {
        this._toRemove.push(t)
    },
    preUpdate: function() {
        for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
        this._toRemove.length = 0
    },
    enable: function(t, e) {
        void 0 === e && (e = !0);
        var i = 1;
        if (Array.isArray(t))
            for (i = t.length; i--;) t[i] instanceof Phaser.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && 0 < t[i].children.length && this.enable(t[i], !0));
        else t instanceof Phaser.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, !0))
    },
    enableBody: function(t) {
        t.hasOwnProperty("body") && null === t.body && (t.body = new Phaser.Physics.Box2D.Body(this.game, t, t.x, t.y, 2), t.anchor.set(.5))
    },
    setBoundsToWorld: function(t, e, i, o, s, n) {
        void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === s && (s = 1), void 0 === n && (s = 4294967295), this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, o, s, n)
    },
    setBounds: function(t, e, i, o, s, n, r, a, h, l) {
        void 0 === s && (s = !0), void 0 === n && (n = !0), void 0 === r && (r = !0), void 0 === a && (a = !0), void 0 === h && (h = 1), void 0 === l && (l = 4294967295), this.walls.left && this.removeBody(this.walls.left), this.walls.right && this.removeBody(this.walls.right), this.walls.top && this.removeBody(this.walls.top), this.walls.bottom && this.removeBody(this.walls.bottom);
        var d = new box2d.b2PolygonShape,
            c = new box2d.b2FixtureDef;
        c.shape = d, c.filter.categoryBits = Phaser.Physics.Box2D.worldBoundsFilterCategory, c.filter.maskBits = 65535;
        var u = this.pxm(100),
            p = this.game.world.bounds;
        s && (this.walls.left = this.createBody(0, 0, 0), d.SetAsOrientedBox(u, this.pxm(p.height) + u, new box2d.b2Vec2(u, 0), 0), this.walls.left.data.CreateFixture(c).id = this.getNextFixtureId());
        n && (this.walls.right = this.createBody(0, 0, 0), d.SetAsOrientedBox(u, this.pxm(p.height) + u, new box2d.b2Vec2(this.pxm(-p.width) - u, 0), 0), this.walls.right.data.CreateFixture(c).id = this.getNextFixtureId());
        r && (this.walls.top = this.createBody(0, 0, 0), d.SetAsOrientedBox(this.pxm(p.width) + u, u, new box2d.b2Vec2(0, u), 0), this.walls.top.data.CreateFixture(c).id = this.getNextFixtureId());
        a && (this.walls.bottom = this.createBody(0, 0, 0), d.SetAsOrientedBox(this.pxm(p.width) + u, u, new box2d.b2Vec2(0, this.pxm(-p.height) - u), 0), this.walls.bottom.data.CreateFixture(c).id = this.getNextFixtureId())
    },
    pause: function() {
        this.paused = !0
    },
    resume: function() {
        this.paused = !1
    },
    update: function() {
        this.paused || (this.useElapsedTime ? this.world.Step(this.game.time.physicsElapsed, this.velocityIterations, this.positionIterations) : this.world.Step(this.frameRate, this.velocityIterations, this.positionIterations))
    },
    reset: function() {
        this.clear()
    },
    clear: function() {
        var t = this.world.GetGravity().Clone();
        this.world = new box2d.b2World(t), this.world.SetDebugDraw(this.debugDraw), this.world.SetContactListener(this.contactListener), this._toRemove = []
    },
    destroy: function() {
        this.clear(), this.gravity = null, this.world = null, this.game = null
    },
    createBody: function(t, e, i) {
        return new Phaser.Physics.Box2D.Body(this.game, null, t, e, i, this)
    },
    createCircle: function(t, e, i, o, s) {
        return this.createBody(t, e, 2).setCircle(i, o, s)
    },
    createRectangle: function(t, e, i, o, s, n, r) {
        return this.createBody(t, e, 2).setRectangle(i, o, s, n, r)
    },
    createPolygon: function(t, e, i, o, s) {
        return this.createBody(t, e, 2).setPolygon(i, o, s)
    },
    addBody: function(t) {
        return !t.data.world && (t.data = this.world.CreateBody(t.bodyDef), t.data.world = this.world, t.data.parent = t, this.onBodyAdded.dispatch(t), !0)
    },
    removeBody: function(t) {
        return t.data.world == this.world && (this.world.DestroyBody(t.data), this.onBodyRemoved.dispatch(t)), t
    },
    getBodies: function() {
        for (var t = [], e = this.world.GetBodyList(); e; e = e.GetNext()) t.push(e);
        return t
    },
    getBody: function(t) {
        return t instanceof box2d.b2Body ? t : t instanceof Phaser.Physics.Box2D.Body ? t.data : t.body && t.body.type === Phaser.Physics.BOX2D ? t.body.data : null
    },
    toJSON: function() {
        return this.world.toJSON()
    },
    mpx: function(t) {
        return t * this.ptmRatio
    },
    pxm: function(t) {
        return t / this.ptmRatio
    },
    renderDebugDraw: function(t) {
        if (this.game.physics.box2d) {
            var e = this.game.physics.box2d;
            e.debugDraw.start(t), e.world.DrawDebugData(), e.debugDraw.stop()
        }
    },
    renderBodyInfo: function(t, e) {
        t.line("Position: x: " + e.x.toFixed(3) + " y: " + e.y.toFixed(3)), t.line("Rotation: " + e.rotation.toFixed(3) + " degrees"), t.line("Velocity: x: " + e.velocity.x.toFixed(3) + " y: " + e.velocity.y.toFixed(3)), t.line("Angular velocity: " + e.angularVelocity.toFixed(3) + " degrees/sec")
    },
    getFixturesAtPoint: function(t, e, i, o) {
        void 0 === i && (i = !1), void 0 === o && (o = !1);
        var s = this.pxm(-t),
            n = this.pxm(-e),
            r = new box2d.b2Vec2(s, n),
            a = new box2d.b2AABB,
            h = new box2d.b2Vec2;
        h.SetXY(.001, .001), box2d.b2SubVV(r, h, a.lowerBound), box2d.b2AddVV(r, h, a.upperBound);
        var l = [];
        return this.world.QueryAABB(function(t) {
            return !(!o || t.GetBody().GetType() === box2d.b2BodyType.b2_dynamicBody) || !t.TestPoint(r) || (l.push(t), !i)
        }, a), l
    },
    getBodiesAtPoint: function(t, e, i, o) {
        void 0 === i && (i = !1), void 0 === o && (o = !1);
        var s = this.getFixturesAtPoint(t, e, i, o);
        if (s.length < 1) return s;
        for (var n = [], r = 0; r < s.length; r++) n.push(s[r].GetBody().parent);
        return n.filter(function(t, e) {
            return n.indexOf(t) === e
        }), n
    },
    mouseDragStart: function(t) {
        this.mouseDragEnd();
        var e = this.getFixturesAtPoint(t.x, t.y, !0, !0);
        if (!(e.length < 1)) {
            var i = this.pxm(-t.x),
                o = this.pxm(-t.y),
                s = new box2d.b2Vec2(i, o),
                n = new box2d.b2MouseJointDef;
            n.bodyA = this.mouseJointBody, n.bodyB = e[0].GetBody(), n.target.Copy(s), n.maxForce = 1e3 * n.bodyB.GetMass(), this.mouseJoint = this.world.CreateJoint(n), n.bodyB.SetAwake(!0)
        }
    },
    mouseDragMove: function(t) {
        if (this.mouseJoint) {
            var e = this.pxm(-t.x),
                i = this.pxm(-t.y),
                o = new box2d.b2Vec2(e, i);
            this.mouseJoint.SetTarget(o)
        }
    },
    mouseDragEnd: function() {
        this.mouseJoint && (this.world.DestroyJoint(this.mouseJoint), this.mouseJoint = null)
    },
    distanceJoint: function(t, e, i, o, s, n, r, a, h) {
        void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var l = new box2d.b2DistanceJointDef;
        if (l.bodyA = t.data, l.bodyB = e.data, l.localAnchorA.SetXY(o, s), l.localAnchorB.SetXY(n, r), null == i) {
            var d = new box2d.b2Vec2,
                c = new box2d.b2Vec2;
            l.bodyA.GetWorldPoint(l.localAnchorA, d), l.bodyB.GetWorldPoint(l.localAnchorB, c), d.SelfSub(c), i = d.Length()
        } else i = this.pxm(i);
        return l.length = i, l.frequencyHz = a, l.dampingRatio = h, this.world.CreateJoint(l)
    },
    ropeJoint: function(t, e, i, o, s, n, r) {
        void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var a = new box2d.b2RopeJointDef;
        if (a.bodyA = t.data, a.bodyB = e.data, a.localAnchorA.SetXY(o, s), a.localAnchorB.SetXY(n, r), null == i) {
            var h = new box2d.b2Vec2,
                l = new box2d.b2Vec2;
            a.bodyA.GetWorldPoint(a.localAnchorA, h), a.bodyB.GetWorldPoint(a.localAnchorB, l), h.SelfSub(l), i = h.Length()
        } else i = this.pxm(i);
        return a.maxLength = i, this.world.CreateJoint(a)
    },
    revoluteJoint: function(t, e, i, o, s, n, r, a, h, l, d, c) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = !1), void 0 === l && (l = 0), void 0 === d && (d = 0), void 0 === c && (c = !1), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var u = new box2d.b2RevoluteJointDef;
        return u.bodyA = t.data, u.bodyB = e.data, u.localAnchorA.SetXY(i, o), u.localAnchorB.SetXY(s, n), u.motorSpeed = Phaser.Math.degToRad(-r), u.maxMotorTorque = a, u.enableMotor = h, u.lowerAngle = Phaser.Math.degToRad(l), u.upperAngle = Phaser.Math.degToRad(d), u.enableLimit = c, this.world.CreateJoint(u)
    },
    prismaticJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, u, p, b) {
        void 0 === i && (i = 1), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === c && (c = 0), void 0 === u && (u = 0), void 0 === p && (p = !1), void 0 === d && (d = !1), void 0 === b && (b = 0), i *= -1, o *= -1, s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(h), c = this.pxm(c), u = this.pxm(u), t.body && (t = t.body), e.body && (e = e.body);
        var m = new box2d.b2PrismaticJointDef;
        return m.bodyA = t.data, m.bodyB = e.data, m.localAxisA.SetXY(i, o), m.localAnchorA.SetXY(s, n), m.localAnchorB.SetXY(r, a), m.motorSpeed = h, m.maxMotorForce = l, m.enableMotor = d, m.lowerTranslation = c, m.upperTranslation = u, m.enableLimit = p, m.referenceAngle = Phaser.Math.degToRad(-b), this.world.CreateJoint(m)
    },
    frictionJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2FrictionJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(s, n), h.localAnchorB.SetXY(r, a), h.maxForce = i, h.maxTorque = o, this.world.CreateJoint(h)
    },
    weldJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2WeldJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(i, o), h.localAnchorB.SetXY(s, n), h.frequencyHz = r, h.dampingRatio = a, this.world.CreateJoint(h)
    },
    motorJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 1), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2MotorJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.linearOffset.SetXY(n, r), h.maxForce = i, h.maxTorque = o, h.angularOffset = Phaser.Math.degToRad(-a), h.correctionFactor = s, this.world.CreateJoint(h)
    },
    wheelJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, u) {
        void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === d && (d = 0), void 0 === c && (c = 0), void 0 === u && (u = !1), void 0 === h && (h = 0), void 0 === l && (l = 0), r *= -1, a *= -1, i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var p = new box2d.b2WheelJointDef;
        return p.bodyA = t.data, p.bodyB = e.data, p.localAxisA.SetXY(r, a), p.localAnchorA.SetXY(i, o), p.localAnchorB.SetXY(s, n), p.motorSpeed = Phaser.Math.degToRad(-d), p.maxMotorTorque = c, p.enableMotor = u, p.frequencyHz = h, p.dampingRatio = l, this.world.CreateJoint(p)
    },
    pulleyJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, u) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === d && (d = 1), void 0 === c && (c = 100), void 0 === u && (u = 100), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(-h), l = this.pxm(-l), c = this.pxm(c), u = this.pxm(u), t.body && (t = t.body), e.body && (e = e.body);
        var p = new box2d.b2PulleyJointDef;
        return p.bodyA = t.data, p.bodyB = e.data, p.localAnchorA.SetXY(i, o), p.localAnchorB.SetXY(s, n), p.groundAnchorA.SetXY(r, a), p.groundAnchorB.SetXY(h, l), p.lengthA = c, p.lengthB = u, p.ratio = d, this.world.CreateJoint(p)
    },
    gearJoint: function(t, e, i) {
        void 0 === i && (i = 1);
        var o = new box2d.b2GearJointDef;
        return o.joint1 = t, o.joint2 = e, o.ratio = -i, o.bodyA = t.GetBodyA(), o.bodyB = e.GetBodyB(), this.world.CreateJoint(o)
    },
    clearTilemapLayerBodies: function(t, e) {
        e = t.getLayer(e);
        for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
        t.layers[e].bodies.length = 0
    },
    convertTilemap: function(t, e, i, o) {
        e = t.getLayer(e), void 0 === i && (i = !0), void 0 === o && (o = !0), this.clearTilemapLayerBodies(t, e);
        for (var s = 0, n = 0, r = 0, a = 0, h = t.layers[e].height; a < h; a++)
            for (var l = s = 0, d = t.layers[e].width; l < d; l++) {
                var c = t.layers[e].data[a][l];
                if (c && -1 < c.index && c.collides)
                    if (o) {
                        var u = t.getTileRight(e, l, a);
                        if (0 === s && (n = c.x * c.width, r = c.y * c.height, s = c.width), u && u.collides) s += c.width;
                        else(p = new Phaser.Physics.Box2D.Body(this.game, null, n, r, 0)).addRectangle(s, c.height, s / 2, c.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), s = 0
                    } else {
                        var p;
                        (p = this.createBody(c.x * c.width, c.y * c.height, 0, !1)).addRectangle(c.width, c.height, c.width / 2, c.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                    }
            }
        return t.layers[e].bodies
    },
    raycast: function(t, e, i, o, s, n) {
        void 0 === s && (s = !0), void 0 === n && (n = null), t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(-i), o = this.pxm(-o);
        var r = new box2d.b2Vec2(t, e),
            a = new box2d.b2Vec2(i, o),
            h = [],
            l = new Phaser.Physics.Box2D.RayCastCallback(this, s, n);
        this.world.RayCast(l, r, a);
        for (var d = 0; d < l.hits.length; d++) {
            var c = l.hits[d];
            c.point = {
                x: this.mpx(-c.point.x),
                y: this.mpx(-c.point.y)
            }, c.normal = {
                x: -c.normal.x,
                y: -c.normal.y
            }, h.push(c)
        }
        return h
    },
    queryAABB: function(t, e, i, o) {
        t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(i), o = this.pxm(o);
        var s = new box2d.b2AABB;
        s.lowerBound.SetXY(t - i, e - o), s.upperBound.SetXY(t, e);
        var n = new Phaser.Physics.Box2D.QueryCallback(this);
        return this.world.QueryAABB(n, s), n.hits
    },
    queryFixture: function(t) {
        var e = new Phaser.Physics.Box2D.QueryCallback(this);
        return this.world.QueryShape(e, t.GetShape(), t.GetBody().GetTransform()), e.hits
    },
    setPTMRatio: function(t) {
        this.ptmRatio = t, this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.ptmRatio), this.world.SetDebugDraw(this.debugDraw)
    }
}, Phaser.Physics.Box2D.RayCastCallback = function(t, e, i) {
    this.world = t, this.closestHitOnly = e, this.filterFunction = i, this.hits = []
}, goog.inherits(Phaser.Physics.Box2D.RayCastCallback, box2d.b2RayCastCallback), Phaser.Physics.Box2D.RayCastCallback.prototype.ReportFixture = function(t, e, i, o) {
    if (null !== this.filterFunction) {
        var s = {
                x: this.world.mpx(-e.x),
                y: this.world.mpx(-e.y)
            },
            n = {
                x: -i.x,
                y: -i.y
            },
            r = t.GetBody().parent;
        if (!this.filterFunction.call(this, r, t, s, n)) return -1
    }
    this.closestHitOnly && (this.hits = []);
    var a = {};
    return a.body = t.GetBody().parent, a.fixture = t, a.point = {
        x: e.x,
        y: e.y
    }, a.normal = {
        x: i.x,
        y: i.y
    }, this.hits.push(a), this.closestHitOnly ? o : 1
}, Phaser.Physics.Box2D.QueryCallback = function(t) {
    this.world = t, this.hits = []
}, goog.inherits(Phaser.Physics.Box2D.QueryCallback, box2d.b2QueryCallback), Phaser.Physics.Box2D.QueryCallback.prototype.ReportFixture = function(t) {
    var e = {};
    return e.body = t.GetBody().parent, e.fixture = t, this.hits.push(e), !0
}, Phaser.Physics.Box2D.renderBody = function(t, e, i, o) {
    i = i || "rgb(255,255,255)", void 0 === o && (o = !0);
    var s = e.data,
        n = s.GetTransform(),
        r = e.world;
    n.p.x += -e.game.camera.x / r.ptmRatio, n.p.y -= -e.game.camera.y / r.ptmRatio, r.debugDraw.start(t), r.debugDraw.PushTransform(n);
    var a = Phaser.Color.webToColor(i),
        h = r.debugDraw.color;
    h.r = a.r / 255, h.g = a.g / 255, h.b = a.b / 255;
    for (var l = s.GetFixtureList(); l; l = l.GetNext()) r.world.DrawShape(l, h);
    r.debugDraw.PopTransform(), r.debugDraw.stop()
}, Phaser.Physics.Box2D.Body = function(t, e, i, o, s, n) {
    void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 2), void 0 === n && (n = t.physics.box2d), this.game = t, this.world = n, this.id = this.world.getNextBodyId(), this.sprite = e, this.type = Phaser.Physics.BOX2D, this.offset = new Phaser.Point, this.bodyDef = new box2d.b2BodyDef, this.bodyDef.position.SetXY(-this.world.pxm(i), -this.world.pxm(o)), 0 === s ? this.bodyDef.type = box2d.b2BodyType.b2_staticBody : 1 === s ? this.bodyDef.type = box2d.b2BodyType.b2_kinematicBody : 2 === s ? this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody : 3 === s && (this.bodyDef.type = box2d.b2BodyType.b2_bulletBody), this.data = this.world.world.CreateBody(this.bodyDef), this.data.world = this.world.world, (this.data.parent = this).velocity = new Phaser.Physics.Box2D.PointProxy(this.world, this.data, this.data.GetLinearVelocity, this.data.SetLinearVelocity), this.removeNextStep = !1, this._fixtureContactCallbacks = {}, this._fixtureContactCallbackContext = {}, this._bodyContactCallbacks = {}, this._bodyContactCallbackContext = {}, this._categoryContactCallbacks = {}, this._categoryContactCallbackContext = {}, this._fixturePresolveCallbacks = {}, this._fixturePresolveCallbackContext = {}, this._bodyPresolveCallbacks = {}, this._bodyPresolveCallbackContext = {}, this._categoryPresolveCallbacks = {}, this._categoryPresolveCallbackContext = {}, this._fixturePostsolveCallbacks = {}, this._fixturePostsolveCallbackContext = {}, this._bodyPostsolveCallbacks = {}, this._bodyPostsolveCallbackContext = {}, this._categoryPostsolveCallbacks = {}, this._categoryPostsolveCallbackContext = {}, e && this.setRectangleFromSprite(e)
}, Phaser.Physics.Box2D.Body.prototype = {
    setBodyContactCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), -1 < o && (null === e ? (delete this._bodyContactCallbacks[o], delete this._bodyContactCallbackContext[o]) : (this._bodyContactCallbacks[o] = e, this._bodyContactCallbackContext[o] = i))
    },
    setFixtureContactCallback: function(t, e, i) {
        var o = t.id; - 1 < o && (null === e ? (delete this._fixtureContactCallbacks[o], delete this._fixtureContactCallbackContext[o]) : (this._fixtureContactCallbacks[o] = e, this._fixtureContactCallbackContext[o] = i))
    },
    setCategoryContactCallback: function(t, e, i) {
        null === e ? (delete this._categoryContactCallbacks[t], delete this._categoryContactCallbacksContext[t]) : (this._categoryContactCallbacks[t] = e, this._categoryContactCallbackContext[t] = i)
    },
    setBodyPresolveCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), -1 < o && (null === e ? (delete this._bodyPresolveCallbacks[o], delete this._bodyPresolveCallbackContext[o]) : (this._bodyPresolveCallbacks[o] = e, this._bodyPresolveCallbackContext[o] = i))
    },
    setFixturePresolveCallback: function(t, e, i) {
        var o = t.id; - 1 < o && (null === e ? (delete this._fixturePresolveCallbacks[o], delete this._fixturePresolveCallbackContext[o]) : (this._fixturePresolveCallbacks[o] = e, this._fixturePresolveCallbackContext[o] = i))
    },
    setCategoryPresolveCallback: function(t, e, i) {
        null === e ? (delete this._categoryPresolveCallbacks[t], delete this._categoryPresolveCallbacksContext[t]) : (this._categoryPresolveCallbacks[t] = e, this._categoryPresolveCallbackContext[t] = i)
    },
    setBodyPostsolveCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), -1 < o && (null === e ? (delete this._bodyPostsolveCallbacks[o], delete this._bodyPostsolveCallbackContext[o]) : (this._bodyPostsolveCallbacks[o] = e, this._bodyPostsolveCallbackContext[o] = i))
    },
    setFixturePostsolveCallback: function(t, e, i) {
        var o = t.id; - 1 < o && (null === e ? (delete this._fixturePostsolveCallbacks[o], delete this._fixturePostsolveCallbackContext[o]) : (this._fixturePostsolveCallbacks[o] = e, this._fixturePostsolveCallbackContext[o] = i))
    },
    setCategoryPostsolveCallback: function(t, e, i) {
        null === e ? (delete this._categoryPostsolveCallbacks[t], delete this._categoryPostsolveCallbacksContext[t]) : (this._categoryPostsolveCallbacks[t] = e, this._categoryPostsolveCallbackContext[t] = i)
    },
    setCollisionCategory: function(t, e) {
        if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext()) {
                i.GetFilterData().categoryBits = t
            } else e.GetFilterData().categoryBits = t
    },
    setCollisionMask: function(t, e) {
        if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext()) {
                i.GetFilterData().maskBits = t
            } else e.GetFilterData().maskBits = t
    },
    applyForce: function(t, e) {
        this.data.ApplyForce(new box2d.b2Vec2(-t, -e), this.data.GetWorldCenter(), !0)
    },
    setZeroRotation: function() {
        this.data.SetAngularVelocity(0)
    },
    setZeroVelocity: function() {
        this.data.SetLinearVelocity(box2d.b2Vec2.ZERO)
    },
    setZeroDamping: function() {
        this.data.SetLinearDamping(0), this.data.SetAngularDamping(0)
    },
    toLocalPoint: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toWorldPoint: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toLocalVector: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toWorldVector: function(t, e) {
        t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y)
    },
    rotateLeft: function(t) {
        this.data.SetAngularVelocity(this.world.pxm(-t))
    },
    rotateRight: function(t) {
        this.data.SetAngularVelocity(this.world.pxm(t))
    },
    moveForward: function(t) {
        var e = this.world.pxm(t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.SetLinearVelocity(i)
    },
    moveBackward: function(t) {
        var e = this.world.pxm(-t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.SetLinearVelocity(i)
    },
    thrust: function(t) {
        var e = this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0)
    },
    reverse: function(t) {
        var e = -this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0)
    },
    moveLeft: function(t) {
        this.velocity.x = -t
    },
    moveRight: function(t) {
        this.velocity.x = t
    },
    moveUp: function(t) {
        this.velocity.y = -t
    },
    moveDown: function(t) {
        this.velocity.y = t
    },
    preUpdate: function() {
        this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
    },
    postUpdate: function() {
        this.sprite && (this.sprite.x = this.world.mpx(-this.data.GetPosition().x), this.sprite.y = this.world.mpx(-this.data.GetPosition().y), this.sprite.rotation = this.data.GetAngle())
    },
    kill: function() {
        this.data.SetActive(!1)
    },
    reset: function(t, e) {
        this.data.SetPositionXY(this.world.pxm(-t), this.world.pxm(-e)), this.data.SetActive(!0)
    },
    removeFromWorld: function() {
        this.data.world === this.game.physics.box2d.world && this.game.physics.box2d.removeBodyNextStep(this)
    },
    destroy: function() {
        this.removeFromWorld(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._categoryCallbacks = {}, this._categoryCallbackContext = {}, this.sprite = null
    },
    clearFixtures: function() {
        for (var t = [], e = this.data.GetFixtureList(); e; e = e.GetNext()) t.push(e);
        for (var i = t.length; i--;) this.data.DestroyFixture(t[i])
    },
    addCircle: function(t, e, i) {
        var o = new box2d.b2CircleShape(this.world.pxm(t));
        o.m_p.SetXY(this.world.pxm(-e), this.world.pxm(-i));
        var s = new box2d.b2FixtureDef;
        s.shape = o, s.friction = this.world.friction, s.restitution = this.world.restitution, s.density = this.world.density;
        var n = this.data.CreateFixture(s);
        return n.id = this.world.getNextFixtureId(), n
    },
    addRectangle: function(t, e, i, o, s) {
        void 0 === t && (t = 16), void 0 === e && (e = 16), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), t = this.world.pxm(t), e = this.world.pxm(e);
        var n = new box2d.b2PolygonShape;
        n.SetAsOrientedBox(.5 * t, .5 * e, new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o)), s);
        var r = new box2d.b2FixtureDef;
        r.shape = n, r.friction = this.world.friction, r.restitution = this.world.restitution, r.density = this.world.density;
        var a = this.data.CreateFixture(r);
        return a.id = this.world.getNextFixtureId(), a
    },
    addEdge: function(t, e, i, o) {
        var s = new box2d.b2EdgeShape;
        s.Set(new box2d.b2Vec2(this.world.pxm(-t), this.world.pxm(-e)), new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o)));
        var n = new box2d.b2FixtureDef;
        n.shape = s, n.friction = this.world.friction, n.restitution = this.world.restitution, n.density = this.world.density;
        var r = this.data.CreateFixture(n);
        return r.id = this.world.getNextFixtureId(), r
    },
    addChain: function(t, e, i, o) {
        if (void 0 === t) return null;
        if (t.length < 4) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2);
        for (var s = [], n = e; n < e + i; n++) s.push(new box2d.b2Vec2(this.world.pxm(-t[2 * n]), this.world.pxm(-t[2 * n + 1])));
        var r = new box2d.b2ChainShape;
        o ? r.CreateLoop(s, s.length) : r.CreateChain(s, s.length);
        var a = new box2d.b2FixtureDef;
        a.shape = r, a.friction = this.world.friction, a.restitution = this.world.restitution, a.density = this.world.density;
        var h = this.data.CreateFixture(a);
        return h.id = this.world.getNextFixtureId(), h
    },
    addLoop: function(t, e, i) {
        return this.addChain(t, e, i, !0)
    },
    addPolygon: function(t, e, i) {
        if (void 0 === t) return null;
        if (t.length < 6) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2);
        for (var o = [], s = e; s < e + i; s++) o.push({
            x: this.world.pxm(-t[2 * s]),
            y: this.world.pxm(-t[2 * s + 1])
        });
        var n = new Phaser.Physics.Box2D.Polygon;
        n.setFromXYObjects(o);
        var r = n.decompose(o),
            a = null;
        for (s = 0; s < r.length; s++) {
            var h = new box2d.b2PolygonShape;
            h.Set(r[s], r[s].length);
            var l = new box2d.b2FixtureDef;
            l.shape = h, l.friction = this.world.friction, l.restitution = this.world.restitution, l.density = this.world.density, (a = this.data.CreateFixture(l)).id = this.world.getNextFixtureId()
        }
        return a
    },
    removeFixture: function(t) {
        return t.GetBody() == this.data && (this.data.DestroyFixture(t), !0)
    },
    setCircle: function(t, e, i) {
        return void 0 === t && (t = 32), void 0 === e && (e = 0), void 0 === i && (i = 0), this.clearFixtures(), this.addCircle(t, e, i)
    },
    setRectangle: function(t, e, i, o, s) {
        return this.clearFixtures(), this.addRectangle(t, e, i, o, s)
    },
    setRectangleFromSprite: function(t) {
        return void 0 === t && (t = this.sprite), this.clearFixtures(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
    },
    setEdge: function(t, e, i, o) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.clearFixtures(), this.addEdge(t, e, i, o)
    },
    setChain: function(t, e, i, o) {
        return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addChain(t, e, i, o))
    },
    setLoop: function(t, e, i) {
        return this.setChain(t, e, i, !0)
    },
    setPolygon: function(t, e, i) {
        return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addPolygon(t, e, i))
    },
    loadPolygon: function(t, e, i) {
        void 0 === i && (i = null);
        for (var o = this.game.cache.getPhysicsData(t, e), s = 0; s < o.length; s++) {
            for (var n = [], r = 0; r < o[s].shape.length; r += 2) n.push(new box2d.b2Vec2(this.world.pxm(-o[s].shape[r]), this.world.pxm(-o[s].shape[r + 1])));
            if (i)
                for (var a = this.world.pxm(-.5 * i.width), h = this.world.pxm(-.5 * i.height), l = 0; l < n.length; l++) n[l].x -= a, n[l].y -= h;
            var d = new box2d.b2PolygonShape;
            d.Set(n, n.length);
            var c = new box2d.b2FixtureDef;
            c.shape = d, c.friction = o[s].friction, c.restitution = o[s].bounce, c.density = o[s].density, c.filter.categoryBits = o[s].filter.categoryBits, c.filter.maskBits = o[s].filter.maskBits, this.data.CreateFixture(c).id = this.world.getNextFixtureId()
        }
        return !0
    },
    containsPoint: function(t) {
        for (var e = this.world.pxm(-t.x), i = this.world.pxm(-t.y), o = new box2d.b2Vec2(e, i), s = this.data.GetFixtureList(); s; s = s.GetNext())
            if (s.TestPoint(o)) return !0;
        return !1
    }
}, Phaser.Physics.Box2D.Body.prototype.constructor = Phaser.Physics.Box2D.Body, Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "static", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_staticBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_staticBody ? this.data.SetType(box2d.b2BodyType.b2_staticBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_staticBody || this.data.SetType(box2d.b2BodyType.b2_dynamicBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "dynamic", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_dynamicBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody ? this.data.SetType(box2d.b2BodyType.b2_dynamicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "kinematic", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_kinematicBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody ? this.data.SetType(box2d.b2BodyType.b2_kinematicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.GetAngle()))
    },
    set: function(t) {
        this.data.SetAngle(Phaser.Math.degToRad(Phaser.Math.wrapAngle(t)))
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "linearDamping", {
    get: function() {
        return this.data.GetLinearDamping()
    },
    set: function(t) {
        this.data.SetLinearDamping(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.GetAngularDamping()
    },
    set: function(t) {
        this.data.SetAngularDamping(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.GetAngularVelocity()
    },
    set: function(t) {
        this.data.SetAngularVelocity(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.IsFixedRotation()
    },
    set: function(t) {
        this.data.SetFixedRotation(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "gravityScale", {
    get: function() {
        return this.data.GetGravityScale()
    },
    set: function(t) {
        this.data.SetGravityScale(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "friction", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.GetFriction() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetFriction(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "restitution", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.GetRestitution() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetRestitution(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "sensor", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.IsSensor() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetSensor(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "bullet", {
    get: function() {
        return this.data.IsBullet()
    },
    set: function(t) {
        this.data.SetBullet(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "mass", {
    get: function() {
        return this.data.GetMass()
    },
    set: function(t) {
        if (0 === t) this.data.SetType(box2d.b2BodyType.b2_staticBody);
        else {
            this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody && this.data.SetType(box2d.b2BodyType.b2_dynamicBody);
            for (var e = t / this.data.GetMass(), i = this.data.GetFixtureList(); i; i = i.GetNext()) {
                var o = i.GetDensity();
                i.SetDensity(o * e)
            }
            this.data.ResetMassData()
        }
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "rotation", {
    get: function() {
        return this.data.GetAngle()
    },
    set: function(t) {
        this.data.SetAngle(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "x", {
    get: function() {
        return this.world.mpx(-this.data.GetPosition().x)
    },
    set: function(t) {
        this.data.SetPositionXY(this.world.pxm(-t), this.data.GetPosition().y)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "y", {
    get: function() {
        return this.world.mpx(-this.data.GetPosition().y)
    },
    set: function(t) {
        this.data.SetPositionXY(this.data.GetPosition().x, this.world.pxm(-t))
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "collideWorldBounds", {
    get: function() {
        for (var t = this.data.GetFixtureList(); t; t = t.GetNext()) {
            if (t.GetFilterData().maskBits & Phaser.Physics.Box2D.worldBoundsFilterCategory) return !0
        }
        return !1
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) {
            var i = e.GetFilterData();
            t ? i.maskBits |= Phaser.Physics.Box2D.worldBoundsFilterCategory : i.maskBits &= ~Phaser.Physics.Box2D.worldBoundsFilterCategory
        }
    }
}), Phaser.Physics.Box2D.PointProxy = function(t, e, i, o) {
    this.world = t, this.object = e, this.gettor = i, this.settor = o
}, Phaser.Physics.Box2D.PointProxy.prototype.constructor = Phaser.Physics.Box2D.PointProxy, Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "x", {
    get: function() {
        return this.world.mpx(-this.gettor.call(this.object).x)
    },
    set: function(t) {
        var e = this.gettor.call(this.object);
        e.x = this.world.pxm(-t), this.settor.call(this.object, e)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "y", {
    get: function() {
        return this.world.mpx(-this.gettor.call(this.object).y)
    },
    set: function(t) {
        var e = this.gettor.call(this.object);
        e.y = this.world.pxm(-t), this.settor.call(this.object, e)
    }
}), Phaser.Physics.Box2D.DefaultDebugDraw = function(t) {
    this.context = null, this.pixelsPerMeter = t, this.flags = box2d.b2DrawFlags.e_shapeBit
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.color = new box2d.b2Color(1, 1, 1), Phaser.Physics.Box2D.DefaultDebugDraw.prototype.SetFlags = function(t) {
    this.flags = t
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.GetFlags = function() {
    return this.flags
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.start = function(t) {
    this.context = t, this.context.save(), this.context.scale(-1, -1), this.context.scale(this.pixelsPerMeter, this.pixelsPerMeter)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.stop = function() {
    this.context.restore()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PushTransform = function(t) {
    var e = this.context;
    e.save(), e.translate(t.p.x, t.p.y), e.rotate(t.q.GetAngleRadians())
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PopTransform = function() {
    this.context.restore()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPolygon = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y);
        for (var s = 1; s < e; s++) o.lineTo(t[s].x, t[s].y);
        o.closePath(), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidPolygon = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y);
        for (var s = 1; s < e; s++) o.lineTo(t[s].x, t[s].y);
        o.closePath(), o.fillStyle = i.MakeStyleString(.5), o.fill(), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawCircle = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.beginPath(), o.arc(t.x, t.y, e, 0, 2 * Math.PI, !0), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidCircle = function(t, e, i, o) {
    if (e) {
        var s = this.context;
        s.lineWidth = 1 / this.pixelsPerMeter;
        var n = t.x,
            r = t.y;
        s.beginPath(), s.arc(n, r, e, 0, 2 * Math.PI, !0), s.moveTo(n, r), s.lineTo(n + i.x * e, r + i.y * e), s.fillStyle = o.MakeStyleString(.5), s.fill(), s.strokeStyle = o.MakeStyleString(1), s.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSegment = function(t, e, i) {
    var o = this.context;
    o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t.x, t.y), o.lineTo(e.x, e.y), o.strokeStyle = i.MakeStyleString(1), o.stroke()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawTransform = function(t) {
    var e = this.context;
    e.lineWidth = 1 / this.pixelsPerMeter, this.PushTransform(t), e.beginPath(), e.moveTo(0, 0), e.lineTo(1, 0), e.strokeStyle = box2d.b2Color.RED.MakeStyleString(1), e.stroke(), e.beginPath(), e.moveTo(0, 0), e.lineTo(0, 1), e.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1), e.stroke(), this.PopTransform(t)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPoint = function(t, e, i) {
    var o = this.context;
    o.fillStyle = i.MakeStyleString();
    var s = e / 2;
    o.fillRect(t.x - s, t.y - s, e, e)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawAABB = function(t, e) {
    var i = this.context;
    i.strokeStyle = e.MakeStyleString();
    var o = t.lowerBound.x,
        s = t.lowerBound.y,
        n = t.upperBound.x - t.lowerBound.x,
        r = t.upperBound.y - t.lowerBound.y;
    i.strokeRect(o, s, n, r)
}, Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "shapes", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_shapeBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_shapeBit : this.flags &= ~box2d.b2DrawFlags.e_shapeBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "joints", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_jointBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_jointBit : this.flags &= ~box2d.b2DrawFlags.e_jointBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "aabbs", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_aabbBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_aabbBit : this.flags &= ~box2d.b2DrawFlags.e_aabbBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "pairs", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_pairBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_pairBit : this.flags &= ~box2d.b2DrawFlags.e_pairBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "centerOfMass", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_centerOfMassBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_centerOfMassBit : this.flags &= ~box2d.b2DrawFlags.e_centerOfMassBit
    }
}), Phaser.Physics.Box2D.DefaultContactListener = function() {}, Phaser.Physics.Box2D.DefaultContactListener.prototype.BeginContact = function(t) {
    this.handleContactBeginOrEnd(t, !0)
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.EndContact = function(t) {
    this.handleContactBeginOrEnd(t, !1)
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.handleContactBeginOrEnd = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyContactCallbacks[c] && h._bodyContactCallbacks[c].call(h._bodyContactCallbackContext[c], h, l, i, o, e, t), l._bodyContactCallbacks[d] && l._bodyContactCallbacks[d].call(l._bodyContactCallbackContext[d], l, h, o, i, e, t), h._fixtureContactCallbacks[o.id] && h._fixtureContactCallbacks[o.id].call(h._fixtureContactCallbackContext[o.id], h, l, i, o, e, t), l._fixtureContactCallbacks[i.id] && l._fixtureContactCallbacks[i.id].call(l._fixtureContactCallbackContext[i.id], l, h, o, i, e, t), h._fixtureContactCallbacks[i.id] && h._fixtureContactCallbacks[i.id].call(h._fixtureContactCallbackContext[i.id], h, l, i, o, e, t), l._fixtureContactCallbacks[o.id] && l._fixtureContactCallbacks[o.id].call(l._fixtureContactCallbackContext[o.id], l, h, o, i, e, t), h._categoryContactCallbacks[a] && h._categoryContactCallbacks[a].call(h._categoryContactCallbackContext[a], h, l, i, o, e, t), l._categoryContactCallbacks[r] && l._categoryContactCallbacks[r].call(l._categoryContactCallbackContext[r], l, h, o, i, e, t), h._categoryContactCallbacks[r] && h._categoryContactCallbacks[r].call(h._categoryContactCallbackContext[r], h, l, i, o, e, t), l._categoryContactCallbacks[a] && l._categoryContactCallbacks[a].call(l._categoryContactCallbackContext[a], l, h, o, i, e, t)
    }
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.PreSolve = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyPresolveCallbacks[c] && h._bodyPresolveCallbacks[c].call(h._bodyPresolveCallbackContext[c], h, l, i, o, t, e), l._bodyPresolveCallbacks[d] && l._bodyPresolveCallbacks[d].call(l._bodyPresolveCallbackContext[d], l, h, o, i, t, e), h._fixturePresolveCallbacks[o.id] && h._fixturePresolveCallbacks[o.id].call(h._fixturePresolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePresolveCallbacks[i.id] && l._fixturePresolveCallbacks[i.id].call(l._fixturePresolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPresolveCallbacks[a] && h._categoryPresolveCallbacks[a].call(h._categoryPresolveCallbackContext[a], h, l, i, o, t, e), l._categoryPresolveCallbacks[r] && l._categoryPresolveCallbacks[r].call(l._categoryPresolveCallbackContext[r], l, h, o, i, t, e)
    }
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.PostSolve = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyPostsolveCallbacks[c] && h._bodyPostsolveCallbacks[c].call(h._bodyPostsolveCallbackContext[c], h, l, i, o, t, e), l._bodyPostsolveCallbacks[d] && l._bodyPostsolveCallbacks[d].call(l._bodyPostsolveCallbackContext[d], l, h, o, i, t, e), h._fixturePostsolveCallbacks[o.id] && h._fixturePostsolveCallbacks[o.id].call(h._fixturePostsolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePostsolveCallbacks[i.id] && l._fixturePostsolveCallbacks[i.id].call(l._fixturePostsolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPostsolveCallbacks[a] && h._categoryPostsolveCallbacks[a].call(h._categoryPostsolveCallbackContext[a], h, l, i, o, t, e), l._categoryPostsolveCallbacks[r] && l._categoryPostsolveCallbacks[r].call(l._categoryPostsolveCallbackContext[r], l, h, o, i, t, e)
    }
}, Phaser.Physics.Box2D.Polygon = function() {
    this.vertices = []
}, Phaser.Physics.Box2D.Polygon.prototype.setFromFlatXYCoords = function(t) {
    this.vertices = [];
    for (var e = 0; e < t.length / 2; e++) this.vertices.push({
        x: t[2 * e],
        y: t[2 * e + 1]
    })
}, Phaser.Physics.Box2D.Polygon.prototype.setFromXYObjects = function(t) {
    this.vertices = t.concat()
}, Phaser.Physics.Box2D.Polygon.prototype.addVertex = function(t) {
    this.vertices.push(t)
}, Phaser.Physics.Box2D.Polygon.prototype.at = function(t) {
    var e = this.vertices.length;
    return this.vertices[t < 0 ? t % e + e : t % e]
}, Phaser.Physics.Box2D.Polygon.prototype.indicesAreAdjacent = function(t, e) {
    if ((t %= this.vertices.length) == (e %= this.vertices.length)) return !0;
    var i = Math.abs(t - e);
    return i < 2 || i == this.vertices.length - 1
}, Phaser.Physics.Box2D.Polygon.prototype.areaInTriangle = function(t, e, i) {
    return t = this.at(t), e = this.at(e), i = this.at(i), .5 * ((e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y))
}, Phaser.Physics.Box2D.Polygon.prototype.left = function(t, e, i) {
    return 0 < this.areaInTriangle(t, e, i)
}, Phaser.Physics.Box2D.Polygon.prototype.leftOn = function(t, e, i) {
    return 0 <= this.areaInTriangle(t, e, i)
}, Phaser.Physics.Box2D.Polygon.prototype.right = function(t, e, i) {
    return this.areaInTriangle(t, e, i) < 0
}, Phaser.Physics.Box2D.Polygon.prototype.rightOn = function(t, e, i) {
    return this.areaInTriangle(t, e, i) <= 0
}, Phaser.Physics.Box2D.Polygon.sqdist = function(t, e) {
    var i = e.x - t.x,
        o = e.y - t.y;
    return i * i + o * o
}, Phaser.Physics.Box2D.Polygon.prototype.makeCCW = function() {
    for (var t = 0, e = 1, i = this.vertices.length; e < i; e++)(this.at(e).y < this.at(t).y || this.at(e).y === this.at(t).y && this.at(e).x > this.at(t).x) && (t = e);
    return !this.left(t - 1, t, t + 1) && (this.vertices.reverse(), !0)
}, Phaser.Physics.Box2D.Polygon.prototype.isConvex = function() {
    for (var t = !1, e = !1, i = 0, o = this.vertices.length; i < o; i++) {
        var s = i,
            n = (i + 1) % o,
            r = (i + 2) % o;
        0 < this.areaInTriangle(this.vertices[s], this.vertices[n], this.vertices[r]) ? t = !0 : e = !0
    }
    return e ^ t
}, Phaser.Physics.Box2D.Polygon.prototype.isReflex = function(t) {
    return this.right(t - 1, t, t + 1)
}, Phaser.Physics.Box2D.Polygon.areVecsEqual = function(t, e) {
    return t.x == e.x && t.y == e.y
}, Phaser.Physics.Box2D.Polygon.linesCross = function(t, e, i, o) {
    if (Phaser.Physics.Box2D.Polygon.areVecsEqual(e, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(e, o) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, o)) return null;
    var s = {};
    box2d.b2SubVV(e, t, s), box2d.b2CrossVS(s, 1, s);
    var n = box2d.b2DotVV(s, t),
        r = box2d.b2DotVV(s, i),
        a = box2d.b2DotVV(s, o);
    if (n < r && n < a) return null;
    if (r < n && a < n) return null;
    var h = {};
    box2d.b2SubVV(o, i, h), box2d.b2CrossVS(h, 1, h);
    r = box2d.b2DotVV(h, i), n = box2d.b2DotVV(h, t);
    var l = box2d.b2DotVV(h, e);
    if (r < n && r < l) return null;
    if (n < r && l < r) return null;
    var d = (r - n) / (l - n);
    return {
        x: t.x + d * (e.x - t.x),
        y: t.y + d * (e.y - t.y)
    }
}, Phaser.Physics.Box2D.Polygon.prototype.canSee = function(t, e) {
    if (this.indicesAreAdjacent(t, e)) return !1;
    if (this.leftOn(t + 1, t, e) && this.rightOn(t - 1, t, e)) return !1;
    for (var i = 0; i < this.vertices.length; ++i)
        if ((i + 1) % this.vertices.length != t && i != t && this.leftOn(t, e, i + 1) && this.rightOn(t, e, i) && Phaser.Physics.Box2D.Polygon.linesCross(this.at(t), this.at(e), this.at(i), this.at(i + 1))) return !1;
    return !0
}, Phaser.Physics.Box2D.Polygon.prototype.subPolygon = function(t, e) {
    var i = new Phaser.Physics.Box2D.Polygon;
    if (t < e)
        for (var o = t; o < e + 1; o++) i.addVertex(this.at(o));
    else {
        for (o = t; o < this.vertices.length; o++) i.addVertex(this.at(o));
        for (o = 0; o < e + 1; o++) i.addVertex(this.at(o))
    }
    return i
}, Phaser.Physics.Box2D.Polygon.prototype.decomposeOptimal = function(t) {
    if (void 0 === t && (t = 0), 1 < t) return this.vertices;
    this.makeCCW();
    for (var e = [], i = [], o = [], s = Number.MAX_VALUE, n = 0; n < this.vertices.length; n++)
        if (this.isReflex(n))
            for (var r = 0; r < this.vertices.length; r++) this.canSee(n, r) && (i = this.subPolygon(n, r).decompose(t + 1), o = this.subPolygon(r, n).decompose(t + 1), i.length + o.length < s && (s = (e = i.concat(o)).length));
    return 0 === e.length && e.push(this.vertices), e
}, Phaser.Physics.Box2D.Polygon.prototype.decompose = function(t) {
    void 0 === t && (t = 0), this.makeCCW();
    for (var e, i, o = [], s = Number.MAX_VALUE, n = !1, r = 0; r < this.vertices.length; r++)
        if (this.isReflex(r)) {
            n = !0;
            for (var a = this.at(r), h = 0; h < this.vertices.length; h++)
                if (this.canSee(r, h)) {
                    var l = this.at(h),
                        d = l.x - a.x,
                        c = l.y - a.y,
                        u = d * d * c * c;
                    u < s && (e = r, i = h, s = u)
                }
        }
    if (!n && 8 < this.vertices.length && (e = 0, i = Math.floor(this.vertices.length / 2), n = !0), n) {
        var p = this.subPolygon(e, i).decompose(t + 1),
            b = this.subPolygon(i, e).decompose(t + 1);
        o = p.concat(b)
    }
    return 0 === o.length && o.push(this.vertices), o
};
var __extends = this && this.__extends || function() {
    var o = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, e) {
        t.__proto__ = e
    } || function(t, e) {
        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
    };
    return function(t, e) {
        function i() {
            this.constructor = t
        }
        o(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
    }
}();
! function(i) {
    var t = function(t) {
        function e() {
            var e = t.call(this, {
                enableDebug: !1,
                width: ScaleManager.GameWidth,
                height: ScaleManager.GameHeight,
                renderer: Phaser.AUTO,
                parent: "content",
                transparent: !0,
                antialias: !0,
                preserveDrawingBuffer: !1,
                physicsConfig: null,
                seed: "",
                state: null,
                forceSetTimeOut: !1
            }) || this;
            return e.clearBeforeRender = !1, Phaser.Device.whenReady(function() {
                e.stage.disableVisibilityChange = !0;
                var t = e.device.desktop ? "click" : "touchstart";
                document.getElementById("content").addEventListener(t, function(t) {
                    e.gameResumed(t)
                })
            }), e.state.add("game", {
                create: e.stateCreator.bind(e),
                preload: e.statePreloader.bind(e)
            }, !0), e
        }
        return __extends(e, t), e.prototype.statePreloader = function() {
            var e = this;
            libs.forEach(function(t) {
                e.load.script(t, t)
            })
        }, e.prototype.stateCreator = function() {
            this.plugins.add(Fabrique.Plugins.GameEvents), this.plugins.add(PhaserCachebuster.CacheBuster), this.plugins.add(PhaserSpine.SpinePlugin), this.plugins.add(PhaserInput.Plugin), this.state.add("Boot", i.Boot), this.state.add(Fabrique.SplashScreen.Preloader.Name, Fabrique.SplashScreen.Preloader, !1), this.state.add("MainMenu", i.MainMenu), this.state.add("Level", i.Level), this.state.add("Game", i.GamePlay), this.state.add("StackEditor", i.StackEditor), this.state.start("Boot"), this.state.remove("game")
        }, e
    }(Phaser.Game);
    i.Game = t
}(Stracker || (Stracker = {}));
var Fabrique, Constants = function() {
        function t() {}
        return t.GAME_SCALE = 1, t.CALCULATED_WIDTH = 0, t.CALCULATED_HEIGHT = 0, t.GAME_WIDTH = 1280, t.GAME_HEIGHT = 720, t.LANDSCAPE_LOCKED = !1, t.PORTRAIT_LOCKED = !1, t.GAME_KEY = "65afb6f8b1d6e28adedba0fdfada12b3", t.SECRET_KEY = "11d25cfb80e0faa1fab140c041c099d930969adf", t.GOOGLE_ID = "UA-78960661-46", t.GOOGLE_APP_NAME = "Super Stacker 3", t.GAMEDISTRIBUTION_ID = "24a0c78387584aa3920886e6f1fec301", t.GAMEDISTRIBUTION_USER = "ABD36C6C-E74B-4BA7-BE87-0AB01F98D30D-s1", t
    }(),
    FadeInOut = function() {
        function e(t) {
            this.fadeColor = 0, this.game = t
        }
        return e.init = function(t) {
            e.instance = new e(t)
        }, e.prototype.fadeTo = function(t) {
            if (this.game.renderType != Phaser.CANVAS) {
                this.createBkg(), this.spr_bg.alpha = 0, this.nextState = t, this.game.add.existing(this.spr_bg);
                var e = this.game.add.tween(this.spr_bg);
                e.to({
                    alpha: 1
                }, 500, null), e.onComplete.add(this.changeState, this), e.start()
            } else this.game.state.start(t)
        }, e.prototype.createBkg = function() {
            this.spr_bg = this.game.make.graphics(0, 0), this.spr_bg.beginFill(this.fadeColor, 1), this.spr_bg.drawRect(ScaleManager.bkgX(), ScaleManager.bkgY(), ScaleManager.MaxWidth, ScaleManager.MaxHeight), this.spr_bg.endFill()
        }, e.prototype.changeState = function() {
            this.game.state.start(this.nextState)
        }, e.prototype.fadeOut = function() {
            this.createBkg(), this.spr_bg.alpha = 1, this.game.add.existing(this.spr_bg);
            var t = this.game.add.tween(this.spr_bg);
            t.to({
                alpha: 0
            }, 500, null), t.start()
        }, e
    }(),
    NineImage = function() {
        function d() {}
        return d.create = function(t, e, i, o, s, n, r, a, h, l) {
            return void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = !1), d._image = t.cache.getImage(o), d._frame = "string" == typeof s ? t.cache.getFrameByName(o, s) : t.cache.getFrameByIndex(o, s), d.calculateNineImage(e, i, n, r, a, h, l), d._nineImage = new Phaser.BitmapData(t, "NineImage" + d._textureKey++, d._width, d._height), d.renderNineImage(), d._nineImage
        }, d.calculateNineImage = function(t, e, i, o, s, n, r) {
            var a = d._frame;
            if (d._centralWidth = a.width - o - n, d._centralHeight = a.height - i - s, r) d._horizontalRepeats = t, d._verticalRepeats = e, d._width = o + n + d._centralWidth * t, d._height = i + s + d._centralHeight * e, d._lastWidth = 0, d._lastHeight = 0;
            else {
                var h = t - o - n;
                d._horizontalRepeats = Math.floor(h / d._centralWidth), d._lastWidth = h % d._centralWidth;
                var l = e - i - s;
                d._verticalRepeats = Math.floor(l / d._centralHeight), d._lastHeight = l % d._centralHeight, d._width = t, d._height = e
            }
            d._leftWidth = o, d._rightWidth = n, d._topHeight = i, d._bottomHeight = s
        }, d.renderNineImage = function() {
            var t = d._frame.y,
                e = 0;
            0 < d._topHeight && (d.renderNineImageRow(d._image, t, e, d._topHeight), t += d._topHeight, e += d._topHeight);
            for (var i = 0; i < d._verticalRepeats; i++) d.renderNineImageRow(d._image, t, e, d._centralHeight), e += d._centralHeight;
            0 < d._lastHeight && (d.renderNineImageRow(d._image, t, e, d._lastHeight), e += d._lastHeight), t += d._centralHeight, 0 < d._bottomHeight && d.renderNineImageRow(d._image, t, e, d._bottomHeight)
        }, d.renderNineImageRow = function(t, e, i, o) {
            var s = d._frame.x,
                n = 0;
            0 < d._leftWidth && (d._nineImage.copy(t, s, e, d._leftWidth, o, n, i), n += d._leftWidth, s += d._leftWidth);
            for (var r = 0; r < d._horizontalRepeats; r++) d._nineImage.copy(t, s, e, d._centralWidth, o, n, i), n += d._centralWidth;
            0 < d._lastWidth && (d._nineImage.copy(t, s, e, d._lastWidth, o, n, i), n += d._lastWidth), s += d._centralWidth, 0 < d._rightWidth && d._nineImage.copy(t, s, e, d._rightWidth, o, n, i)
        }, d._textureKey = 0, d
    }(),
    ScaleManager = function() {
        function s() {}
        return s.init = function(t) {
            s.game = t, this.onResize = new Phaser.Signal, t.scale.pageAlignHorizontally = !0, t.scale.pageAlignVertically = !0, t.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, window.onresize = function() {
                s.SizeCalculation(t)
            }, s.SizeCalculation(t)
        }, s.SizeCalculation = function(t) {
            var e, i, o = Math.min(window.innerWidth / s.GameWidth, window.innerHeight / s.GameHeight);
            document.getElementById("content").style.minHeight = window.innerHeight.toString() + "px", e = window.innerWidth / o, i = window.innerHeight / o, t.scale.setUserScale(o, o, 0, 0), t.scale.setGameSize(e, i), t.world.setBounds(0, 0, e, i), t.scale.refresh(), this.scale = o, this.onResize.dispatch()
        }, s.bkgX = function() {
            return (s.GameWidth - s.MaxWidth) / 2
        }, s.bkgY = function() {
            return (s.GameHeight - s.MaxHeight) / 2
        }, s.by = function(t) {
            return s.GameWidth / 2 - (s.GameWidth / 2 - t)
        }, s.handleIncorrect = function() {
            s.game.device.desktop || (document.getElementById("turn").style.display = "block", s.game.world.isPaused = !0)
        }, s.handleCorrect = function() {
            s.game.device.desktop || (document.getElementById("turn").style.display = "none", s.game.world.isPaused = !1), setTimeout("window.scrollTo(0,0)", 1e3)
        }, s.GameWidth = 600, s.GameHeight = 550, s.MaxWidth = 1440, s.MaxHeight = 1457, s
    }();
! function(t) {
    var e = function() {
        function t() {}
        return t.show = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "block")
        }, t.hide = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "none")
        }, t
    }();
    t.LoaderHelper = e
}(Fabrique || (Fabrique = {})),
function(y) {
    var t = function() {
        function t() {}
        return t.getFigures = function(t, e, i, o) {
            var s;
            void 0 === o && (o = !1), s = i ? o ? y.GameAPI.STATICDATA : this.LVLCODES[e].split("/")[1].split("_")[0] : o ? y.GameAPI.DYNAMICDATA : this.LVLCODES[e].split("/")[1].split("_")[1];
            for (var n = [], r = 0; s.length > r;) {
                var a = this.getType(s[r]),
                    h = this.getNumber(s[++r], s[++r]),
                    l = this.getNumber(s[++r], s[++r]),
                    d = this.getNumber(s[++r], s[++r]);
                if (i) {
                    var c = this.getNumber(s[++r], s[++r]),
                        u = this.getNumber(s[++r], s[++r]);
                    (m = y.GameAPI.getSprite(t, a, h, l, !1, !1, !1, !0)).x = c, m.angle = d, m.y = u, n.unshift(m)
                } else
                    for (var p = this.getNumber("0", s[++r]), b = 0; b < p; ++b) {
                        var m;
                        (m = y.GameAPI.getSprite(t, a, h, l, !1)).angle = d, n.push(m)
                    }
                r++
            }
            return n
        }, t.getDynamicFigures = function() {
            for (var t = y.GameAPI.DYNAMICDATA, e = [], i = 0; t.length > i;) {
                var o = this.getType(t[i]),
                    s = this.getNumber(t[++i], t[++i]),
                    n = this.getNumber(t[++i], t[++i]),
                    r = this.getNumber(t[++i], t[++i]),
                    a = this.getNumber("0", t[++i]),
                    h = new y.DataQueue;
                h.width = s, h.height = n, h.angle = r, h.count = a, h.figureType = o, e.push(h), i++
            }
            return e
        }, t.getBackgroundText = function(t) {
            return this.LVLCODES[t].split("/")[0]
        }, t.getType = function(t) {
            switch (t) {
                case "r":
                    return "cube";
                case "t":
                    return "triangle";
                case "c":
                    return "circle"
            }
        }, t.getNumber = function(t, e) {
            var i = 62 * +t;
            return i += this.LISTCHARS.indexOf(e)
        }, t.setType = function(t) {
            switch (t) {
                case "cube":
                    return "r";
                case "triangle":
                    return "t";
                case "circle":
                    return "c"
            }
        }, t.setNumber = function(t, e) {
            void 0 === e && (e = !1);
            var i = "";
            if (!e) {
                var o = Math.floor(t / 62);
                i = this.LISTCHARS[o], t -= Math.floor(62 * o)
            }
            return i += this.LISTCHARS[t]
        }, t.getStaticCode = function(t, e, i, o, s, n) {
            var r;
            return r = this.setType(t), r += this.setNumber(e), r += this.setNumber(i), r += this.setNumber(o), r += this.setNumber(s), r += this.setNumber(n)
        }, t.getDynamicCode = function(t, e, i, o, s) {
            var n;
            return n = this.setType(t), n += this.setNumber(e), n += this.setNumber(i), n += this.setNumber(o), n += this.setNumber(s, !0)
        }, t.LISTCHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", t.LVLCODES = ["Please Stack the Shapes/r470J004O8i_r1s1s002r1d1d002r0Y0Y002r0J0J002", "Up Up and Away/t0Y0Y1s2b4Qt0Y0Y007v4Qr1d0J004Q8X_r0Y0Y003r3o0u001c1d1d005r1s1s003", "Neat/r0Y0u004Q6Mr0u0u551W5kr0u0u0J7K5k_t1W1W3D1t1W1W0J2t1W1W3D2t1W1W0J1", "Architect/t0Y0Y3D5O8et0Y0Y3D3S8et0Y0Y3D3S5kt0Y0Y3D5O5k_c0O0O002r6i0z002t0J0J3D4c0O0O00a", "Slow Rollers/r470u5N8e2Ur470u011s2Ur1s0u004Q8I_c1d1d002r1d1d006t1s1s3D1", "Empire State Building/r220J004Q80_t0Y0Y001t0Y0Y1s1r1d1d0J1t0S0S4m1t0S0S2U1t0O0O001t0O0O1s1r0Y0Y0J1t0G0G4m1t0G0G2U1t0C0C001t0C0C1s1r0M0M0J1t0y0y4m1t0y0y2U1t0J0J3D1", "Bobble Head/r2q0f00557g_r0J0J007r2F2F001", "Happy in a Box/r4Q0J004Z7y_r0Y0Y006c2U2U001r3o0J001t0Y0Y001t0Y0Y2U1t0Y0Y001t0Y0Y2U1t0Y0Y001t0Y0Y2U1", "Leaning Tower of Pizza Rolls/r2q0J054D83_r0J0J05ot2q2q3I1", "Wedge Stop/r4Q0J004Z7y_c1s1s001c0Y0Y001t0u0u001r4Q0J001", "Mouse/r0Y0u006M5Or0Y0u002U5O_r0T0T004c3434001c1H1H002", "Tumble/c0u0u003o1Wc0u0u005k3Sc0u0u003o5Oc0u0u005k7Kc0u0u007Z8Xc0u0u002q8X_r1x1x001r6x0u001", "Kung Fu Splits/c0u0u001W7Zc0u0u007K7Zc0u0u004Q6x_r0J3e002t1d1d0J1r1d1d001r3S0u001r0u0u002c1s1s001", "Happy Family/r1H0u007g8er0Y0u004Q8er1H0u002q8e_c1s1s003r0Y0Y006r6i0Y001t1s1s3D3t1s1s0J2t1s1s3D2t1s1s0J1t1s1s3D1", "Long Legs/r0Y0u083o7Zr0Y0u5G5O7Z_r0J0J085r0J0J5G5c2q2q001", "Hay Bale Roof/c0f0f007K4mc0f0f004Q4mc0f0f001W4mr1d0u006i8er1d0u003o8e_r0Y0Y006t1d1d3D2c1d1d00a", "Room for Everyone/r0Y0Y556M6Mr0Y0Y554Q6Mr0Y0Y552U6M_r390Y0J1r390Y551c0J0J00k", "10 Tourists (in a Pyramid)/r7g0f004Q8t_t0Y0Y3D5c0z0z004t0Y0Y3D4c0z0z003t0Y0Y3D3c0z0z002t0Y0Y3D2c0z0z001t0Y0Y3D1", "Make a Level Surface/r0J2U556i6Mr0J2U0J396Mc0f0f0J1d7gc0f0f0J8e7g_r12120J2t0Y0Y0J1r1212552t0Y0Y0J1t18180J1c0Y0Y003r4Q0u001r121200at1H1H3D1", "Rungs/c0u0u004B6ic0u0u004B4Bc0u0u004B7Zc0u0u004B2U_r3S1d003r0Y0Y003c0Y0Y003", "Counterbalance/c0f0f001d47c0f0f004Q5k_r8I0u001c0J0J003r0J0J001", "Work Smarter not Harder/c0u0u004Q5kc0u0u001W6Mc0u0u007K6M_r840u001r1d1d00a", "Tumblers/t1s1s005O1Ht1s1s005z4Bt1s1s005z7gt1s1s1s3D39t1s1s1s3D63r0f0f00477Zr0f0f000J7Z_c0f0f003r3S0f001t0u0u1s1", "Level Surface 2/t0Y0Y3D7g4Qt0Y0Y3D4Q4Qt0Y0Y3D2q4Q_r0Y0Y552r0u0u0J4r0f0f558r630u001c1d1d003", "The Incredible Wobbling Man/r0Y0u083o8tr0Y0u5G5O8t_r0J0J085r0J0J5G5r1H1H001r6x0u001r0J0J002c2q2q001", "Double Cantilever/r0Y0u005O8Ic0f0f007g63c0f0f001t3L_r0T0T002r7v0u001r0T0T002r7v0u001r0J0J001c1O1O007", "Remember to Tip/c0f0f000Y8ec0f0f003o8ec0f0f006i8ec0f0f008I8ec0f0f004Q5O_r0J3D002r0J0J00kt3D3D001t3D3D1s1c2U2U002", "A Little Support Please/c1d1d004Q5kr1d0f000G8m_r9G0u001r1d1d003c0J0J006", "Chequered/r0Y0Y002U4Qr0Y0Y002U6Mr0Y0Y003S5Or0Y0Y004Q4Qr0Y0Y004Q6Mr0Y0Y005O5Or0Y0Y006M4Qr0Y0Y006M6M_r0J0J003c0J0J003r3o0W002t0J0J3D5t0J0J0J5", "Puzzle/c0u0u007K3Sc0u0u005O3Sc0u0u003S3Sc0u0u001W3Sc0u0u005O5Oc0u0u003S5O_t1s1s0J2t1s1s3D1c0Y0Y003r0J0J002", "Spirit Level/r1d0u00718tr1d0u002F6x_r0Y0Y00ar4Q0J001c0J0J001", "ez Ballies/r1d0J002q8er1d0J007g8er1d0J004Q8e_r1s1s003t0J0J003t0J0J1s3c0u0u009", "The Supreme Leader/r0Y0Y554Q8tr0Y0Y552U7Zr0Y0Y556M7Z_r390Y0J1r390Y551r0Y0Y551r390Y0J1r390Y551r0Y0Y551r390Y0J1r390Y551r0Y0Y551r390Y0J1r390Y551r0Y0Y551r390Y0J1r390Y551c2b2b001", "Temple/r0Y0Y001W7gr0Y0Y002U6ir0Y0Y003S5kr0Y0Y004Q4mr0Y0Y005O5kr0Y0Y006M6ir0Y0Y007K7g_t0J0J003t0J0J3D1t0J0J1s3c0J0J006", "Big W/r2b0J553D63r2b0J0J5O63r2b0J0J1d63r2b0J558e63_t0Y0Y0J2t0Y0Y4m2t0Y0Y2U2r1d1d00q", "Tricky/c0u0u004B6ic0u0u004B4Bc0u0u004B2U_r4L0Y002r0Y0Y003", "Block/r1s0u0u107qr0u1W000n5Er1W0u5k4l7hr0u1W00595pr5Y0u5N7c3vr0u0Y009I2x_c0k0k001c0u0u001c0E0E001c0O0O001c0Y0Y001c1818001c1i1i001c1s1s001c1W1W001", "Right Foundation/r1d0u007v8tr1d0u001W6xr1d0u004Q6x_c1W1W002r3S0J001r0Y0Y001c0J0J00a", "Hard Ballies/r1d0J002q8er1d0J007g8er1d0J004Q8e_r1s1s003t0J0J003t0J0J1s3c0u0u00p", "Space Invader/r0Y0Y006M7Kr0Y0Y002U7Kr0Y0Y005O6Mr0Y0Y003S6Mr0Y1W004Q5kt0Y0Y004755t0Y0Y1s5z55_c0Y0Y003r2U0W002r0Y0Y00a", ""], t
    }();
    y.EncryptionLogic = t
}(Stracker || (Stracker = {}));
var Music = function() {
        function t(t) {
            this.game = t, this.lowscream = this.game.make.audio("lowscreamaudio", 1), this.middlescream = this.game.make.audio("middlescreamaudio", 1), this.bigscream = this.game.make.audio("bigscreamaudio", 1), this.music = this.game.make.audio("musicaudio", 1), this.jazz = this.game.make.audio("jazzaudio", 1), this.cat = this.game.make.audio("cataudio", 1), this.figure = this.game.make.audio("figureaudio", 1), this.failed = this.game.make.audio("failedaudio", 1), this.clock = this.game.make.audio("clockaudio", 1), this.success = this.game.make.audio("successaudio", 1), this.speak = this.game.make.audio("speakaudio", 1);
            var e = SaveAPI.getAccess(SaveAPI.SOUND);
            null == e && (e = !0), this.SoundActive = e;
            var i = SaveAPI.getAccess(SaveAPI.MUSIC);
            null == i && (i = !0), this.MusicActive = i
        }
        return t.prototype.playMusic = function() {
            this.MusicActive && (this.music.play(), this.music.resume())
        }, t.prototype.musicStopped = function() {
            this.game.add.tween(this.music).to({
                volume: 0
            }, 500, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.jazz).to({
                volume: 0
            }, 500, Phaser.Easing.Linear.None, !0)
        }, t.prototype.getNameObject = function(t) {
            if ("music" == t) {
                if (this.MusicActive) return "musicOn.png";
                if (!this.MusicActive) return "musicOff.png"
            }
            if ("sound" == t) {
                if (this.SoundActive) return "soundOn.png";
                if (!this.SoundActive) return "soundOff.png"
            }
        }, t.prototype.statusSound = function(t, e, i, o) {
            void 0 === o && (o = "sound"), "sound" == o && (this.SoundActive = !this.SoundActive, SaveAPI.setForce(SaveAPI.SOUND, this.SoundActive), t.frameName = this.getNameObject(o)), "music" == o && (this.MusicActive = !this.MusicActive, SaveAPI.setForce(SaveAPI.MUSIC, this.MusicActive), t.frameName = this.getNameObject(o), this.MusicActive || this.musicStopped(), this.MusicActive && (this.music.isPlaying ? this.game.add.tween(this.music).to({
                volume: 1
            }, 500, Phaser.Easing.Linear.None, !0) : this.playMusic()))
        }, t.prototype.audioEffects = function(t) {
            this.SoundActive && (t.isPlaying || t.play())
        }, t.prototype.startMusic = function(t) {
            this.MusicActive && (t.isPlaying || t.play())
        }, t.prototype.playAudio = function(t) {
            this.SoundActive && t.play()
        }, t.prototype.stopAudio = function(t) {
            this.SoundActive && t.isPlaying && t.stop()
        }, t
    }(),
    Splash = function() {
        function t(t) {
            this.game = t
        }
        return t.prototype.create = function() {
            this.splash = this.game.add.sprite(10, 0, "FG_splash"), this.splash.anchor.setTo(.52, .5), this.splash.inputEnabled = !0, this.splash.events.onInputUp.add(ExternalLinks.onClickMoreGames, this), this.splash.width -= 300;
            var t = this.game.time.create(!0);
            t.add(3e3, this.goToMenuAfterDelay, this), t.start(), FadeInOut.init(this.game), FadeInOut.instance.fadeOut(), ScaleManager.onResize.add(this.rescale, this), ScaleManager.SizeCalculation(this.game)
        }, t.prototype.shutdown = function() {
            ScaleManager.onResize.remove(this.rescale, this)
        }, t.prototype.rescale = function() {
            this.splash.x = this.game.world.width / 2, this.splash.y = this.game.world.height / 2
        }, t.prototype.goToMenuAfterDelay = function() {
            var t = this,
                e = document.location.href.split("?");
            if (null != e[1]) {
                var i = (e = e[1].split("level="))[0];
                null != e[1] && (i = (e = e[1].split("&"))[0]), null != i && (Stracker.GamePlay.gameTime = 0, Stracker.GameAPI.STATICDATA = i.split("_")[0], Stracker.GameAPI.DYNAMICDATA = i.split("_")[1], Fabrique.LoaderHelper.show(), this.game.ads.onContentPaused.addOnce(function() {
                    Fabrique.LoaderHelper.hide()
                }), this.game.ads.onContentResumed.addOnce(function() {
                    Fabrique.LoaderHelper.hide(), t.game.ads.onContentPaused.removeAll(), t.game.ads.onContentResumed.removeAll(), t.game.state.start("Game", !0, !1, 1, !1, !1, !0)
                }), this.game.ads.showAd())
            } else FadeInOut.instance.fadeTo("MainMenu")
        }, t
    }(),
    SponsorLogo = function(s) {
        function n(t, e, i) {
            var o = s.call(this, t, e, i, n.KEY, n.LOGO_FRAME) || this;
            return o.inputEnabled = !0, o.input.useHandCursor = !0, o.events.onInputUp.add(ExternalLinks.onClickMoreGames, o), o
        }
        return __extends(n, s), n.KEY = "atlas", n.LOGO_FRAME = "fgLogo.png", n
    }(Phaser.Sprite);
! function(t) {
    var e = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return __extends(e, t), e.prototype.preload = function() {
            var t = this;
            var e = Date.now();
            window.addEventListener("beforeunload", function() {
                t.game.analytics.game.addEvent(new GA.Events.SessionEnd((Date.now() - e) / 1e3)), t.game.analytics.game.sendEvents()
            }), this.game.input.maxPointers = 1, this.game.canvas.oncontextmenu = function(t) {
                t.preventDefault()
            };

            window.hasOwnProperty("fbrqSA") && !0 === window.fbrqSA && (Fabrique.Utils.ASSET_LOCATION = "assets/")
        }, e.prototype.create = function() {
            var t = this;
            this.game.load.cacheBuster = "undefined" == typeof version ? null : version, ScaleManager.init(this.game), this.input.maxPointers = 1, this.game.canvas.oncontextmenu = function(t) {
                t.preventDefault()
            }, this.game.device.desktop && (this.game.scale.setGameSize(window.innerWidth, window.innerHeight), this.game.scale.setUserScale(1, 1)), Fabrique.LoaderHelper.hide(), this.game.state.start(Fabrique.SplashScreen.Preloader.Name, !0, !1, {
                nextState: "MainMenu",
                showPlayButton: !window.hasOwnProperty("playBtn") || window.playBtn,
                mobilePlayClickhandler: function() {
                    t.game.state.start("MainMenu")

                },
                preloadHandler: function() {
                    Fabrique.Branding.preloadImages(t.game), Fabrique.Branding.outGoingLinksAllowed() && Fabrique.MoreGames.Menu.preloadImages(t.game), t.game.stage.disableVisibilityChange = !1, t.sound.muteOnPause = !0, t.load.image("homepage", "assets/images/Backgrounds/fgLogo.png"), t.load.image("front", "assets/images/Backgrounds/fron.png"), t.load.image("back", "assets/images/Backgrounds/back.png"), t.load.image("backgroundMenu", "assets/images/Backgrounds/backgroundMenu.jpg"), t.load.image("backgroundLine", "assets/images/Backgrounds/backgroundLine.png"), t.load.image("border", "assets/images/Backgrounds/border.png"), t.load.image("bkgmessage", "assets/images/Backgrounds/bkgmessage.png"), t.load.image("bigborder", "assets/images/Backgrounds/bigborder.png"), t.load.image("FG_splash", "assets/images/Backgrounds/FG_splash.jpg"), t.load.image("bkgQueue", "assets/images/Backgrounds/fon.png"), t.load.image("bkgline", "assets/images/Backgrounds/bkgline.png"), t.load.image("help", "assets/images/helpOn.png"), t.load.image("new_logo", "assets/images/new-logo.png"), t.load.image("r_nf_h", "assets/images/r_nf_h.png"), t.load.image("r_nf_v", "assets/images/r_nf_v.png"), t.load.image("rf_nf_h", "assets/images/rf_nf_h.png"), t.load.image("rf_nf_v", "assets/images/rf_nf_v.png"), t.load.image("rf_nf", "assets/images/rf_nf.png"), t.load.image("c_nf", "assets/images/c_nf.png"), t.load.image("rmin_nf_h", "assets/images/rmin_nf_h.png"), t.load.image("rmin_nf_v", "assets/images/rmin_nf_v.png"), t.load.image("ls_logo", "assets/images/strackerpurple.png"), t.load.image("msg_box", "assets/images/n_msg_box.png"), t.load.image("succ", "assets/images/n_succ.png"), t.load.image("b_ls", "assets/images/n_b_levelselect.png"), t.load.image("b_next_big", "assets/images/n_b_next_big.png"), t.load.image("b_next", "assets/images/n_b_next.png"), t.load.image("b_next_dead", "assets/images/n_b_next_dead.png"), t.load.image("b_retry_big", "assets/images/n_b_retry_big.png"), t.load.image("b_retry", "assets/images/n_b_retry.png"), t.load.image("mm_play", "assets/images/n_m_play.png"), t.load.image("mm_more", "assets/images/n_m_more.png"), t.load.image("kizi", "assets/images/n_kizi.png"), t.load.image("ls1", "assets/images/selectedlevel1.png"), t.load.image("ls2", "assets/images/selectedlevel2.png"), t.load.image("ls4", "assets/images/selectedlevel4.png"), t.load.image("ls5", "assets/images/selectedlevel5.png"), t.load.image("ls6", "assets/images/selectedlevel6.png"), t.load.image("ls7", "assets/images/selectedlevel7.png"), t.game.load.atlasXML("atlas", "assets/images/superstracker.png", "assets/images/superstracker.xml"), t.game.load.bitmapFont("MaindraBlackSmall", "assets/font/MaindraBlackSmall.png", "assets/font/MaindraBlackSmall.fnt"), t.game.load.bitmapFont("MaindraBlackStroke", "assets/font/MaindraBlackStroke.png", "assets/font/MaindraBlackStroke.fnt"), t.game.load.bitmapFont("MaindraBlack", "assets/font/MaindraBlack.png", "assets/font/MaindraBlack.fnt"), t.game.load.bitmapFont("MaiandraGDwhite", "assets/font/Maiandra GD white.png", "assets/font/Maiandra GD white.fnt"), t.game.load.bitmapFont("Maiandra16", "assets/font/Maindra16.png", "assets/font/Maindra16.fnt"), t.game.load.bitmapFont("MaiandraGDStroke", "assets/font/MaiandraGDStroke.png", "assets/font/MaiandraGDStroke.fnt"), t.game.load.bitmapFont("CookiesStroke", "assets/font/CookiesStroke.png", "assets/font/CookiesStroke.fnt"), t.game.load.bitmapFont("Cookieswhite", "assets/font/Cookieswhite.png", "assets/font/Cookieswhite.fnt"), t.game.load.bitmapFont("Cookies", "assets/font/Cookies.png", "assets/font/Cookies.fnt"), t.game.load.bitmapFont("Segoi", "assets/font/Segoi.png", "assets/font/Segoi.fnt"), t.load.audio("lowscreamaudio", ["assets/sound/sound 373.mp3", "assets/sound/sound 373.ogg"]), t.load.audio("middlescreamaudio", ["assets/sound/sound 372.mp3", "assets/sound/sound 372.ogg"]), t.load.audio("bigscreamaudio", ["assets/sound/sound 371.mp3", "assets/sound/sound 371.ogg"]), t.load.audio("cataudio", ["assets/sound/sound 370.mp3", "assets/sound/sound 370.ogg"]), t.load.audio("musicaudio", ["assets/sound/sound 369.mp3", "assets/sound/sound 369.ogg"]), t.load.audio("jazzaudio", ["assets/sound/sound 368.mp3", "assets/sound/sound 368.ogg"]), t.load.audio("speakaudio", ["assets/sound/sound 367.mp3", "assets/sound/sound 367.ogg"]), t.load.audio("figureaudio", ["assets/sound/sound 366.mp3", "assets/sound/sound 366.ogg"]), t.load.audio("failedaudio", ["assets/sound/sound 365.mp3", "assets/sound/sound 365.ogg"]), t.load.audio("clockaudio", ["assets/sound/sound 364.mp3", "assets/sound/sound 364.ogg"]), t.load.audio("successaudio", ["assets/sound/sound 363.mp3", "assets/sound/sound 363.ogg"])
                }
            })
        }, e.inSplash = !0, e
    }(Phaser.State);
    t.Boot = e
}(Stracker || (Stracker = {})),
function(a) {
    var t = function(e) {
        function o() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.showClock = 0, t.instapassCU = 0, t.onMobile = !1, t.mOffX = -80, t.mOffY = -80, t.isOutOfBounds = !1, t
        }
        return __extends(o, e), o.prototype.init = function(t, e, i, o) {
            void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === o && (o = !1), this.game.device.desktop || (this.onMobile = !0), this.isCustomLevel = o, this.isCustomLevel ? this.stateLevel = 2 : this.stateLevel = a.Level.save.levelState[t], this.isSpeedrun = e, this.isBonusMode = i, this.levelNumber = t
        }, o.prototype.preload = function() {
            this.showClock = 0, this.instapassCU = 0, this.music = new Music(this.game), this.bkg = this.add.sprite(0, 0, "backgroundMenu"), this.isCustomLevel || (this.bkgText = a.GameAPI.createText(this.game, 310, 155, "CookiesStroke", a.EncryptionLogic.getBackgroundText(this.levelNumber), 30, 16777215, !0)), this.dynamicFigures = a.EncryptionLogic.getFigures(this.game, this.levelNumber, !1, this.isCustomLevel), this.staticFigures = a.EncryptionLogic.getFigures(this.game, this.levelNumber, !0, this.isCustomLevel), this.isBonusMode && this.dynamicFigures.sort(this.compareRandom), this.setTopArray(), this.pause = !1, this.success = !1, this.isCreated = !1, this.isStop = !1, this.isSleep = !1, this.xTop = 30, this.yTop = 25, this.timer = 0, this.isPlaying = !0, this.bkgMessage = this.game.add.sprite(0, 0, "bkgmessage"), this.bkgMessage.visible = !1, this.timesec = this.game.add.bitmapText(80, 540, "Cookieswhite", "0 seconds", 16), this.timesec.anchor.setTo(.5, .5);
            var t = this.levelNumber;
            this.isBonusMode ? (this.textLevel = this.game.add.bitmapText(this.game.world.width - 70, 540, "Cookieswhite", "BONUS " + ++t + "/40", 16), this.textLevel.tint = 65280) : this.textLevel = this.game.add.bitmapText(this.game.world.width - 70, 540, "Cookieswhite", "stack " + ++t + "/40", 16), this.textLevel.anchor.setTo(.5, .5), this.primeGroup = this.game.add.group(), this.topObjects = this.game.add.group(), this.staticGroup = this.game.add.group(), this.usedGroup = this.game.add.group(), this.placedGroup = this.game.add.group(), this.pauseGroup = this.game.add.group(), this.confirmationGroup = this.game.add.group(), this.successGroup = this.game.add.group(), this.primeGroup.add(this.timesec), this.primeGroup.add(this.textLevel), this.primeGroup.add(this.usedGroup), this.primeGroup.add(this.staticGroup), this.primeGroup.add(this.topObjects), this.primeGroup.add(this.placedGroup), this.primeGroup.add(this.bkgMessage)
        }, o.prototype.create = function() {
            var t = this;
            this.game.physics.startSystem(Phaser.Physics.BOX2D), this.game.physics.box2d.gravity.y = 300, this.game.physics.box2d.paused = !1, this.setTopBar(), this.setStaticLayer(), this.startDrag(), this.spriteTimer = this.game.add.sprite(this.xTop, this.yTop + 4, "atlas", "timer.png"), this.spriteTimer.anchor.setTo(.5, .5), this.topObjects.add(this.spriteTimer), this.spriteTimer.visible = !1, this.createPause(), this.createSuccess(), this.primeGroup.add(this.confirmationGroup);
            var e = a.GameAPI.createConfirmMessage(this.game, "Exit Speedrun", "Are you sure you want to quit the speedrun?", function() {
                t.game.state.start("Level", !0, !1, t.levelNumber, !1, 0, t.isBonusMode)
            }, this);
            this.confirmationGroup.add(e), this.confirmationGroup.visible = !1, this.customResize(), ScaleManager.onResize.add(this.rescale, this)
        }, o.prototype.update = function() {
            var e = this;
            if (this.isSleep = !0, this.placedGroup.forEach(function(t) {
                    t.y > e.game.world.height + t.height / 2 && e.onOutOfBounds(t)
                }, this), 0 != this.placedGroup.length)
                for (var t = 0; t < this.placedGroup.length; ++t) {
                    var i = this.placedGroup.getAt(t);
                    0 == i.body.velocity.y && 0 == i.body.velocity.x && 0 == i.body.angularVelocity ? null != i.body.sprite.animations.getAnimation("smile") && (i.body.sprite.animations.getAnimation("smile").frame = 1) : (this.isSleep = !1, null != i.body.sprite.animations.getAnimation("smile") && (i.body.sprite.animations.getAnimation("smile").frame = 0))
                }
            this.isStop || (o.gameTime += this.time.elapsed, this.timesec.setText(Math.floor(o.gameTime / 1e3) + " seconds")), this.pause ? (this.isSpeedrun || (o.gameTime = 0, this.timesec.setText(Math.floor(o.gameTime / 1e3) + " seconds")), this.success = !1, this.timer = 0, this.isCreated = !1, this.spriteTimer.angle = 0) : this.isCreated && (this.timer += this.time.elapsed, this.spriteTimer.angle += .0515 * this.time.elapsed, this.timer >= 7 * Phaser.Timer.SECOND ? this.passedLevel() : this.isSleep ? (30 < this.instapassCU && this.passedLevel(), this.instapassCU++) : this.instapassCU = 0)
        }, o.prototype.render = function() {}, o.prototype.shutdown = function() {
            ScaleManager.onResize.remove(this.rescale, this)
        }, o.prototype.rescale = function() {
            this.music.stopAudio(this.music.clock), this.game.state.start("Game", !0, !1, this.levelNumber, this.isSpeedrun, this.isBonusMode, this.isCustomLevel)
        }, o.prototype.customResize = function() {
            null != this.bkgText && (this.bkgText.y = this.game.world.height / 2 - (ScaleManager.GameHeight / 2 - this.bkgText.y), this.bkgText.x = this.game.world.width / 2 - (ScaleManager.GameWidth / 2 - this.bkgText.x)), this.bkg.width = this.game.world.width, this.bkg.height = this.game.world.height, this.pauseGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.pauseGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.successGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.successGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.confirmationGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.confirmationGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.topLine.width = this.game.world.width, this.textLevel.x = this.game.world.width - 10 - this.textLevel.width, this.timesec.y = this.game.world.height - 10 - this.timesec.height, this.textLevel.y = this.game.world.height - 10 - this.textLevel.height, this.bkgMessage.width = this.game.world.width, this.bkgMessage.height = this.game.world.height
        }, o.prototype.setTopArray = function() {
            var s = this;
            this.topFigures = [], this.dynamicFigures.forEach(function(t, e, i) {
                var o = a.GameAPI.getSprite(s.game, t.name, t.width, t.height, !0, !0);
                o.angle = t.angle, s.topFigures.push(o)
            }, this)
        }, o.prototype.compareRandom = function(t, e) {
            return Math.random() - .5
        }, o.prototype.createPause = function() {
            this.primeGroup.add(this.pauseGroup), this.pauseGroup.create(290, 250, "atlas", "bkgfiled.png").anchor.setTo(.5, .5);
            var t = this.add.button(185, 310, "b_ls", this.onContinueClick, this, 0, 0, 0);
            this.pauseGroup.add(t);
            var e = this.add.button(255, 305, "b_retry_big", this.resetGame, this, 0, 0, 0);
            this.pauseGroup.add(e), this.pauseGroup.visible = !1
        }, o.prototype.createSuccess = function() {
            var e = this;
            if (this.isCustomLevel) {
                this.primeGroup.add(this.successGroup), this.successGroup.create(290, 290, "atlas", "bkgsuccesseditor.png").anchor.setTo(.5, .5);
                var t = a.GameAPI.createText(this.game, 290, 185, "Cookies", "Stack Successful!", 32, 16777215, !0);
                this.successGroup.add(t), i = a.GameAPI.createButtonWithText(this.game, 295, 240, "Edit Stack", function() {
                    e.game.state.start("StackEditor")
                }, this), this.successGroup.add(i);
                var i = a.GameAPI.createButtonWithText(this.game, 295, 290, "Share it", function() {
                    var t = a.GameAPI.createShare(e.game, function(t) {
                        t.parent.destroy(!0)
                    }, e);
                    e.successGroup.add(t)
                }, this);
                this.successGroup.add(i), i = a.GameAPI.createButtonWithText(this.game, 295, 340, "Main Menu", function() {
                    e.game.state.start("MainMenu")
                }, this), this.successGroup.add(i), this.successGroup.visible = !1
            } else {
                this.primeGroup.add(this.successGroup), this.successGroup.create(290, 100, "atlas", "bkgsuccesseditor.png").anchor.setTo(.5, .5);
                var o = this.add.button(184, 72, "b_ls", this.onContinueClick, this, 0, 0, 0);
                this.successGroup.add(o);
                var s = this.add.button(255, 67, "b_next_big", this.onNextClick, this, 0, 0, 0);
                this.successGroup.add(s);
                var n = this.add.button(338, 72, "b_retry", this.resetGame, this, 0, 0, 0);
                if (this.successGroup.add(n), Fabrique.Branding.outGoingLinksAllowed()) {
                    //var r = a.GameAPI.createButtonWithText(this.game, 295, 355, "More Games", ExternalLinks.onClickMoreGames, this);
                    //r.height = 40, r.width = 180, this.successGroup.add(r)
                }
                this.successGroup.visible = !1
            }
        }, o.prototype.onNextClick = function(t, e, i, o) {
            var s = this;
            9 == this.levelNumber || 19 == this.levelNumber || 29 == this.levelNumber || 39 == this.levelNumber ? this.game.state.start("Level", !0, !1, this.levelNumber, !1, 0, this.isBonusMode, this.stateLevel) : (this.levelNumber++, s.game.state.start("Game", !0, !1, s.levelNumber, s.isSpeedrun, s.isBonusMode, s.isCustomLevel))
        }, o.prototype.onContinueClick = function(t, e, i, o) {
            var s = this;
            3 < this.levelNumber ? s.game.state.start("Level", !0, !1, s.levelNumber, s.isSpeedrun, s.isBonusMode, s.isCustomLevel) : this.changeState(t.game)
        }, o.prototype.changeState = function(t) {
            this.isSpeedrun && 9 != this.levelNumber && 19 != this.levelNumber && 29 != this.levelNumber && 39 != this.levelNumber ? (this.levelNumber++, t.state.start("Game", !0, !1, this.levelNumber, this.isSpeedrun, this.isBonusMode, this.isCustomLevel)) : this.isSpeedrun ? t.state.start("Level", !0, !1, this.levelNumber, !0, o.gameTime, this.isBonusMode, this.stateLevel) : this.isSpeedrun || t.state.start("Level", !0, !1, this.levelNumber, !1, 0, this.isBonusMode, this.stateLevel)
        }, o.prototype.setTopBar = function() {
            this.topLine = this.game.add.sprite(0, -1, "backgroundLine"), a.GameAPI.setParameter(this.topLine, ScaleManager.GameWidth, 60, .6), this.usedGroup.add(this.topLine);
            var t = this.game.add.sprite(5, 4, "atlas", "selectFigure.png");
            a.GameAPI.setParameter(t, 50, 50, .6), this.usedGroup.add(t), this.topFigures.forEach(this.createMiniatureFigure, this)
        }, o.prototype.createMiniatureFigure = function(t, e, i) {
            var o = this.game.add.group(),
                s = this.dynamicFigures[e],
                n = a.GameAPI.createText(this.game, 0, 23, "MaindraBlackSmall", Math.floor(s.width) + " x " + Math.floor(s.height), 10);
            o.add(n), t.visible = !0, o.add(t), o.x = this.xTop, o.y = this.yTop, this.topObjects.add(o), this.xTop += 50
        }, o.prototype.setStaticLayer = function() {
            var o = this;
            this.game.add.group();
            this.staticFigures.forEach(function(t, e, i) {
                t.visible = !0, a.GameAPI.setParameter(t, t.width, t.height, 1, t.x, t.y), 23 == o.levelNumber ? t.y = o.game.world.height - ScaleManager.GameHeight + t.y : t.y = o.game.world.height / 2 - (ScaleManager.GameHeight / 2 - t.y), t.x = o.game.world.width / 2 - (ScaleManager.GameWidth / 2 - t.x), o.addPhysics(t, !0), t.body.static = !0, o.staticGroup.add(t)
            }, this)
        }, o.prototype.addPhysics = function(t, e) {
            void 0 === e && (e = !1), this.game.physics.box2d.enable(t), t = this.createBodySprite(t), e || a.GameAPI.addEye(t, this.game)
        }, o.prototype.startDrag = function() {
            this.moveFigure = this.setSprite(), this.game.device.desktop ? this.game.input.onDown.add(this.mouseDragEnd, this) : this.game.input.onUp.add(this.mouseDragEnd, this), this.game.input.addMoveCallback(this.mouseDrag, this)
        }, o.prototype.setSprite = function() {
            var t;
            return (t = this.dynamicFigures.shift()).visible = !0, a.GameAPI.setParameter(t, t.width, t.height, .5, this.game.input.worldX, this.game.input.worldY), t.angle = t.angle, this.onMobile ? (t.x = this.game.world.width / 2, t.y = this.game.world.height / 2) : (t.x = this.input.mousePointer.x, t.y = this.input.mousePointer.y), a.GameAPI.addEye(t, this.game), this.usedGroup.add(t), t
        }, o.prototype.mouseDrag = function(t, e, i) {
            null != this.moveFigure && (this.onMobile ? (this.moveFigure.x = t.worldX + this.mOffX, this.moveFigure.y = t.worldY + this.mOffY) : (this.moveFigure.x = t.worldX, this.moveFigure.y = t.worldY))
        }, o.prototype.mouseDragEnd = function(t) {
            if (!(null == this.moveFigure || this.game.input.worldX > this.game.world.width - 1 || this.game.input.worldX < 0 || this.game.input.worldY > this.game.world.height - 1 || this.game.input.worldY < 1)) {
                if (this.onMobile) var e = this.game.physics.box2d.getBodiesAtPoint(this.game.input.worldX + this.mOffX, this.game.input.worldY + this.mOffY);
                else e = this.game.physics.box2d.getBodiesAtPoint(this.game.input.worldX, this.game.input.worldY);
                0 != e.length || this.pause || (3 <= this.moveFigure.width / this.moveFigure.height || 3 <= this.moveFigure.height / this.moveFigure.width ? this.music.playAudio(this.music.figure) : (this.moveFigure.animations.stop("smile"), this.moveFigure.width <= 45 || this.moveFigure.height <= 45 ? this.music.playAudio(this.music.lowscream) : this.moveFigure.width <= 60 || this.moveFigure.height <= 60 ? this.music.playAudio(this.music.bigscream) : this.music.playAudio(this.music.middlescream)), this.moveFigure.alpha = 1, this.moveFigure.children.length = 0, this.game.physics.box2d.enable(this.moveFigure), this.addPhysics(this.moveFigure), this.placedGroup.add(this.moveFigure), 0 != this.dynamicFigures.length ? this.moveFigure = this.setSprite() : (this.isStop = !0, this.moveFigure = null, this.isCreated = !0, this.showClock++, this.music.audioEffects(this.music.clock)), null != this.topObjects && 0 != this.topObjects.length && (this.topObjects.remove(this.topObjects.getAt(0), !0), this.xTop = 30, this.topObjects.forEach(this.shiftLeft, this))), this.showClock < 1 ? this.spriteTimer.visible = !1 : this.spriteTimer.visible = !0
            }
        }, o.prototype.shiftLeft = function(t, e, i) {
            t.x = this.xTop, this.xTop < ScaleManager.GameWidth && (t.visible = !0), this.xTop += 50
        }, o.prototype.createBodySprite = function(t) {
            var e = t.body;
            if (e.angle = t.angle, e.clearFixtures(), "cube" == t.name) {
                var i = 0,
                    o = t.width - t.width * i,
                    s = t.height - t.height * i;
                e.addRectangle(o, s), t.width += .03 * t.width, t.height += .03 * t.height
            } else if ("triangle" == t.name) {
                i = 0;
                t.anchor.setTo(.75, .75);
                var n = t.width / 2 - t.width * i,
                    r = t.height / 2 - t.height * i;
                e.setPolygon([n - .25 * t.width, r - .25 * t.height, -(n - .02 * t.width) - .25 * t.width, r - .25 * t.height, n - .25 * t.width, -(r - .02 * t.height) - .25 * t.height, n - .25 * t.width, r - .25 * t.height]), t.width += .04 * t.width, t.height += .04 * t.height
            } else "circle" == t.name && e.setCircle(t.height / 2);
            return e.restitution = .2, e.friction = .5, e.world.density = 1e3, e.mass -= .8 * e.mass, e.linearDamping = .2, e.angularDamping = .2, e.setCollisionCategory(2), e.dynamic = !0, e.setCategoryContactCallback(2, this.contactCallback, this), t
        }, o.prototype.contactCallback = function(t, e, i, o, s) {}, o.prototype.passedLevel = function() {
            this.game.physics.box2d.paused = !0;
            var t = this.levelNumber;
            this.music.stopAudio(this.music.clock), this.music.audioEffects(this.music.success), this.isCreated = !1, this.success = !0, this.bkgMessage.visible = !0, this.successGroup.visible = !0, this.isCustomLevel || (null == a.Level.save || a.Level.save.bonusMode || (a.Level.save.levelState[this.levelNumber] = 2, 39 != this.levelNumber && 0 == a.Level.save.levelState[this.levelNumber + 1] && (a.Level.save.levelState[this.levelNumber + 1] = 1), 39 != this.levelNumber || a.Level.save.bonusMode || (a.Level.save.bonusMode = !0)), this.isBonusMode && (a.Level.save.levelState[this.levelNumber] = 3), SaveAPI.setForce(SaveAPI.SAVE_DATA, JSON.stringify(SaveAPI.GAME_SAVE)))
        }, o.prototype.onOutOfBounds = function(t) {
            if (!this.success && t.y > ScaleManager.GameHeight) {
                var e = this.levelNumber;
                e++, this.sendFailLevelData(e), this.pauseGroup.visible = !0, this.bkgMessage.visible = !0, this.music.stopAudio(this.music.clock), this.isStop = !0, this.pause = !0, this.isPlaying && (this.music.audioEffects(this.music.failed), this.isPlaying = !1)
            }
        }, o.prototype.sendFailLevelData = function(t) {
            this.isOutOfBounds = !0
        }, o.prototype.resetGame = function() {
            this.game.state.start("Game", !0, !1, this.levelNumber, this.isSpeedrun, this.isBonusMode, this.isCustomLevel)
        }, o.gameTime = 0, o
    }(Phaser.State);
    a.GamePlay = t
}(Stracker || (Stracker = {})),
function(h) {
    var t = function(e) {
        function a() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.isSpeedrun = !1, t
        }
        return __extends(a, e), a.prototype.init = function(t, e, i, o, s) {
            var n;
            if (void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === i && (i = 0), void 0 === o && (o = !1), void 0 === s && (s = 0), null == (a.save = JSON.parse(SaveAPI.getAccess(SaveAPI.SAVE_DATA))) && (a.save = SaveAPI.generateDefaultData()), this.isBonusMode = o, t < 10 ? (0, n = "PACK 1") : t < 20 ? (1, n = "PACK 2") : t < 30 ? (2, n = "PACK 3") : t < 40 && (3, n = "PACK 4"), e);
            else if (2 == a.save.levelState[t] && 1 == s) {
                if (9 == t) {
                    var r = n + ".  Nice work!\n\nBut can you beat PACK 2?";
                    this.successLevel(h.music.jazz, r)
                }
                if (19 == t) {
                    r = n + ".  Awesome Job!\n\nOn to PACK 3!";
                    this.successLevel(h.music.music, r)
                }
                if (29 == t) {
                    r = n + ".\n\nYou can really stack!  One pack left...";
                    this.successLevel(h.music.jazz, r)
                }
                if (39 == t) {
                    r = n + '.\nYou\'re a stacking genius!!!\n\nYou have now unlocked "Bonus Mode". Turn it\non and see what happens :)';
                    this.successLevel(h.music.music, r)
                }
            }
            SaveAPI.GAME_SAVE = a.save, SaveAPI.setForce(SaveAPI.SAVE_DATA, JSON.stringify(SaveAPI.GAME_SAVE))
        }, a.prototype.successLevel = function(t, e) {
            this.globalGroup = this.add.group(), this.game.sound.stopAll(), h.music.startMusic(t), this.globalGroup.add(h.GameAPI.createMessage(this.game, "WELL DONE", "You have beaten " + e, function() {
                this.globalGroup.visible = !1, this.bkgMessage.visible = !1
            }, this)), this.globalGroup.visible = !1
        }, a.prototype.preload = function() {
            this.backGroup = this.add.group(), this.bkg = this.game.add.sprite(0, 0, "backgroundMenu"), this.primeGroup = this.game.add.group();
            var t = this.game.add.sprite(28, -5, "ls_logo");
            this.primeGroup.add(t), this.nameLevel = h.GameAPI.createText(this.game, 290, 135, "MaiandraGDwhite", "", 30, 16777215), this.primeGroup.add(this.nameLevel)
        }, a.prototype.getTime = function(t) {
            if (0 == t) return "?";
            var e = t / 1e3,
                i = e / 60;
            return (e -= 60 * Math.floor(i)) < 10 ? Math.floor(i) + ":0" + Math.floor(e) : Math.floor(i) + ":" + Math.floor(e)
        }, a.prototype.startSpeedrun = function(t, e, i, o) {
            h.GamePlay.gameTime = 0, this.game.state.start("Game", !0, !1, o[0], !0, this.isBonusMode)
        }, a.prototype.create = function() {
            this.backGroup = this.game.add.group(), this.createLevels(), this.createBottomText(), this.backGroup.add(this.primeGroup), null != this.globalGroup && 0 != this.globalGroup.children.length && (this.bkgMessage = this.game.add.sprite(0, 0, "bkgmessage"), this.backGroup.add(this.primeGroup), this.backGroup.add(this.bkgMessage), this.backGroup.add(this.globalGroup), this.globalGroup.visible = !0), ScaleManager.onResize.add(this.rescale, this), ScaleManager.SizeCalculation(this.game)
        }, a.prototype.createLevels = function() {
            var t = h.GameAPI.createText(this.game, 150, 185, "MaiandraGDStroke", "PACK 1", 22, 16777215, !0);
            this.primeGroup.add(t), this.createFiveLevel(200, 5, 0), this.createFiveLevel(260, 5, 5), t = h.GameAPI.createText(this.game, 450, 185, "MaiandraGDStroke", "PACK 2", 22, 16777215, !0), this.primeGroup.add(t), this.createFiveLevel(200, 310, 10), this.createFiveLevel(260, 310, 15), t = h.GameAPI.createText(this.game, 150, 345, "MaiandraGDStroke", "PACK 3", 22, 16777215, !0), this.primeGroup.add(t), this.createFiveLevel(360, 5, 20), this.createFiveLevel(420, 5, 25), t = h.GameAPI.createText(this.game, 450, 345, "MaiandraGDStroke", "PACK 4", 22, 16777215, !0), this.primeGroup.add(t), this.createFiveLevel(360, 310, 30), this.createFiveLevel(420, 310, 35), 1 < a.save.levelState[39] && (a.save.bonusMode = !0)
        }, a.prototype.speedrunText = function(t, e, i, o) {
            var s = this.getTime(a.save.speedRunState[t]),
                n = h.GameAPI.createText(this.game, e, i, "MaiandraGDStroke", "Best Time = " + s, 16, 0, !1);
            h.GameAPI.addEvent(n, this, this.startSpeedrun, [o], this.changeText, ["Click for Speedrun", "default"], this.changeText, ["Best Time = " + s, "default"]), h.GameAPI.setText(n), this.primeGroup.add(n)
        }, a.prototype.createBottomText = function() {
            var t, e, i = this,
                o = h.GameAPI.createText(this.game, 160, 520, "MaiandraGDStroke", "Main Menu", 23, 16777215, !1);
            (h.GameAPI.addEvent(o, this, h.GameAPI.changeState, ["MainMenu"], h.GameAPI.chageColor, [6710886, "pointer"], h.GameAPI.chageColor, [16777215, "default"]), h.GameAPI.setText(o), this.primeGroup.add(o), 1 < a.save.levelState[39]) ? (e = this.isBonusMode ? (t = "Bonus Mode On", 3329330) : (t = "Bonus Mode Off", 16711680), o = h.GameAPI.createText(this.game, 450, 520, "MaiandraGDStroke", t, 23, e, !1), h.GameAPI.setText(o), this.game.device.desktop ? h.GameAPI.addEvent(o, this, this.changeBonusMode, null, this.changeBonusTextOver, ["pointer"], this.changeBonusText, ["default"]) : (h.GameAPI.addEvent(o, this, this.changeBonusMode), o.events.onInputUp.add(function(t) {
                i.isBonusMode ? (t.text = "Bonus Mode On", h.GameAPI.setText(t), t.tint = 3329330) : (t.text = "Bonus Mode Off", h.GameAPI.setText(t), t.tint = 16711680)
            }, this))) : (o = h.GameAPI.createText(this.game, 450, 520, "MaiandraGDStroke", "Bonus Mode Locked", 23, 16777215, !1), h.GameAPI.setText(o), h.GameAPI.addEvent(o, this, null, null, this.changeText, ["Beat the game to unlock", "pointer"], this.changeText, ["Bonus Mode Locked", "default"]));
            this.primeGroup.add(o)
        }, a.prototype.shutdown = function() {
            ScaleManager.onResize.remove(this.rescale, this)
        }, a.prototype.rescale = function() {
            null != this.bkgMessage && (this.bkgMessage.width = this.game.world.width, this.bkgMessage.height = this.game.world.height), null != this.globalGroup && (this.globalGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.globalGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2), this.primeGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.primeGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.bkg.width = this.game.world.width, this.bkg.height = this.game.world.height
        }, a.prototype.changeBonusMode = function(t) {
            if (this.isBonusMode = !this.isBonusMode, this.isBonusMode) {
                this.globalGroup = this.add.group(), this.bkgMessage = this.game.add.sprite(0, 0, "bkgmessage"), this.globalGroup.add(h.GameAPI.createMessage(this.game, "Bonus Mode", "You turned bonus mode ON. Play a stack now\nand you will be given the shapes in a random\norder.\n\nGood luck!", function() {
                    this.globalGroup.visible = !1, this.bkgMessage.visible = !1
                }, this)), this.globalGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.globalGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.bkgMessage.width = this.game.world.width, this.bkgMessage.height = this.game.world.height, this.globalGroup.visible = !0, this.bkgMessage.visible = !0;
                for (var e = 0; e < 60; ++e) this.world.moveUp(this.globalGroup)
            }
        }, a.prototype.changeBonusTextOver = function(t, e, i) {
            t.game.canvas.style.cursor = i[0], this.isBonusMode ? t.text = "Turn off Bonus Mode" : t.text = "Turn on Bonus Mode", t.tint = 16777215
        }, a.prototype.changeBonusText = function(t, e, i) {
            t.game.canvas.style.cursor = i[0], this.isBonusMode ? (t.text = "Bonus Mode On", t.tint = 3329330) : (t.text = "Bonus Mode Off", t.tint = 16711680)
        }, a.prototype.changeText = function(t, e, i) {
            t.game.canvas.style.cursor = i[1], t.text = i[0], 2 < i.length && (t.tint = i[2])
        }, a.prototype.createFiveLevel = function(t, e, i) {
            for (var o = i + 5; i < o; ++i) {
                var s = this.game.add.group();
                if (0 == a.save.levelState[i]) {
                    var n = this.game.add.sprite(0, 0, "ls1");
                    s.add(n);
                    var r = h.GameAPI.createText(this.game, 24, 26, "MaiandraGDStroke", "L", 22, 0, !0)
                } else if (1 == a.save.levelState[i]) {
                    n = this.game.add.sprite(0, 0, "ls2");
                    s.add(n), h.GameAPI.addEvent(n, this, this.startGame, [i], this.inputOver, [i, 3], this.InputOut, [2]);
                    r = h.GameAPI.createText(this.game, 24, 26, "MaiandraGDStroke", (i + 1).toString(), 22, 0, !0)
                } else if (2 == a.save.levelState[i]) {
                    n = this.game.add.sprite(0, 0, "ls4");
                    s.add(n), h.GameAPI.addEvent(n, this, this.startGame, [i], this.inputOver, [i, 5], this.InputOut, [4]);
                    r = h.GameAPI.createText(this.game, 24, 26, "MaiandraGDStroke", (i + 1).toString(), 22, 0, !0)
                } else if (3 == a.save.levelState[i]) {
                    n = this.game.add.sprite(0, 0, "ls6");
                    s.add(n), h.GameAPI.addEvent(n, this, this.startGame, [i], this.inputOver, [i, 7], this.InputOut, [6]);
                    r = h.GameAPI.createText(this.game, 24, 26, "MaiandraGDStroke", (i + 1).toString(), 22, 0, !0)
                }
                s.add(r), s.position = new Phaser.Point(e, t), this.primeGroup.add(s), e += 58
            }
        }, a.prototype.InputOut = function(t, e, i) {
            this.nameLevel.setText("")
        }, a.prototype.inputOver = function(t, e, i) {
            var o = h.EncryptionLogic.LVLCODES[i[0]].split("/")[0].split("\n")[0];
            this.nameLevel.setText(o)
        }, a.prototype.startGame = function(t, e, i, o) {
            o[h.GamePlay.gameTime = 0];
            t.game.state.start("Game", !0, !1, o[0], !1, this.isBonusMode)
        }, a
    }(Phaser.State);
    h.Level = t
}(Stracker || (Stracker = {})),
function(s) {
    var t = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return __extends(e, t), e.prototype.init = function() {
            s.Boot.inSplash = !1, ScaleManager.SizeCalculation(this.game);
            var t = document.location.href.split("?");
            if (null != t[1] && -1 !== t[1].indexOf("level")) {
                var e = (t = t[1].split("level="))[0];
                null != t[1] && (e = (t = t[1].split("&"))[0]), null != e && (s.GamePlay.gameTime = 0, s.GameAPI.STATICDATA = e.split("_")[0], s.GameAPI.DYNAMICDATA = e.split("_")[1], this.game.state.start("Game", !0, !1, 1, !1, !1, !0))
            }
        }, e.prototype.preload = function() {
            null == s.music && (s.music = new Music(this.game), s.music.playMusic()), this.bkg = this.add.sprite(0, 0, "backgroundMenu"), this.superstracker = this.add.sprite(40, 20, "new_logo"), this.superstracker.anchor.setTo(.5, .5), this.mainMenuGroup = this.game.add.group()
        }, e.prototype.create = function() {

            var t = this.add.button(180, 310, "mm_play", this.PlayClick, this, 0, 0, 0);
            t.anchor.setTo(.5, .5), this.mainMenuGroup.add(t);
            //var e = this.add.button(180, 410, "mm_more", this.MoreClick, this, 0, 0, 0);
            // e.anchor.setTo(.5, .5), this.mainMenuGroup.add(e), Fabrique.Branding.outGoingLinksAllowed() || (e.visible = !1);
            //var i = s.GameAPI.createText(this.game, 180, 520, "MaiandraGDStroke", "Kizi / Gaz Thomas", 20, 16777215, !1);
            //this.mainMenuGroup.add(i);
            var o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0);
            s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 50, 304), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 60, 388), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 52, 472), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 48, 556), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 52, 640), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 52, 724), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 - 52, 808), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 326, 304), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 334, 388), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 320, 472), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 326, 556), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 334, 640), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 334, 724), this.mainMenuGroup.add(o), o = s.GameAPI.getSprite(this.game, "cube", 84, 84, !1, !0, !0), s.GameAPI.setParameter(o, 84, 84, 1, t.x - 134 + 334, 808), this.mainMenuGroup.add(o), this.effectbutton = this.game.add.button(30, 445, "atlas", s.music.statusSound, s.music), this.effectbutton.frameName = s.music.getNameObject("sound"), this.musicbutton = this.game.add.button(30, 445, "atlas"), this.musicbutton.events.onInputUp.add(s.music.statusSound, s.music, 1, ["music"]), this.musicbutton.frameName = s.music.getNameObject("music"), this.moreGamesMenu = new Fabrique.MoreGames.Menu(this.game, "super-stacker-2"), this.moreGamesMenu.x = this.game.width / 2, this.moreGamesMenu.y = this.game.height / 2, this.game.add.existing(this.moreGamesMenu), ScaleManager.onResize.add(this.rescale, this), ScaleManager.SizeCalculation(this.game)
        }, e.prototype.PlayClick = function(t, e, i, o) {
            s.GameAPI.changeState(t, e, i, ["Level"])
        }, e.prototype.MoreClick = function(t, e, i, o) {
            window.open("https://kizi.com/", "_blank")
        }, e.prototype.shutdown = function() {
            ScaleManager.onResize.remove(this.rescale, this)
        }, e.prototype.rescale = function() {
            this.effectbutton.y = this.game.world.height - 5 - this.effectbutton.height, this.effectbutton.x = this.game.world.width - 5 - this.musicbutton.width, this.musicbutton.y = this.game.world.height - 5 - this.musicbutton.height, this.musicbutton.x = this.game.world.width - 8 - 2 * this.musicbutton.width, this.superstracker.x = this.game.world.width / 2, this.superstracker.y = this.game.world.height / 2 - 150, this.mainMenuGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2 + 100, this.mainMenuGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.bkg.width = this.game.world.width, this.bkg.height = this.game.world.height, this.moreGamesMenu.x = this.game.width / 2, this.moreGamesMenu.y = this.game.height / 2
        }, e.prototype.stackeditor = function() {
            this.game.state.start("StackEditor")
        }, e
    }(Phaser.State);
    s.MainMenu = t
}(Stracker || (Stracker = {})),
function(f) {
    var t = function(e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.stepUp = 10, t.yScroll = 0, t
        }
        return __extends(t, e), t.prototype.preload = function() {
            if (this.figureType = "cube", this.xStart = 10, this.yStart = 105, this.yEnd = 105, this.isOver = !1, this.isQueue = !1, this.bkg = this.add.sprite(0, 0, "backgroundMenu"), this.bkg.width = 600, this.bkg.height = 550, this.bigborder = this.add.sprite(50, 28, "bigborder"), this.bigborder.width = 500, this.bigborder.height = 460, this.bigborder.anchor.setTo(.5, .5), this.bkgQueue = this.add.sprite(0, 0, "bkgQueue"), this.bkgQueue.visible = !1, this.dataQueue = [], this.inputArray = [], this.bkgMessage = this.game.add.sprite(0, 0, "bkgmessage"), this.bkgMessage.visible = !1, this.bottomData = new x, this.bottomData.angle = 0, this.bottomData.width = 60, this.bottomData.height = 60, this.bottomData.count = 1, this.bottomData.figureType = this.figureType, this.topMenu = this.add.sprite(0, 0, "topmenu"), this.topMenu.alpha = 1, this.topMenu.height = 35, this.topMenu.width = 600, this.bottomMenu = this.add.sprite(0, 504, "topmenu"), this.bottomMenu.alpha = 1, this.bottomMenu.height = 47, this.bottomMenu.width = 600, this.isMove = !1, this.primeGroup = this.game.add.group(), this.staticGroup = this.game.add.group(), this.figureGroup = this.game.add.group(), this.usedGroup = this.game.add.group(), this.topMenuGroup = this.game.add.group(), this.bottomMenuGroup = this.game.add.group(), this.queueGroup = this.game.add.group(), this.queueFGroup = this.game.add.group(), this.topQueueGroup = this.game.add.group(), this.hideGroup = this.game.add.group(), this.scrollGroup = this.game.add.group(), this.shareGroup = this.game.add.group(), this.primeGroup.add(this.usedGroup), this.primeGroup.add(this.staticGroup), this.primeGroup.add(this.figureGroup), this.primeGroup.add(this.bkgQueue), this.primeGroup.add(this.queueGroup), this.primeGroup.add(this.topQueueGroup), this.primeGroup.add(this.queueFGroup), this.primeGroup.add(this.topMenu), this.primeGroup.add(this.topMenuGroup), this.primeGroup.add(this.bottomMenu), this.primeGroup.add(this.bottomMenuGroup), this.primeGroup.add(this.scrollGroup), this.primeGroup.add(this.bkgMessage), this.primeGroup.add(this.shareGroup), this.topQueueGroup.visible = !1, this.queueGroup.visible = !1, "" != f.GameAPI.STATICDATA && (this.staticFigures = f.EncryptionLogic.getFigures(this.game, 0, !0, !0), this.locateSprite()), "" != f.GameAPI.DYNAMICDATA) {
                this.dynamicFigures = f.EncryptionLogic.getDynamicFigures();
                var t = this.dynamicFigures[0],
                    e = this.createQueue(this.xStart, this.yStart, 0, t.figureType, t.width, t.height, t.angle, t.count);
                this.yEnd += 60;
                for (var i = 1; i < this.dynamicFigures.length; ++i) {
                    t = this.dynamicFigures[i];
                    var o = this.queueGroup.getIndex(e) + 1;
                    this.yEnd += 60;
                    for (i = o; i < this.queueGroup.length; ++i) {
                        this.queueGroup.getAt(i).y += 60, this.dataQueue[i].index = i + 1
                    }
                    e = this.createQueue(e.x, e.y + 60, o, t.figureType, t.width, t.height, t.angle, t.count), this.resizeScroll()
                }
            }
        }, t.prototype.create = function() {
            this.createTopMenu(), this.createBottomMenu(), this.startDrag(), this.createTopQueue(), ScaleManager.onResize.add(this.rescale, this), ScaleManager.SizeCalculation(this.game), this.scrollGroup.visible = !1
        }, t.prototype.shutdown = function() {
            ScaleManager.onResize.remove(this.rescale, this)
        }, t.prototype.rescale = function() {
            this.topMenu.width = this.game.world.width, this.topMenuGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.bottomMenu.width = this.game.world.width, this.topQueueGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.queueGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.bottomMenu.y = this.game.world.height - this.bottomMenu.height, this.bottomMenuGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.bottomMenuGroup.y = this.game.world.height - ScaleManager.GameHeight, this.staticGroup.x = this.game.world.width / 2 - ScaleManager.GameWidth / 2, this.staticGroup.y = this.game.world.height / 2 - ScaleManager.GameHeight / 2, this.bigborder.y = this.game.world.height / 2, this.bigborder.x = this.game.world.width / 2, 0 != this.shareGroup.length && (this.shareGroup.y = this.game.world.height / 2 - ScaleManager.GameWidth / 2, this.shareGroup.x = this.game.world.width / 2 - ScaleManager.GameHeight / 2), this.bkg.width = this.game.world.width, this.bkg.height = this.game.world.height, this.bkgMessage.width = this.game.world.width, this.bkgMessage.height = this.game.world.height, this.bkgQueue.width = this.game.world.width, this.bkgQueue.height = this.game.world.height, null != this.scrollback && (this.scrollback.x = this.game.world.width / 2 + 285, this.scrollback.y = this.game.world.height / 2 + 90 - 65, this.scrollback.height = this.game.world.height - 95 - 60), null != this.scrollup && (this.scrollup.y = 110, this.scrollup.x = this.game.world.width / 2 + 285), null != this.scrolldown && (this.scrolldown.x = this.game.world.width / 2 + 285, this.scrolldown.y = this.game.world.height - 60), null != this.bkgtopQueue && null != this.topQueueGroup && (this.bkgtopQueue.width = this.topQueueGroup.width), null != this.scrollmove && (this.scrollmove.x = this.game.world.width / 2 + 285), 0 != this.queueGroup.length && this.resizeScroll()
        }, t.prototype.update = function() {
            var e = this;
            this.inputArray.forEach(function(t) {
                if (0 == t.focus) {
                    if ("" == t.domElement.value) switch (t.name) {
                        case "size":
                            e.changeInputText(t, "15");
                            break;
                        case "angle":
                            e.changeInputText(t, "0");
                            break;
                        case "step":
                            e.changeInputText(t, "1")
                    }
                    switch (t.name) {
                        case "size":
                            +t.domElement.value < 15 && e.changeInputText(t, "15");
                            break;
                        case "step":
                            +t.domElement.value < 1 && e.changeInputText(t, "1")
                    }
                }
            }, this)
        }, t.prototype.render = function() {}, t.prototype.locateSprite = function() {
            var o = this;
            this.rescale(), this.staticFigures.forEach(function(t) {
                var e = o.convertScale(t.width, t.height),
                    i = o.parsePosition(t.x, t.y);
                f.GameAPI.addEye(t, o.game), t.width = e.x, t.height = e.y, t.x = i.x - o.staticGroup.x, t.y = i.y - o.staticGroup.y, t.visible = !0, t.inputEnabled = !0, t.events.onInputOver.add(function() {
                    o.isOver = !0
                }, o), t.events.onInputOut.add(function() {
                    o.isOver = !1
                }, o), t.events.onInputUp.add(o.changeSprite, o), o.staticGroup.add(t)
            }, this)
        }, t.prototype.createInput = function(t, e, i, o, s, n) {
            var r = n.pop(),
                a = new PhaserInput.InputField(this.game, t, e, {
                    font: "16px MaindraBlackStroke",
                    fill: "#000000",
                    fillAlpha: 0,
                    fontWeight: "bold",
                    width: 30,
                    height: 0,
                    max: r.toString(),
                    min: "0",
                    padding: 3,
                    borderWidth: 1,
                    borderColor: "#000000",
                    type: PhaserInput.InputType.number,
                    textAlign: "center"
                });
            return n.unshift(o), n.unshift(a), this.changeInputText(a, s), a.name = o, a.domElement.removeEventListener(), a.domElement.addKeyUpListener(this.KeyInput.bind(this, n)), i.add(a), this.inputArray.push(a), a
        }, t.prototype.changeInputText = function(t, e) {
            t.setText(e)
        }, t.prototype.KeyInput = function(t) {
            var e = t[0],
                i = t[1],
                o = t[2],
                s = t[3],
                n = t[4];
            if (null == n && (n = !1), e.focus) {
                if ("" == e.domElement.value && (e.domElement.value = ""), +e.domElement.value > +e.inputOptions.max)
                    if ("size" == i || "step" == i) e.domElement.value = e.inputOptions.max;
                    else if ("angle" == i) {
                    var r = +e.domElement.value;
                    999 < r && (r = Math.floor(r / 10));
                    for (var a = 0; a < 2; ++a) 360 < r && (r = Math.abs(r - 360));
                    e.setText(r.toString())
                }
                switch (s) {
                    case "H":
                        o.height = +e.domElement.value;
                        break;
                    case "W":
                        o.width = +e.domElement.value;
                        break;
                    case "A":
                        this.moveFigure.angle = +e.domElement.value, o.angle = +e.domElement.value;
                        break;
                    case "S":
                        o.count = +e.domElement.value
                }
                if ("circle" == o.figureType) switch (s) {
                    case "W":
                        o.height = o.width, this.changeInputText(o.heightText, o.height.toString());
                        break;
                    case "H":
                        o.width = o.height, this.changeInputText(o.widthText, o.width.toString())
                }
                if (n) {
                    if ("" == e.value) switch (s) {
                        case "H":
                            o.height = 15;
                            break;
                        case "W":
                            o.width = 15
                    }
                    this.moveFigure.destroy(!0), this.moveFigure = this.creteSprite(), this.moveFigure.x = this.input.x, this.moveFigure.y = this.input.y
                }
            }
        }, t.prototype.createTopMenu = function() {
            var e = this,
                t = f.GameAPI.createText(this.game, 80, 17, "Cookies", "stack editor", 23, 16777215, !0);
            this.topMenuGroup.add(t), this.textLayaut = f.GameAPI.createText(this.game, 200, 17, "Maiandra16", "- Layout", 14, 0, !1), this.topMenuGroup.add(this.textLayaut), t = f.GameAPI.createText(this.game, 320, 17, "Maiandra16", "Test it", 16, 0, !1), f.GameAPI.addEvent(t, this, null, null, f.GameAPI.chageColor, [12079, "pointer"], f.GameAPI.chageColor, [0, "default"]), t.events.onInputDown.add(this.convertingStaticGroup, this), t.events.onInputDown.add(function() {
                if (e.convertingStaticGroup(), "" == f.GameAPI.STATICDATA || "" == f.GameAPI.DYNAMICDATA) return e.bkgMessage.visible = !0, e.isOver = !0, f.GamePlay.gameTime = 0, void f.GameAPI.createMessage(e.game, "Message", 'There aren\'t any pieces in the queue, click "++"\nto add some :)', function(t) {
                    t.parent.parent.destroy(!0), e.bkgMessage.visible = !1, e.isOver = !1
                }, e);
                e.game.state.start("Game", !0, !1, 1, !1, !1, !0)
            }, this), this.topMenuGroup.add(t), f.GameAPI.setText(t), t = f.GameAPI.createText(this.game, 430, 17, "Maiandra16", "Share it", 16, 0, !1), f.GameAPI.addEvent(t, this, this.convertingStaticGroup, null, f.GameAPI.chageColor, [12079, "pointer"], f.GameAPI.chageColor, [0, "default"]), t.events.onInputDown.add(function() {
                if (e.convertingStaticGroup(), "" == f.GameAPI.STATICDATA || "" == f.GameAPI.DYNAMICDATA) return e.bkgMessage.visible = !0, e.isOver = !0, void f.GameAPI.createMessage(e.game, "Message", 'There aren\'t any pieces in the queue, click "++"\nto add some :)', function(t) {
                    t.parent.parent.destroy(!0), e.bkgMessage.visible = !1, e.isOver = !1
                }, e);
                e.bkgMessage.visible = !0, e.isOver = !0;
                var t = f.GameAPI.createShare(e.game, function(t) {
                    t.parent.destroy(!0), e.bkgMessage.visible = !1, e.isOver = !1
                }, e);
                e.shareGroup = e.game.add.group(), e.primeGroup.add(e.shareGroup), e.shareGroup.add(t)
            }, this), this.topMenuGroup.add(t), f.GameAPI.setText(t), t = f.GameAPI.createText(this.game, 530, 17, "Maiandra16", "Exit", 16, 0, !1), f.GameAPI.addEvent(t, this, f.GameAPI.changeState, ["MainMenu"], f.GameAPI.chageColor, [12079, "pointer"], f.GameAPI.chageColor, [0, "default"]), t.events.onInputDown.add(this.convertingStaticGroup, this), this.topMenuGroup.add(t), f.GameAPI.setText(t)
        }, t.prototype.createBottomMenu = function() {
            var e = this,
                t = f.GameAPI.createText(this.game, 30, 517, "MaindraBlackStroke", "Shapes: ", 14);
            this.hideGroup.add(t), t = f.GameAPI.createText(this.game, 30, 537, "MaindraBlackStroke", "Tools: ", 14), this.createButton(85, 517, "mincube", this.changeFigure, ["cube"]), this.createButton(108, 517, "mincircle", this.changeFigure, ["circle"]), this.createButton(131, 517, "mintriangle", this.changeFigure, ["triangle"]), this.createButton(85, 537, "mindelete", this.changeFigure, ["delete"]), this.createButton(108, 537, "mincopy", this.changeFigure, ["copy"]), this.createButton(131, 537, "mincut", this.changeFigure, ["cut"]), this.hideGroup.add(t), this.createEdit(185, 517, "W:", "W", 220, this.bottomData, this.hideGroup), this.createEdit(185, 537, "H:", "H", 220, this.bottomData, this.hideGroup), this.createEdit(305, 517, "A:", "A", 340, this.bottomData, this.hideGroup), this.createEdit(297, 537, "Step:", "S", 340, this.bottomData, this.hideGroup), this.xText = f.GameAPI.createText(this.game, 425, 517, "MaindraBlackStroke", "x:  " + (this.game.input.worldX - 60), 14), this.yText = f.GameAPI.createText(this.game, 425, 537, "MaindraBlackStroke", "y:  " + (this.game.input.worldY - 35), 14), this.hideGroup.add(this.xText), this.hideGroup.add(this.yText), t = f.GameAPI.createText(this.game, 530, 530, "MaiandraGDStroke", "Edit Queue", 17, 0, !1), f.GameAPI.addEvent(t, this, function(t) {
                e.hideGroup.visible = !e.hideGroup.visible, e.hideGroup.visible ? (e.queueGroup.visible = !1, e.bkgQueue.visible = !1, e.topQueueGroup.visible = !1, e.scrollGroup.visible = !1, t.setText("Edit Queue"), e.textLayaut.setText("- Layout"), e.isQueue = !1) : (e.isQueue = !0, e.topQueueGroup.visible = !0, e.queueGroup.visible = !0, e.bkgQueue.visible = !0, e.IsShowScroll() ? e.scrollGroup.visible = !0 : e.scrollGroup.visible = !1, t.setText("Edit Layout"), e.textLayaut.setText("- Queue"))
            }, null, f.GameAPI.chageColor, [7833753, "pointer"], f.GameAPI.chageColor, [0, "default"]), this.bottomMenuGroup.add(t), f.GameAPI.setText(t), this.bottomMenuGroup.add(this.hideGroup)
        }, t.prototype.IsShowScroll = function() {
            if (0 != this.queueGroup.length) {
                if (this.scrollback.height - this.scrolldown.height - this.scrollup.height < this.scrollmove.height) return !1;
                if (this.queueGroup.height > this.scrollback.height) return !0
            }
            return !1
        }, t.prototype.scrollBar = function() {
            var t = this;
            this.scrollback = this.game.add.sprite(580, 225, "atlas", "flcontrols.png"), this.scrollback.anchor.setTo(.5, .5), this.scrollGroup.add(this.scrollback), this.scrollup = this.game.add.button(580, 90, "atlas", null, null, "flscrollbuttonup2.png", "flscrollbuttonup1.png", "flscrollbuttonup3.png", "flscrollbuttonup1.png"), this.scrollup.anchor.setTo(.5, .5), this.scrollup.onInputDown.add(function() {
                t.timerUp = t.game.time.create(!1), t.timerUp.loop(50, function() {
                    t.scrollback.y - t.scrollback.height / 2 + t.scrollup.height < t.scrollmove.y && (t.scrollmove.y -= 1, t.queueGroup.y += 1 * t.fuctorMove)
                }, t), t.timerUp.start()
            }, this), this.scrollup.onInputUp.add(function() {
                t.timerUp.stop()
            }, this), this.scrollGroup.add(this.scrollup), this.scrolldown = this.game.add.button(580, 90, "atlas", null, null, "flscrollbuttondown2.png", "flscrollbuttondown1.png", "flscrollbuttondown3.png", "flscrollbuttondown1.png"), this.scrolldown.anchor.setTo(.5, .5), this.scrolldown.onInputDown.add(function() {
                t.timerDown = t.game.time.create(!1), t.timerDown.loop(50, function() {
                    t.scrollback.y + t.scrollback.height / 2 - t.scrolldown.height > t.scrollmove.y + t.scrollmove.height && (t.scrollmove.y += 1, t.queueGroup.y -= 1 * t.fuctorMove)
                }, t), t.timerDown.start()
            }, this), this.scrolldown.onInputUp.add(function() {
                t.timerDown.stop()
            }, this), this.scrollGroup.add(this.scrolldown), this.scrollmove = this.game.add.button(580, this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height, "atlas", null, null, "flscroll2.png", "flscroll1.png", "flscroll3.png", "flscroll1.png"), this.scrollmove.onInputUp.add(function() {
                t.isMove = !1
            }, this), this.scrollmove.onInputDown.add(function() {
                t.isMove = !0
            }, this), this.scrollmove.anchor.setTo(.6, 0), this.scrollmove.width = this.scrollback.width - 5, this.scrollGroup.add(this.scrollmove), this.scrollGroup.visible = !1
        }, t.prototype.createTopQueue = function() {
            var e = this;
            this.bkgtopQueue = this.add.sprite(2, 2, "back"), this.bkgtopQueue.height = 100, this.topQueueGroup.add(this.bkgtopQueue);
            var t = f.GameAPI.createText(this.game, 40, 55, "Maiandra16", "Shape", 15, 0, !0);
            this.topQueueGroup.add(t);
            t = f.GameAPI.createText(this.game, 155, 55, "Maiandra16", "Width", 15, 0, !0);
            this.topQueueGroup.add(t);
            t = f.GameAPI.createText(this.game, 250, 55, "Maiandra16", "Height", 15, 0, !0);
            this.topQueueGroup.add(t);
            t = f.GameAPI.createText(this.game, 350, 55, "Maiandra16", "Angle", 15, 0, !0);
            this.topQueueGroup.add(t);
            t = f.GameAPI.createText(this.game, 440, 55, "Maiandra16", "Qty.", 15, 0, !0);
            this.topQueueGroup.add(t);
            t = f.GameAPI.createText(this.game, 540, 55, "Maiandra16", "Remove", 15, 0, !0);
            this.topQueueGroup.add(t), this.add.sprite(300, 70, "atlas", "queueline.png", this.topQueueGroup).anchor.setTo(.5, .5), (t = this.addShape(300, 88, this.topQueueGroup)).events.onInputUp.removeAll(), t.events.onInputUp.add(function() {
                if (e.createQueue(e.xStart, e.yStart, 0), e.yEnd += 60, 1 != e.queueGroup.length) {
                    for (var t = 1; t < e.queueGroup.length; ++t) {
                        e.queueGroup.getAt(t).y += 60
                    }
                    e.resetDataQueue(0)
                }
                e.resizeScroll()
            }, this), this.scrollBar()
        }, t.prototype.addShape = function(t, e, i) {
            var o = f.GameAPI.createText(this.game, t, e, "Maiandra16", "++", 15, 12079, !1);
            return f.GameAPI.addEvent(o, this, this.addNewQueue, null, function(t) {
                t.setText("+add shape here+"), t.hitArea = new Phaser.Rectangle(-t.width / 2, -t.height / 2, t.width, t.height)
            }, null, function(t) {
                t.setText("++"), t.hitArea = new Phaser.Rectangle(-t.width / 2, -t.height / 2, t.width, t.height)
            }, null), o.events.onInputUp.add(function(t) {
                t.setText("++"), t.hitArea = new Phaser.Rectangle(-t.width / 2, -t.height / 2, t.width, t.height)
            }, this), i.add(o), o
        }, t.prototype.resetDataQueue = function(t) {
            var i = this,
                e = this.dataQueue[t];
            this.dataQueue[t] = this.dataQueue[this.dataQueue.length - 1];
            for (var o = t + 1; o < this.dataQueue.length; ++o) {
                var s = this.dataQueue[o];
                this.dataQueue[o] = e, e = s
            }
            o = 0;
            this.queueGroup.forEach(function(t) {
                var e = i.queueGroup.getIndex(t);
                i.dataQueue[o].index = e, o++
            }, this)
        }, t.prototype.addNewQueue = function(t, e, i) {
            var o = t.parent,
                s = this.queueGroup.getIndex(o) + 1;
            this.yEnd += 60;
            for (var n = s; n < this.queueGroup.length; ++n) {
                this.queueGroup.getAt(n).y += 60, this.dataQueue[n].index = n + 1
            }
            this.createQueue(o.x, o.y + 60, s), this.resetDataQueue(s), this.resizeScroll()
        }, t.prototype.resizeScroll = function() {
            if (null != this.scrollback && null != this.scrolldown && null != this.scrollmove && null != this.scrollup) {
                var t = (this.scrollback.height - this.scrollup.height - this.scrolldown.height) / (this.yEnd - this.yStart),
                    e = this.scrollback.height - this.scrollup.height - this.scrolldown.height;
                this.scrollmove.height = e * t, this.queueGroup.y = 0, this.scrollmove.y = this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height, this.IsShowScroll() ? this.scrollGroup.visible = !0 : this.scrollGroup.visible = !1, this.fuctorMove = (this.yEnd - this.yStart) / (this.scrollback.height - this.scrollup.height - this.scrolldown.height)
            }
        }, t.prototype.createQueue = function(t, e, i, o, s, n, r, a) {
            var h = this;
            void 0 === o && (o = "cube"), void 0 === s && (s = 45), void 0 === n && (n = 45), void 0 === r && (r = 0), void 0 === a && (a = 1);
            var l = new x,
                d = this.game.add.group(),
                c = this.game.add.sprite(285, 18, "bkgline");
            c.anchor.setTo(.5, .5), d.x = t, d.y = e, d.add(c);
            var u = f.GameAPI.getSprite(this.game, o, 30, 30, !0, !0, !0);
            u.width = 23, u.height = 23, u.x = 25, u.y = 18, d.add(u), l.index = i, l.sprite = u, l.figureType = o;
            var p = this.createButton(50, 9, "up", function(t, e, i, o) {
                var s = o[0],
                    n = h.getTypeFigure(s.name, !0);
                s.name = n, o[1].figureType = n, s.animations.add("change", ["min" + n + ".png"]), s.animations.play("change"), s.children.length = 0, "circle" == n && (o[1].height = o[1].width, h.changeInputText(o[1].heightText, o[1].height.toString())), "triangle" == n ? (s.anchor.setTo(.75, .75), s.x += .25 * s.width, s.y += .25 * s.height) : (s.anchor.setTo(.5, .5), s.x = 25, s.y = 18), f.GameAPI.addEye(s, h.game, .2)
            }, [u, l]);
            p.width = 13, p.height = 13, d.add(p);
            var b = this.createButton(50, 27, "down", function(t, e, i, o) {
                var s = o[0],
                    n = h.getTypeFigure(s.name);
                s.name = n, o[1].figureType = n, s.animations.add("change", ["min" + n + ".png"]), s.animations.play("change"), s.children.length = 0, "circle" == n && (o[1].height = o[1].width, h.changeInputText(o[1].heightText, o[1].height.toString())), "triangle" == n ? (s.anchor.setTo(.75, .75), s.x += .25 * s.width, s.y += .25 * s.height) : (s.anchor.setTo(.5, .5), s.x = 25, s.y = 18), f.GameAPI.addEye(s, h.game, .2)
            }, [u, l]);
            b.width = 13, b.height = 13, d.add(b);
            var m = f.GameAPI.createEye(this.game, 90, 17, 13, 13);
            m.inputEnabled = !0, m.events.onInputOver.add(function(t, e, i) {
                var o = i[0];
                null == h.demonstration && (h.demonstration = f.GameAPI.getSprite(h.game, o.sprite.name, o.width, o.height, !1, !0, !0), h.primeGroup.add(h.demonstration), h.demonstration.x = h.game.world.width / 2, h.demonstration.y = h.game.world.height / 2, h.demonstration.angle = o.angle, h.demonstration.visible = !0)
            }, this, 1, [l]), m.events.onInputOut.add(function(t, e) {
                null != h.demonstration && (h.demonstration.destroy(!0), h.demonstration = null)
            }, this), d.add(m), this.createEdit(145, 17, "", "W", 145, l, d, s, n, r, a), this.createEdit(240, 17, "", "H", 240, l, d, s, n, r, a), this.createEdit(340, 17, "", "A", 340, l, d, s, n, r, a), this.createEdit(440, 17, "", "S", 430, l, d, s, n, r, a, 50);
            var y = this.game.add.button(530, 18, "atlas", null, this, "delQueue2.png", "delQueue1.png", "delQueue2.png", "delQueue2.png", d);
            return y.anchor.setTo(.5, .5), y.events.onInputUp.add(this.deleteQueue, this, 1, [d]), this.addShape(290, 50, d), this.dataQueue.push(l), this.queueGroup.add(d), this.queueGroup.setChildIndex(d, i), d
        }, t.prototype.getTypeFigure = function(t, e) {
            return void 0 === e && (e = !1), "cube" == t ? e ? "circle" : "triangle" : "circle" == t ? e ? "triangle" : "cube" : "triangle" == t ? e ? "cube" : "circle" : void 0
        }, t.prototype.deleteQueue = function(t, e, i, o) {
            var s = o[0],
                n = (o[1], this.queueGroup.getIndex(s) + 1);
            this.yEnd -= 60;
            for (var r = n; r < this.queueGroup.length; ++r) {
                this.queueGroup.getAt(r).y -= 60
            }
            this.resizeScroll();
            for (r = n; r < this.dataQueue.length; ++r) this.dataQueue[r - 1] = this.dataQueue[r];
            this.dataQueue.pop(), s.destroy(!0)
        }, t.prototype.changeFigure = function(t, e, i, o) {
            this.moveFigure.destroy(!0), this.figureType = o[0], "circle" == this.figureType && (this.bottomData.height = this.bottomData.width, this.changeInputText(this.bottomData.heightText, this.bottomData.height.toString())), this.bottomData.figureType = this.figureType, this.moveFigure = this.creteSprite()
        }, t.prototype.createEdit = function(t, e, i, o, s, n, r, a, h, l, d, c) {
            if (void 0 === a && (a = 45), void 0 === h && (h = 45), void 0 === l && (l = 0), void 0 === d && (d = 1), void 0 === c && (c = 1e3), "" != i) {
                var u = f.GameAPI.createText(this.game, t, e, "MaindraBlackStroke", i, 14);
                r.add(u), u.anchor.setTo(.5, .5)
            }
            var p, b = this.add.sprite(s, e, "atlas", "fontborder.png");
            switch (b.height = 20, b.width = 40, b.anchor.setTo(.5, .5), r.add(b), o) {
                case "W":
                    p = this.createInput(s - 17, e - 9, r, "size", a.toString(), [n, o, !0, 600]), n.widthText = p, n.width = a;
                    break;
                case "H":
                    p = this.createInput(s - 17, e - 9, r, "size", h.toString(), [n, o, !0, 600]), n.heightText = p, n.height = h;
                    break;
                case "A":
                    p = this.createInput(s - 17, e - 9, r, "angle", l.toString(), [n, o, !1, 360]), n.angleText = p, n.angle = l;
                    break;
                case "S":
                    p = this.createInput(s - 17, e - 9, r, "step", d.toString(), [n, o, !1, c]), n.countText = p, n.count = d
            }
            var m = this.createButton(s + 30, e, "minus", this.changeValue, ["-", o, p, n]);
            m.height = 5, m.width = 10, r.add(m), (m = this.createButton(s + 45, e, "plus", this.changeValue, ["+", o, p, n])).height = 10, m.width = 10, r.add(m)
        }, t.prototype.changeValue = function(t, e, i, o) {
            var s = o[0],
                n = o[1],
                r = o[2],
                a = o[3];
            if ("W" == n) {
                if ("+" == s ? a.width += 15 : a.width -= 15, a.width < 15 && (a.width = 15), this.changeInputText(r, a.width.toString()), "cut" == this.figureType || "copy" == this.figureType || "delete" == this.figureType) return;
                "circle" == a.figureType && (a.height = a.width, this.changeInputText(a.heightText, a.width.toString())), this.moveFigure.destroy(!0), this.moveFigure = this.creteSprite()
            } else if ("H" == n) {
                if ("+" == s ? a.height += 15 : a.height -= 15, a.height < 15 && (a.height = 15), this.changeInputText(r, a.height.toString()), "cut" == this.figureType || "copy" == this.figureType || "delete" == this.figureType) return;
                "circle" == a.figureType && (a.width = a.height, this.changeInputText(a.widthText, a.height.toString())), this.moveFigure.destroy(!0), this.moveFigure = this.creteSprite()
            } else if ("A" == n) {
                if ("+" == s ? a.angle += 45 : a.angle -= 45, 360 <= a.angle && (a.angle = this.bottomData.angle - 360), a.angle < 0 && (a.angle = 360 - Math.abs(a.angle)), this.changeInputText(r, a.angle.toString()), "cut" == this.figureType || "copy" == this.figureType || "delete" == this.figureType) return;
                this.moveFigure.angle = a.angle
            } else "S" == n && ("+" == s ? a.count++ : a.count--, a.count < 1 && (a.count = 1), this.changeInputText(r, a.count.toString()))
        }, t.prototype.createButton = function(t, e, i, o, s) {
            void 0 === o && (o = null), void 0 === s && (s = null);
            var n = f.GameAPI.createButtonWithText(this.game, 0, 0, "", o, this, s, i);
            return n.getAt(0).anchor.setTo(.5, .5), n.x = t, n.y = e, n.width = 18, n.height = 18, n.getAt(0).hitArea = new Phaser.Rectangle(-n.width / 2, -n.height / 2, n.width, n.height), this.hideGroup.add(n), n
        }, t.prototype.startDrag = function() {
            this.moveFigure = this.creteSprite(), this.x = this.game.input.mousePointer.worldX, this.y = this.game.input.mousePointer.worldY, this.moveFigure.x = this.game.world.width / 2, this.moveFigure.y = this.game.world.height / 2, this.game.input.onDown.add(this.mouseDragEnd, this), this.game.input.addMoveCallback(this.mouseDrag, this)
        }, t.prototype.mouseDrag = function(t, e, i, o) {
            if (this.isMove) {
                if (this.yScroll < i && this.scrolldown.y - this.scrolldown.height / 2 > this.scrollmove.y + this.scrollmove.height) {
                    var s = i - this.yScroll;
                    if (this.scrollmove.y += s, this.queueGroup.y -= s * this.fuctorMove, this.scrolldown.y - this.scrolldown.height / 2 < this.scrollmove.y + this.scrollmove.height) {
                        var n = this.scrollmove.y + this.scrollmove.height - (this.scrolldown.y - this.scrolldown.height / 2);
                        this.scrollmove.y -= n, this.queueGroup.y += n * this.fuctorMove
                    }
                }
                if (this.yScroll > i && this.scrollup.y + this.scrollup.height / 2 < this.scrollmove.y) {
                    s = this.yScroll - i;
                    if (this.scrollmove.y -= s, this.queueGroup.y += s * this.fuctorMove, this.scrollup.y + this.scrollup.height / 2 > this.scrollmove.y) {
                        n = this.scrollup.y + this.scrollup.height / 2 - this.scrollmove.y;
                        this.scrollmove.y += n, this.queueGroup.y -= n * this.fuctorMove
                    }
                }
            }
            this.yScroll = i;
            var r = this.convertPosition(t.worldX, t.worldY);
            this.xText.setText("x: " + r.x), this.yText.setText("y: " + r.y), null != this.moveFigure && (Math.abs(t.worldX - this.moveFigure.x) >= this.bottomData.count && (this.moveFigure.x = t.worldX), Math.abs(t.worldY - this.moveFigure.y) >= this.bottomData.count && (this.moveFigure.y = t.worldY))
        }, t.prototype.mouseDragEnd = function(t, e) {
            var i = this,
                o = this.convertPosition(t.x, t.y);
            o.y < 0 || 550 < o.y || t.y < 32 || t.y > this.bottomMenu.y || this.isQueue || this.isOver || o.x < 0 || 599 < o.x || "cut" != this.figureType && "copy" != this.figureType && "delete" != this.figureType && (this.isOver = !0, this.moveFigure.alpha = 1, this.moveFigure.x -= this.staticGroup.x, this.moveFigure.y -= this.staticGroup.y, this.moveFigure.events.onInputOver.add(function() {
                i.isOver = !0
            }, this), this.moveFigure.events.onInputOut.add(function() {
                i.isOver = !1
            }, this), this.staticGroup.add(this.moveFigure), this.moveFigure = this.creteSprite())
        }, t.prototype.creteSprite = function() {
            if ("cut" == this.figureType) {
                var t = this.add.sprite(this.input.worldX, this.input.worldY, "atlas", "cut.png");
                return this.figureGroup.add(t), t.alpha = .5, t.name = "cut", t
            }
            if ("delete" == this.figureType) {
                t = this.add.sprite(this.input.worldX, this.input.worldY, "atlas", "delete.png");
                return this.figureGroup.add(t), t.alpha = .5, t.name = "delete", t
            }
            if ("copy" == this.figureType) {
                t = this.add.sprite(this.input.worldX, this.input.worldY, "atlas", "copy.png");
                return this.figureGroup.add(t), t.name = "copy", t.alpha = .5, t
            }
            this.bottomData.width < 15 && (this.bottomData.width = 15), this.bottomData.height < 15 && (this.bottomData.height = 15);
            var e = this.convertScale(this.bottomData.width, this.bottomData.height);
            return (t = f.GameAPI.getSprite(this.game, this.figureType, e.x, e.y, !1, !0)).alpha = .5, t.angle = this.bottomData.angle, t.inputEnabled = !0, t.visible = !0, t.events.onInputUp.add(this.changeSprite, this), this.usedGroup.add(t), t
        }, t.prototype.changeSprite = function(t, e, i) {
            if (!this.isQueue) {
                if ("cut" == this.figureType && (this.moveFigure.destroy(), this.moveFigure = t, this.moveFigure.alpha = .5, this.usedGroup.add(this.moveFigure), this.figureType = this.moveFigure.name, this.moveFigure.events.onInputOut.removeAll(), this.moveFigure.events.onInputOver.removeAll(), this.isOver = !1), "copy" == this.figureType) {
                    this.moveFigure.destroy(), this.figureType = t.name;
                    var o = this.parseScale(t.width, t.height);
                    this.bottomData.height = o.y, this.bottomData.width = o.x, this.bottomData.angle = t.angle, this.moveFigure = this.creteSprite(), this.changeInputText(this.bottomData.heightText, Math.floor(this.bottomData.height).toString()), this.changeInputText(this.bottomData.widthText, Math.floor(this.bottomData.width).toString()), this.changeInputText(this.bottomData.angleText, Math.floor(this.bottomData.angle).toString()), this.moveFigure.x -= this.staticGroup.x, this.moveFigure.y -= this.staticGroup.y, this.moveFigure.alpha = .5, this.figureType = this.moveFigure.name, this.isOver = !1
                }
                "delete" == this.figureType && (t.destroy(), this.isOver = !1)
            }
        }, t.prototype.convertingStaticGroup = function() {
            var o = "";
            this.staticGroup.forEach(function(t) {
                var e = this.parseScale(t.width, t.height),
                    i = this.staticGroup.toGlobal(t.position);
                i = this.convertPosition(i.x, i.y), o += f.EncryptionLogic.getStaticCode(t.name, Math.round(e.x), Math.round(e.y), Math.round(t.angle), Math.round(i.x), Math.round(i.y))
            }, this), f.GameAPI.STATICDATA = o, o = "", this.dataQueue.forEach(function(t) {
                o += f.EncryptionLogic.getDynamicCode(t.figureType, t.width, t.height, t.angle, t.count)
            }, this), f.GameAPI.DYNAMICDATA = o
        }, t.prototype.convertPosition = function(t, e) {
            var i = this.bigborder.x - this.bigborder.width / 2,
                o = this.bigborder.y - this.bigborder.height / 2;
            return new Phaser.Point(Math.round(1.2 * (t - i)), Math.round(1.2 * (e - o)))
        }, t.prototype.parsePosition = function(t, e) {
            var i = this.bigborder.x - this.bigborder.width / 2,
                o = this.bigborder.y - this.bigborder.height / 2;
            return new Phaser.Point(Math.round(t / 1.2 + i), Math.round(e / 1.2 + o))
        }, t.prototype.convertScale = function(t, e) {
            return new Phaser.Point(Math.round(.8 * t), Math.round(.8 * e))
        }, t.prototype.parseScale = function(t, e) {
            return new Phaser.Point(Math.round(t / .8), Math.round(e / .8))
        }, t
    }(Phaser.State);
    f.StackEditor = t;
    var x = function() {};
    f.DataQueue = x
}(Stracker || (Stracker = {}));
var Stracker, ExternalLinks = function() {
    function t() {}
    return t.getUtmCampaignLink = function(t) {
        var e = document.referrer;
        return e = top !== self ? (e = -1 < e.indexOf("://") ? e.split("/")[2] : e.split("/")[0]).split(":")[0] : window.location.host, this.externalURL + "/?utm_source=" + e + "&utm_medium=html5&utm_term=" + this.gameName + "&utm_content=" + t + "&utm_campaign=sponsored_games"
    }, t.onClickMoreGames = function() {
        window.open(t.getUtmCampaignLink("more_games"), "_blank").focus()
    }, t.gameName = "SuperStacker3", t.externalURL = "https://kizi.com/", t
}();
! function(t) {
    var e = function() {
        function c() {}
        return c.createFigureWithEyes = function(t, e, i, o, s, n) {
            var r = new Phaser.Sprite(t, 0, 0, "atlas", e + "2.png");
            return "triangle" == e ? r.anchor.setTo(.75, .75) : r.anchor.setTo(.5, .5), r.animations.add("smile", Phaser.Animation.generateFrameNames(e, 1, 2, ".png"), 1, !1), t.world.add(r), r.width = i, r.height = o, r.x = s, r.y = n, r
        }, c.createMessage = function(t, e, i, o, s, n) {
            void 0 === o && (o = null), void 0 === s && (s = null), void 0 === n && (n = null);
            var r = t.add.group();
            r.create(300, 200, "msg_box").anchor.setTo(.5, .5);
            var a = this.createText(t, 300, 130, "Segoi", e, 30, 0, !0);
            a.anchor.setTo(.5, .5), r.add(a), (a = this.createText(t, 300, 200, "Segoi", i, 16, 0, !0)).anchor.setTo(.5, .5), r.add(a);
            var h = t.add.group(),
                l = h.create(0, 0, "border");
            l.anchor.setTo(.5, .5), l.width = 40, l.height = 35;
            var d = this.createText(t, 0, 0, "Cookieswhite", "Ok", 20, 0, !0);
            return d.anchor.setTo(.5, .5), h.add(d), h.x = 300, h.y = 272, r.add(h), this.addEvent(l, s, o, n, this.changeVisible, [!0, "pointer"], this.changeVisible, [!0, "default"]), r
        }, c.createConfirmMessage = function(t, e, i, o, s, n) {
            void 0 === o && (o = null), void 0 === s && (s = null), void 0 === n && (n = null);
            var r = t.add.group();
            r.create(290, 210, "atlas", "bkgconfirm.png").anchor.setTo(.5, .5);
            var a = this.createText(t, 300, 140, "Segoi", e, 30, 0, !0);
            a.anchor.setTo(.5, .5), r.add(a), (a = this.createText(t, 300, 210, "Segoi", i, 16, 0, !0)).anchor.setTo(.5, .5), r.add(a);
            var h = t.add.group(),
                l = h.create(0, 0, "border");
            l.anchor.setTo(.5, .5), l.width = 40, l.height = 35, this.addEvent(l, s, o, n, this.changeVisible, [!0, "pointer"], this.changeVisible, [!0, "default"]);
            var d = this.createText(t, 0, 0, "Cookieswhite", "Yes", 20, 0, !0);
            return d.anchor.setTo(.5, .5), h.add(d), h.x = 220, h.y = 260, r.add(h), (l = (h = t.add.group()).create(0, 0, "border")).anchor.setTo(.5, .5), l.width = 40, l.height = 35, this.addEvent(l, s, function(t) {
                t.parent.parent.parent.visible = !1
            }, n, this.changeVisible, [!0, "pointer"], this.changeVisible, [!0, "default"]), (d = this.createText(t, 0, 0, "Cookieswhite", "No", 20, 0, !0)).anchor.setTo(.5, .5), h.add(d), h.x = 380, h.y = 260, r.add(h), r
        }, c.changeVisible = function(t, e, i) {
            t.game.canvas.style.cursor = i[1], t.visible = i[0]
        }, c.createEye = function(t, e, i, o, s) {
            void 0 === o && (o = 40), void 0 === s && (s = 40);
            var n = new Phaser.Sprite(t, e, i, "atlas", "eye1.png");
            return n.width = o, n.height = s, n.anchor.setTo(.5, .5), n.animations.add("lookAt", Phaser.Animation.generateFrameNames("eye", 1, 3, ".png"), .5, !0), n.animations.play("lookAt"), n
        }, c.createText = function(t, e, i, o, s, n, r, a) {
            void 0 === r && (r = -1), void 0 === a && (a = !1);
            var h = t.add.bitmapText(e, i, o, s, n);
            return h.anchor.setTo(.5, .5), h.align = "center", -1 != r && (h.tint = r), a && (h.cacheAsBitmap = !0), h
        }, c.changeState = function(t, e, i, o) {
            t.game.state.start(o[0])
        }, c.chageColor = function(t, e, i) {
            t.game.canvas.style.cursor = i[1], t.tint = i[0]
        }, c.addEvent = function(t, e, i, o, s, n, r, a) {
            void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = null), void 0 === a && (a = null), t.inputEnabled = !0, null != i && t.events.onInputUp.add(i, e, 0, o), null != s && t.events.onInputOver.add(s, e, 0, n), null != r && t.events.onInputOut.add(r, e, 0, a)
        }, c.setText = function(t) {
            t.hitArea = new Phaser.Rectangle(-t.width / 2 - .2 * t.width, -t.height / 2 - .4 * t.height, t.width + .4 * t.width, t.height + .6 * t.height)
        }, c.createButtonWithText = function(t, e, i, o, s, n, r, a) {
            void 0 === o && (o = ""), void 0 === s && (s = null), void 0 === n && (n = this), void 0 === r && (r = null), void 0 === a && (a = "menubutton");
            var h = t.add.group(),
                l = t.add.sprite(0, 0, "atlas", a + "1.png");
            if (l.anchor.setTo(.5, .5), this.addEvent(l, n, s, r, this.changeFrame, [a + "2.png", "pointer"], this.changeFrame, [a + "1.png", "default"]), h.add(l), l.events.onInputDown.add(this.changeFrame, n, 0, [a + "1.png", "default"]), "" != o) {
                var d = c.createText(t, 0, 0, "Cookies", o, 30, -1, !0);
                h.add(d), h.x = e, h.y = i
            }
            return h
        }, c.changeFrame = function(t, e, i) {
            t.game.canvas.style.cursor = i[1], t.frameName = i[0]
        }, c.getSprite = function(t, e, i, o, s, n, r, a) {
            var h;
            return void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === a && (a = !1), 3 <= o / i ? s ? (h = "cube" == e ? t.add.sprite(0, 0, "rmin_nf_v") : new Phaser.Sprite(t, 0, 0, "atlas", "min" + e + "vertical.png"), this.setParameter(h, 10, 30, 1, 0, 0), h.anchor.setTo(.5, .5)) : "cube" == e ? (h = a ? t.add.sprite(0, 0, "rf_nf_v") : t.add.sprite(0, 0, "r_nf_v"), this.setParameter(h, i, o, 1), h.anchor.setTo(.5, .5)) : "triangle" == e ? ((h = t.add.sprite(0, 0, "atlas", "bigtriangle.png")).anchor.setTo(.75, .75), this.setParameter(h, i, o, 1)) : "circle" == e && ((h = t.add.sprite(0, 0, "c_nf")).anchor.setTo(.5, .5), this.setParameter(h, i, o, 1)) : 3 <= i / o ? s ? (h = "cube" == e ? t.add.sprite(0, 0, "rmin_nf_h") : new Phaser.Sprite(t, 0, 0, "atlas", "min" + e + "horizontal.png"), this.setParameter(h, 30, 10, 1, 0, 0), h.anchor.setTo(.5, .5)) : "cube" == e ? ((h = a ? t.add.sprite(0, 0, "rf_nf_h") : t.add.sprite(0, 0, "r_nf_h")).anchor.setTo(.5, .5), this.setParameter(h, i, o, 1)) : "triangle" == e && ((h = t.add.sprite(0, 0, "atlas", "bigtriangle.png")).anchor.setTo(.75, .75), this.setParameter(h, i, o, 1)) : s ? ((h = new Phaser.Sprite(t, 0, 0, "atlas", "min" + e + ".png")).anchor.setTo(.5, .5), h.name = e, n && ("circle" == e ? this.addEye(h, t, .18) : "triangle" == e ? this.addEye(h, t, .2, s) : this.addEye(h, t, .2)), this.setParameter(h, 30, 30, 1, 0, 0)) : (a ? ("cube" == e ? h = t.add.sprite(0, 0, "rf_nf") : "triangle" == e ? h = t.add.sprite(0, 0, "atlas", "bigtriangle.png") : "circle" == e && (h = t.add.sprite(0, 0, "c_nf")), this.setParameter(h, i, o, 1), h.anchor.setTo(.5, .5)) : h = c.createFigureWithEyes(t, e, i, o, 0, 0), n && (h.name = e, this.addEye(h, t))), h.name = e, h.visible = r, h
        }, c.isNonStandart = function(t, e) {
            return 3 <= t / e || 3 <= e / t
        }, c.addEye = function(t, e, i, o) {
            var s, n;
            (void 0 === i && (i = 1), void 0 === o && (o = !1), t.height / t.width < 3 && t.width / t.height < 3) && ("cube" == t.name ? (n = c.createEye(e, -22 * i, -6 * i, 40 * i, 40 * i), s = c.createEye(e, 22 * i, -6 * i, 40 * i, 40 * i)) : "circle" == t.name ? (n = c.createEye(e, -25 * i, -15 * i, 40 * i, 40 * i), s = c.createEye(e, 25 * i, -15 * i, 40 * i, 40 * i)) : "triangle" == t.name && (s = o ? (n = c.createEye(e, 0 * i, 33 * i, 35 * i, 35 * i), c.createEye(e, 33 * i, 0 * i, 35 * i, 35 * i)) : (n = c.createEye(e, -33 * i, 0 * i, 35 * i, 35 * i), c.createEye(e, -5 * i, -32 * i, 35 * i, 35 * i)), n.angle = 320, s.angle = 320), t.addChild(s), t.addChild(n))
        }, c.createShare = function(t, e, i) {
            void 0 === e && (e = null), void 0 === i && (i = null);
            var o = t.add.group(),
                s = o.create(t.world.width / 2, t.world.height / 2, "atlas", "bkgshare.png");
            s.anchor.setTo(.5, .5), o.add(s);
            var n = this.createText(t, t.world.width / 2, 140, "Segoi", "LEVEL CODE/URL:", 30, 0, !0);
            n.anchor.setTo(.5, .5), o.add(n), (n = this.createText(t, t.world.width / 2, 250, "Segoi", "Copy this link", 16, 0, !0)).anchor.setTo(.5, .5), o.add(n);
            var r = o.create(t.world.width / 2, 275, "atlas", "bkgconfirm.png");
            r.width = 335, r.height = 120, r.anchor.setTo(.5, .5), o.add(r);
            var a = c.GAMEURL;
            a += "?level=", a += c.STATICDATA, a += "_";
            var h = c.setString(a += c.DYNAMICDATA);
            (l = c.createText(t, t.world.width / 2, 280, "Segoi", h, 14, 0, !0)).anchor.setTo(.5, .5), o.add(l), (l = c.createText(t, t.world.width / 2, 360, "Segoi", "Copy this link above and paste it where ever you\nlike. It links directly to you stack!", 14, 0, !1)).anchor.setTo(.5, .5), o.add(l);
            var l = c.createText(t, t.world.width / 2, 390, "Segoi", "Copy", 20, 0, !1);
            c.addEvent(l, i, function(t, e, i, o) {
                var s = document.getElementById("content"),
                    n = document.createElement("textarea");
                n.name = "post", n.style.position = "fixed", n.style.top = 0, n.style.left = 0, n.cols = "50", n.rows = "40", n.style.width = "2em", n.style.height = "2em", n.classList.add("js-cuttextarea"), n.style.padding = 0, n.style.border = "none", n.style.outline = "none", n.style.boxShadow = "none", n.style.background = "transparent", n.value = o, s.appendChild(n), n.select();
                try {
                    document.execCommand("copy")
                } catch (t) {}
                s.removeChild(n)
            }, [a], c.chageColor, [12079, "pointer"], c.chageColor, [0, "default"]), l.anchor.setTo(.5, .5), o.add(l), c.setText(l);
            l = c.createText(t, t.world.width / 2, 420, "Segoi", "Ok", 24, 0, !1);
            return c.addEvent(l, i, e, null, c.chageColor, [12079, "pointer"], c.chageColor, [0, "default"]), l.anchor.setTo(.5, .5), o.add(l), c.setText(l), o
        }, c.setString = function(t) {
            var e = "";
            e += t[0];
            for (var i = 1; i < t.length; ++i) {
                if (225 < i) return e;
                e += t[i], i % 45 == 0 && (e += "\n")
            }
            return e
        }, c.changeInputText = function(t, e) {
            t.setText(e)
        }, c.setParameter = function(t, e, i, o, s, n) {
            null != s && (t.x = s), null != n && (t.y = n), t.height = i, t.width = e, null != o && (t.alpha = o)
        }, c.STATICDATA = "", c.DYNAMICDATA = "", c.GAMEURL = "http://super-stacker-2.fbrq.io/super-stacker-2/index.html", c
    }();
    t.GameAPI = e
}(Stracker || (Stracker = {}));
var SaveAPI = function() {
        function t() {}
        return t.isCapable = function() {
            return !(void 0 === window.localStorage)
        }, t.getAccess = function(e) {
            if (!this.isCapable()) return null;
            try {
                return JSON.parse(localStorage.getItem(e))
            } catch (t) {
                return window.localStorage.getItem(e)
            }
        }, t.setAccess = function(t, e) {
            if (!this.isCapable()) return null;
            try {
                var i = window.localStorage.getItem(t);
                (i < e || null == i) && window.localStorage.setItem(t, JSON.stringify(e))
            } catch (t) {
                DOMException.QUOTA_EXCEEDED_ERR
            }
        }, t.setForce = function(t, e) {
            if (!this.isCapable()) return null;
            try {
                window.localStorage.setItem(t, JSON.stringify(e))
            } catch (t) {
                DOMException.QUOTA_EXCEEDED_ERR
            }
        }, t.clear = function() {
            if (!this.isCapable()) return null;
            window.localStorage.clear()
        }, t.generateDefaultData = function() {
            var t = new GameSave;
            t.levelState = [], t.speedRunState = [], t.bonusMode = !1, t.levelState.push(1);
            for (var e = 1; e < 40; e++) t.levelState.push(0);
            for (e = 0; e < 4; e++) t.speedRunState.push(0);
            return t
        }, t.UNIQ_ID = "UniqId", t.SOUND = "isSoundOn", t.MUSIC = "isMusicOn", t.SAVE_DATA = "SuperStracker2SaveData", t
    }(),
    GameSave = function() {};